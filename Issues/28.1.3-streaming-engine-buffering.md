# Issue 28.1.3 - Streaming Engine with Buffering

**Status:** Open  
**Priority:** High  
**Category:** Playback Engine  
**Created:** 2026-01-05  
**Parent Issue:** 28.1

## Description

Enhance AVPlayer integration to support streaming playback with intelligent buffering, buffer monitoring, and user feedback for buffering states.

## Spec Reference

See `spec/streaming-playback.md`:
- Starting Stream Playback
- Buffering During Playback
- Buffer Progress Indication
- Seeking While Streaming
- Slow Network Buffering
- HTTP Range Request Support

## Objectives

1. Monitor AVPlayer buffering state and progress
2. Provide buffer progress information to UI
3. Handle buffering delays gracefully (pause, resume)
4. Support HTTP Range requests for seeking
5. Optimize initial buffer before playback starts
6. Expose streaming state via async streams or Combine publishers

## API Design

```swift
@MainActor
public final class StreamingPlaybackEngine: ObservableObject {
    @Published private(set) var bufferProgress: Double = 0.0  // 0.0 to 1.0
    @Published private(set) var isBuffering: Bool = false
    @Published private(set) var streamingState: StreamingState = .idle
    
    // Start streaming from URL
    func startStreaming(url: URL) async throws
    
    // Query buffer status
    func bufferedDuration() -> TimeInterval
    func bufferedRange() -> ClosedRange<TimeInterval>?
    
    // Streaming state stream
    var streamingStateUpdates: AsyncStream<StreamingState> { get }
}

public enum StreamingState {
    case idle
    case initialBuffering
    case ready
    case playing
    case buffering  // Mid-playback buffering
    case paused
    case failed(Error)
}

public struct BufferInfo {
    let currentTime: TimeInterval
    let bufferedDuration: TimeInterval
    let totalDuration: TimeInterval
    let bufferProgress: Double  // bufferedDuration / totalDuration
}
```

## Implementation Requirements

### Core Functionality

1. **AVPlayerItem KVO Observation**
   - Observe `.loadedTimeRanges` for buffer progress
   - Observe `.isPlaybackBufferEmpty` for stall detection
   - Observe `.isPlaybackLikelyToKeepUp` for play/pause decisions
   - Observe `.status` for readiness

2. **Initial Buffering**
   - Wait for `.isPlaybackLikelyToKeepUp == true` before starting
   - Target: 5 seconds of buffered audio before playback
   - Show loading indicator during initial buffer
   - Timeout after 15 seconds if buffer doesn't fill

3. **Mid-Playback Buffering**
   - Detect when `.isPlaybackBufferEmpty == true`
   - Automatically pause playback
   - Show "Buffering..." indicator
   - Resume when `.isPlaybackLikelyToKeepUp == true`

4. **Buffer Progress Calculation**
   ```swift
   func calculateBufferProgress() -> Double {
       guard let item = player.currentItem,
             let timeRange = item.loadedTimeRanges.first as? CMTimeRange else {
           return 0.0
       }
       
       let bufferStart = CMTimeGetSeconds(timeRange.start)
       let bufferDuration = CMTimeGetSeconds(timeRange.duration)
       let bufferedEnd = bufferStart + bufferDuration
       
       let totalDuration = CMTimeGetSeconds(item.duration)
       guard totalDuration > 0 else { return 0.0 }
       
       return bufferedEnd / totalDuration
   }
   ```

5. **Range Request Support**
   - Use `AVURLAsset` with custom `AVAssetResourceLoader` delegate
   - Intercept requests for seeking
   - Add HTTP Range header for seek positions
   - Example: `Range: bytes=1000000-` for seeking forward

6. **Prefetching Strategy**
   - AVPlayer handles prefetching automatically
   - Optionally configure `preferredForwardBufferDuration` (default: ~10s)
   - Set to 30s on good networks, 10s on slow networks

### Testing Requirements

1. **Unit Tests** (`Packages/PlaybackEngine/Tests/`)
   - Buffer progress calculation
   - Streaming state transitions
   - KVO observation setup/teardown
   - Buffer info queries

2. **Integration Tests** (`IntegrationTests/`)
   - Stream from mock HTTP server
   - Simulate slow network (throttle bandwidth)
   - Verify initial buffering completes
   - Verify mid-playback buffering recovery

3. **UI Tests** (`zpodUITests/`)
   - Start streaming → buffering indicator appears
   - Buffer fills → playback starts
   - Seek far ahead → brief buffer pause
   - Use test HTTP server from 03.3.2.6 infrastructure

## Acceptance Criteria

- [ ] StreamingPlaybackEngine implemented with buffer monitoring
- [ ] `bufferProgress` published and updated every second during streaming
- [ ] `isBuffering` state accurate for initial and mid-playback buffering
- [ ] Initial buffer waits for `.isPlaybackLikelyToKeepUp` before starting
- [ ] Mid-playback buffer stalls pause automatically and resume when ready
- [ ] Buffer range queries return accurate time ranges
- [ ] KVO observers properly registered and removed (no leaks)
- [ ] Unit tests cover buffer calculations and state transitions
- [ ] Integration test streams from mock HTTP server
- [ ] UI test verifies buffering indicators appear correctly
- [ ] All spec scenarios from `streaming-playback.md` (buffering section) pass

## Dependencies

- **Requires:** AVPlayer playback engine (03.3 series)
- **Blocks:** 28.1.5 (playback coordinator needs streaming state)

## Technical Notes

### KVO Setup for Buffer Monitoring

```swift
private var observations: [NSKeyValueObservation] = []

func setupBufferObservation(for playerItem: AVPlayerItem) {
    // Loaded time ranges (buffer progress)
    observations.append(
        playerItem.observe(\.loadedTimeRanges, options: [.new]) { [weak self] item, _ in
            Task { @MainActor in
                self?.updateBufferProgress()
            }
        }
    )
    
    // Playback buffer empty (stall detection)
    observations.append(
        playerItem.observe(\.isPlaybackBufferEmpty, options: [.new]) { [weak self] item, _ in
            Task { @MainActor in
                self?.handleBufferStall()
            }
        }
    )
    
    // Playback likely to keep up (ready to play)
    observations.append(
        playerItem.observe(\.isPlaybackLikelyToKeepUp, options: [.new]) { [weak self] item, _ in
            Task { @MainActor in
                self?.handleBufferReady()
            }
        }
    )
}

func removeObservations() {
    observations.forEach { $0.invalidate() }
    observations.removeAll()
}
```

### Range Request with AVAssetResourceLoader

```swift
class RangeRequestResourceLoader: NSObject, AVAssetResourceLoaderDelegate {
    func resourceLoader(_ resourceLoader: AVAssetResourceLoader, 
                       shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -> Bool {
        
        guard let url = loadingRequest.request.url else { return false }
        
        // Build range request
        let requestedOffset = loadingRequest.dataRequest?.requestedOffset ?? 0
        let requestedLength = loadingRequest.dataRequest?.requestedLength ?? 0
        
        var request = URLRequest(url: url)
        request.setValue("bytes=\(requestedOffset)-\(requestedOffset + requestedLength - 1)", 
                        forHTTPHeaderField: "Range")
        
        // Fulfill request asynchronously...
        return true
    }
}
```

### Buffer Duration Configuration

```swift
// Optimize buffer size based on network
func configureBufferStrategy(networkSpeed: NetworkSpeed) {
    switch networkSpeed {
    case .fast:  // > 2 Mbps
        playerItem.preferredForwardBufferDuration = 30.0
    case .medium:  // 500 Kbps - 2 Mbps
        playerItem.preferredForwardBufferDuration = 20.0
    case .slow:  // < 500 Kbps
        playerItem.preferredForwardBufferDuration = 10.0
    }
}
```

## Out of Scope

- Adaptive bitrate streaming (HLS/DASH) - Future enhancement
- Custom buffering algorithms beyond AVPlayer defaults
- Offline caching of streamed segments
- Bandwidth throttling controls

## Dev Log

Document buffering strategy, KVO patterns, and test results in:
`dev-log/28.1.3-streaming-engine-buffering.md`

---

**Related Issues:** 28.1 (parent), 28.1.4 (network monitoring), 28.1.5 (playback coordinator)  
**Estimated Effort:** 2-3 days
