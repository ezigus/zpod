# Issue 03.3.2.2: Playback Ticker Test Suite

**Status**: ⚠️ In Review

**Priority**: High

**Parent**: 03.3.2 - AVPlayer Playback Engine (#267)

**GitHub Issue**: [#297](https://github.com/ezigus/zpod/issues/297)

**Estimated Effort**: 1.5 hours

## Description

Create a dedicated test suite for playback position validation using the Ticker engine. These tests run fast (~15 seconds total), are deterministic, and validate UI state management without requiring audio hardware.

## Problem Statement

**Current State**:
- `PlaybackPositionUITests.swift` mixes ticker tests with no clear mode distinction
- Tests assume ticker behavior but don't explicitly configure it
- No clear separation between UI logic tests and audio integration tests

**Target State**:
- `PlaybackPositionTickerTests.swift` explicitly uses ticker mode
- 5 tests covering core playback position scenarios
- Fast, deterministic execution (~3 seconds per test)
- Clear documentation of ticker mode purpose and scope

## Technical Design

### Test Class Structure

```swift
/// UI tests for playback position using the Ticker engine (deterministic timing).
///
/// **Issue**: 03.3.2.2 - Playback Ticker Test Suite
/// **Mode**: Ticker (UITEST_DISABLE_AUDIO_ENGINE=1)
/// **Spec**: `zpod/spec/playback.md` - Core Playback Behavior
///
/// These tests validate position UI updates using the deterministic TimerTicker.
/// Fast execution (~10-15 seconds per test), no audio hardware required.
///
/// **CI Job**: UITests-PlaybackTicker
final class PlaybackPositionTickerTests: XCTestCase, PlaybackPositionTestSupport {
    nonisolated(unsafe) var app: XCUIApplication!
    static let logger = Logger(subsystem: "us.zig.zpod", category: "PlaybackPositionTickerTests")
    
    @MainActor
    private func launchApp() {
        app = launchConfiguredApp(
            environmentOverrides: [
                "UITEST_POSITION_DEBUG": "1",
                "UITEST_DISABLE_AUDIO_ENGINE": "1"
            ]
        )
    }
    
    // Test methods...
}
```

### Test Scenarios

| Test | Spec Reference | Validates |
|------|----------------|-----------|
| `testExpandedPlayerProgressAdvancesDuringPlayback` | Timeline Advancement | Position increases during playback |
| `testPositionStopsAdvancingWhenPaused` | Pausing Playback | Position freezes when paused |
| `testPositionResumesAdvancingAfterPause` | Resuming Playback | Position continues after resume |
| `testSeekingUpdatesPositionImmediately` | Seeking to Position | Seek updates position, playback continues |
| `testMiniPlayerReflectsPlaybackState` | Timeline Advancement (Mini) | Mini-player shows correct state |

## Acceptance Criteria

- [x] `PlaybackPositionTickerTests.swift` created with 7 test methods (was 5, added seek-while-paused + initial-position-zero)
- [x] All tests launch with `UITEST_DISABLE_AUDIO_ENGINE=1` via `launchWithPlaybackMode(.ticker)`
- [x] All tests conform to `PlaybackPositionTestSupport` protocol
- [x] Test 1: Position advances during playback (validates ≥1s advancement)
- [x] Test 2: Position stops when paused (validates stability within ±0.1s)
- [x] Test 3: Position resumes after pause (validates ≥1s advancement)
- [x] Test 4: Seeking updates position immediately (validates minimum 3s delta)
- [x] Test 5: Mini-player reflects playback state (validates button states)
- [x] Test 6: Seeking while paused updates position (spec line 83: "playing or paused")
- [x] Test 7: Initial position starts at 0 (spec line 59: "position starts at 0")
- [x] All tests use 5s timeout for position advancement
- [x] All tests use ±0.1s tolerance for position stability
- [ ] All tests complete in <30 seconds total (was <20s, extended for 2 new tests)
- [ ] All tests pass locally via `./scripts/run-xcode-tests.sh -t PlaybackPositionTickerTests`

## Spec References

See `zpod/spec/playback.md`:

### Test 1 & 5: Timeline Advancement During Playback (lines 62-68)
```gherkin
Given an episode is playing
When the playback is in progress
Then the timeline position advances
And the elapsed time is updated in the player
And the lock screen / Control Center shows the current position
```

### Test 2: Pausing Playback (lines 69-75)
```gherkin
Given an episode is playing
When the user taps the pause button
Then playback stops immediately
And the progress bar stops advancing
```

### Test 3: Resuming Playback (lines 76-82)
```gherkin
Given an episode is paused
When the user taps the play button
Then playback resumes from the previous position
And the progress bar continues advancing
```

### Test 4: Seeking to Position (lines 83-87)
```gherkin
Given an episode is playing or paused
When the user drags the progress slider
Then playback jumps to the selected position immediately
```

## Files to Create

| File | Lines | Purpose |
|------|-------|---------|
| `zpodUITests/PlaybackPositionTickerTests.swift` | ~180 | Ticker test suite |

## Implementation Steps

### Step 1: Create Test File (10 minutes)

1. Create `zpodUITests/PlaybackPositionTickerTests.swift`
2. Add file header with issue reference
3. Add imports: `OSLog`, `XCTest`
4. Define class conforming to `XCTestCase` and `PlaybackPositionTestSupport`
5. Add `app` property and `logger`
6. Add `setUpWithError()` and `tearDownWithError()`
7. Add `launchApp()` helper with ticker mode configuration

### Step 2: Implement Test 1 - Position Advancement (15 minutes)

```swift
/// **Spec**: Timeline Advancement During Playback
/// **Given**: An episode is playing
/// **When**: Time passes during playback
/// **Then**: Progress slider position advances
@MainActor
func testExpandedPlayerProgressAdvancesDuringPlayback() throws {
    // Given: Episode is playing
    launchApp()
    guard startPlayback() else {
        XCTFail("Failed to start playback")
        return
    }
    
    guard expandPlayer() else {
        XCTFail("Failed to expand player")
        return
    }
    
    // Capture initial slider value
    let initialValue = getSliderValue()
    XCTAssertNotNil(initialValue, "Progress slider should have an initial value")
    let initialPosition = extractCurrentPosition(from: initialValue)
    
    // When: Wait for position to advance (ticker updates every 0.5s)
    let updatedValue = waitForPositionAdvancement(beyond: initialValue, timeout: 5.0)
    
    // Then: Progress slider should show advanced position
    XCTAssertNotNil(updatedValue, "Progress slider should have advanced")
    let updatedPosition = extractCurrentPosition(from: updatedValue)
    
    if let initial = initialPosition, let updated = updatedPosition {
        XCTAssertGreaterThan(updated, initial)
        XCTAssertGreaterThanOrEqual(updated - initial, 1.0,
            "Position should advance at least 1.0s during playback")
    } else {
        XCTFail("Could not parse position values")
    }
}
```

### Step 3: Implement Test 2 - Pause Stops Position (15 minutes)

```swift
/// **Spec**: Pausing Playback
/// **Given**: An episode is playing with advancing position
/// **When**: User pauses playback
/// **Then**: Position stops advancing
@MainActor
func testPositionStopsAdvancingWhenPaused() throws {
    launchApp()
    guard startPlayback(), expandPlayer() else {
        XCTFail("Failed to start playback and expand player")
        return
    }
    
    // Wait for initial position advancement
    let initialValue = getSliderValue()
    _ = waitForPositionAdvancement(beyond: initialValue, timeout: 3.0)
    
    // When: Pause playback
    let pauseButton = app.buttons.matching(identifier: "Expanded Player Pause").firstMatch
    XCTAssertTrue(pauseButton.waitForExistence(timeout: adaptiveShortTimeout))
    pauseButton.tap()
    
    // Verify play button appears
    let playButton = app.buttons.matching(identifier: "Expanded Player Play").firstMatch
    XCTAssertTrue(playButton.waitForExistence(timeout: adaptiveShortTimeout))
    
    // Then: Verify position remains stable
    let pausedValue = getSliderValue()
    let positionStable = verifyPositionStable(at: pausedValue, forDuration: 2.0, tolerance: 0.1)
    XCTAssertTrue(positionStable, "Position should remain stable when paused")
}
```

### Step 4: Implement Test 3 - Resume Advances Position (15 minutes)

```swift
/// **Spec**: Resuming Playback
/// **Given**: An episode is paused
/// **When**: User resumes playback
/// **Then**: Position resumes advancing from paused position
@MainActor
func testPositionResumesAdvancingAfterPause() throws {
    launchApp()
    guard startPlayback(), expandPlayer() else {
        XCTFail("Failed to start playback and expand player")
        return
    }
    
    // Pause playback
    let pauseButton = app.buttons.matching(identifier: "Expanded Player Pause").firstMatch
    XCTAssertTrue(pauseButton.waitForExistence(timeout: adaptiveShortTimeout))
    pauseButton.tap()
    
    let playButton = app.buttons.matching(identifier: "Expanded Player Play").firstMatch
    XCTAssertTrue(playButton.waitForExistence(timeout: adaptiveShortTimeout))
    
    let pausedValue = getSliderValue()
    let pausedPosition = extractCurrentPosition(from: pausedValue)
    
    // When: Resume playback
    playButton.tap()
    XCTAssertTrue(pauseButton.waitForExistence(timeout: adaptiveShortTimeout))
    
    // Then: Position should advance
    let resumedValue = waitForPositionAdvancement(beyond: pausedValue, timeout: 5.0)
    XCTAssertNotNil(resumedValue, "Position should advance after resuming")
    
    if let paused = pausedPosition,
       let resumed = extractCurrentPosition(from: resumedValue) {
        XCTAssertGreaterThan(resumed, paused)
        XCTAssertGreaterThanOrEqual(resumed - paused, 1.0)
    }
}
```

### Step 5: Implement Test 4 - Seeking Updates Position (20 minutes)

```swift
/// **Spec**: Seeking to Position
/// **Given**: An episode is playing
/// **When**: User seeks to a new position
/// **Then**: Position updates immediately and continues advancing
@MainActor
func testSeekingUpdatesPositionImmediately() throws {
    logBreadcrumb("testSeekingUpdatesPositionImmediately: launch app")
    launchApp()
    guard startPlayback(), expandPlayer() else {
        XCTFail("Failed to start playback and expand player")
        return
    }
    
    let initialValue = getSliderValue()
    logSliderValue("initial", value: initialValue)
    
    // When: Seek to 50% position
    let slider = app.sliders.matching(identifier: "Progress Slider").firstMatch
    XCTAssertTrue(slider.waitForExistence(timeout: adaptiveShortTimeout))
    
    logBreadcrumb("testSeekingUpdatesPositionImmediately: seek to 50%")
    let preSeekValue = getSliderValue()
    slider.adjust(toNormalizedSliderPosition: 0.5)
    
    // Then: Wait for position to change significantly
    let seekedValue = waitForUIStabilization(
        afterSeekingFrom: preSeekValue,
        timeout: 3.0,
        minimumDelta: 3.0,
        stabilityWindow: 0.3
    )
    logSliderValue("seeked", value: seekedValue)
    XCTAssertNotNil(seekedValue, "Slider value should change after seek")
    
    // Verify position continues advancing after seek
    let finalValue = waitForPositionAdvancement(beyond: seekedValue, timeout: 5.0)
    logSliderValue("final", value: finalValue)
    XCTAssertNotNil(finalValue, "Position should continue advancing after seek")
}
```

### Step 6: Implement Test 5 - Mini-Player State (10 minutes)

```swift
/// **Spec**: Timeline Advancement During Playback (Mini-Player)
/// **Given**: An episode is playing
/// **When**: Mini-player is visible
/// **Then**: Mini-player reflects playback state
@MainActor
func testMiniPlayerReflectsPlaybackState() throws {
    launchApp()
    guard startPlayback() else {
        XCTFail("Failed to start playback")
        return
    }
    
    // Then: Mini-player should show pause button
    let miniPlayer = miniPlayerElement(in: app)
    XCTAssertTrue(miniPlayer.exists)
    
    let pauseButton = app.buttons.matching(identifier: "Mini Player Pause").firstMatch
    XCTAssertTrue(pauseButton.waitForExistence(timeout: adaptiveShortTimeout))
    
    // When: Pause via mini-player
    pauseButton.tap()
    
    // Then: Play button should appear
    let playButton = app.buttons.matching(identifier: "Mini Player Play").firstMatch
    XCTAssertTrue(playButton.waitForExistence(timeout: adaptiveShortTimeout))
}
```

### Step 7: Validate Tests (15 minutes)

1. Build zpodUITests target
2. Run ticker tests: `./scripts/run-xcode-tests.sh -t zpodUITests/PlaybackPositionTickerTests`
3. Verify all 5 tests pass
4. Verify total execution time < 20 seconds
5. Check for flakiness (run 3 times)

## Testing Strategy

### Local Validation
```bash
# Build tests
xcodebuild -workspace zpod.xcworkspace -scheme zpod build-for-testing

# Run ticker suite only
./scripts/run-xcode-tests.sh -t zpodUITests/PlaybackPositionTickerTests

# Expected output:
# Test Suite 'PlaybackPositionTickerTests' passed at 2026-01-04 10:15:23.456
# Executed 5 tests, with 0 failures (0 unexpected) in 14.234 (14.567) seconds
```

### CI Integration (Next Phase)
- Will be added to `UITests-PlaybackTicker` job in CI workflow
- Expected execution time: ~3 minutes (includes simulator provisioning)

## Dependencies

- **03.3.2.1**: Shared infrastructure (protocol, helpers) MUST be complete
- **03.3.1**: Ticker implementation (already complete)
- **Next**: 03.3.2.4 (CI configuration) will add this suite to CI

## Notes

### Why Ticker Tests First?

1. **Fast feedback**: 15s vs 45s for AVPlayer tests
2. **Deterministic**: No network/hardware dependencies
3. **UI logic validation**: Ensures state management works before testing audio
4. **Baseline**: If these fail, AVPlayer tests would fail too

### Ticker Mode Characteristics

- Position updates every 0.5 seconds (same as AVPlayer)
- No actual audio output
- No buffering delays
- No network latency
- Predictable, repeatable behavior

### Test Timeouts

| Operation | Timeout | Rationale |
|-----------|---------|-----------|
| Position advancement | 5s | Ticker updates every 0.5s, allow 10x margin |
| UI element appearance | 3s | SmartUITesting adaptive timeout |
| Position stability check | 2s | Verify no drift over 2 seconds |
| Seek UI stabilization | 3s | Wait for seek + 1 tick |

## Estimated Effort

**1.5 hours total**:
- File setup: 10 minutes
- Test 1 (advancement): 15 minutes
- Test 2 (pause): 15 minutes
- Test 3 (resume): 15 minutes
- Test 4 (seeking): 20 minutes
- Test 5 (mini-player): 10 minutes
- Validation and fixes: 15 minutes

## Success Criteria

| Criterion | Verification | Status |
|-----------|--------------|--------|
| All 5 tests implemented | File contains 5 test methods | ⏳ |
| All tests pass locally | run-xcode-tests.sh passes | ⏳ |
| Total execution < 20s | Check test log timing | ⏳ |
| No flakiness | 3 consecutive passes | ⏳ |
| Ticker mode verified | UITEST_DISABLE_AUDIO_ENGINE=1 set | ⏳ |
| Protocol conformance | Uses shared helpers | ⏳ |
