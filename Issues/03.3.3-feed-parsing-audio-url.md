# Issue 03.3.3: Feed Parsing - Populate audioURL & Duration

**Status**: âœ… COMPLETE (merged to `main`)

**Priority**: High

**Parent**: 03.3 - Audio Playback Implementation

**GitHub Issue**: [#268](https://github.com/ezigus/zpod/issues/268)

## Description

Ensure the RSS feed parser extracts audio URLs and duration metadata from podcast feeds, populating `Episode.audioURL` and `Episode.duration` properties. Currently, sample episodes use placeholder URLs (e.g., `example.com`) that cannot be played.

## Problem Statement

**Current State**:
- Sample/test episodes have placeholder URLs
- Feed parsing may not extract `<enclosure>` URLs correctly
- Duration may come from feed but isn't always populated

**Target State**:
- Real podcast feeds populate `Episode.audioURL` with playable URLs
- Duration extracted from `<itunes:duration>` or `<enclosure length>`
- Invalid URLs handled gracefully (logged, not crashed)

## RSS Feed Structure

### Standard RSS 2.0 Enclosure
```xml
<item>
  <title>Episode Title</title>
  <enclosure url="https://podcast.example.com/episode.mp3"
             length="12345678"
             type="audio/mpeg"/>
  <itunes:duration>3600</itunes:duration>  <!-- seconds or HH:MM:SS -->
</item>
```

### Parsing Requirements

| RSS Element | Episode Property | Notes |
|-------------|------------------|-------|
| `<enclosure url="...">` | `audioURL: URL?` | Required for playback |
| `<itunes:duration>` | `duration: TimeInterval` | May be "3600" or "1:00:00" |
| `<enclosure length="...">` | (optional) `fileSize: Int64?` | For download estimates |
| `<enclosure type="...">` | (optional) `mimeType: String?` | Usually "audio/mpeg" |

## Acceptance Criteria

- [x] `<enclosure url>` extracted and assigned to `Episode.audioURL` (first valid enclosure wins)
- [x] URL validated as parseable; invalid enclosure URLs ignored and logged as warnings
- [x] `<itunes:duration>` parsed (seconds, HH:MM:SS, and MM:SS formats)
- [x] Duration assigned to `Episode.duration`
- [x] Missing enclosure logged but doesn't crash
- [x] Invalid URL format logged distinctly from missing
- [x] Unit tests with real RSS feed samples (ATP, The Talk Show fixtures)
- [x] Sample feeds from popular podcasts verified working via parser tests

## Spec References

See `zpod/spec/discovery.md` - Feed Parsing section:
- **Parsing Episode Audio Enclosure** - Extract audioURL from `<enclosure>` element
- **Parsing Episode Duration** - Handle seconds and HH:MM:SS formats
- **Handling Missing Audio Enclosure** - Create episode with nil audioURL, log warning

## Files to Modify

| File | Changes |
|------|---------|
| `Packages/FeedParsing/Sources/FeedParsing/RSSParser.swift` | Extract enclosure URL and duration |
| `Packages/FeedParsing/Sources/FeedParsing/DurationParser.swift` | CREATE - parse duration formats |
| `Packages/CoreModels/Sources/CoreModels/Episode.swift` | Ensure `audioURL: URL?` property exists |
| `Packages/FeedParsing/Tests/FeedParsingTests/RSSParserTests.swift` | Add enclosure parsing tests |

## Implementation Steps

### 1. Verify Episode Model
```swift
// CoreModels/Episode.swift
public struct Episode: Identifiable, Sendable {
    public let id: UUID
    public let title: String
    public let audioURL: URL?        // Ensure this exists
    public let duration: TimeInterval // Ensure this exists
    // ... other properties
}
```

### 2. Parse Enclosure in RSS Parser
```swift
// FeedParsing/RSSParser.swift
private func parseEpisode(from item: XMLElement) -> Episode {
    // ... existing parsing ...

    // Extract enclosure
    let enclosureURL: URL?
    if let enclosureElement = item.firstChild(named: "enclosure"),
       let urlString = enclosureElement.attribute(named: "url"),
       let url = URL(string: urlString) {
        enclosureURL = url
    } else {
        enclosureURL = nil
        Logger.warning("Episode '\(title)' missing audio enclosure")
    }

    // Extract duration
    let duration = parseDuration(from: item)

    return Episode(
        // ... other properties ...
        audioURL: enclosureURL,
        duration: duration
    )
}
```

### 3. Create Duration Parser
```swift
// FeedParsing/DurationParser.swift
public enum DurationParser {
    /// Parses iTunes duration format (seconds or HH:MM:SS)
    public static func parse(_ string: String) -> TimeInterval? {
        // Try as plain seconds first
        if let seconds = TimeInterval(string) {
            return seconds
        }

        // Try HH:MM:SS or MM:SS format
        let components = string.split(separator: ":")
        switch components.count {
        case 2: // MM:SS
            guard let minutes = Int(components[0]),
                  let seconds = Int(components[1]) else { return nil }
            return TimeInterval(minutes * 60 + seconds)
        case 3: // HH:MM:SS
            guard let hours = Int(components[0]),
                  let minutes = Int(components[1]),
                  let seconds = Int(components[2]) else { return nil }
            return TimeInterval(hours * 3600 + minutes * 60 + seconds)
        default:
            return nil
        }
    }
}
```

## Testing Strategy

### Unit Tests
- Parse enclosure URL correctly
- Parse duration as seconds
- Parse duration as MM:SS
- Parse duration as HH:MM:SS
- Handle missing enclosure (nil, no crash)
- Handle malformed URL (nil, no crash)
- Handle missing duration (default to 0 or nil)

### Integration Tests
- Parse real RSS feeds from popular podcasts
- Verify URLs are actually reachable (optional, network test)

### Sample Feeds for Testing
- ATP (Accidental Tech Podcast)
- The Talk Show
- Swift by Sundell
- Any feed from Apple Podcasts directory

## Dependencies

- None - can be implemented in parallel with other issues
- Feeds must be subscribed/loaded before this matters

## Estimated Effort

**Medium** - 2-3 hours
- RSS parsing structure likely exists
- Duration parsing is straightforward
- Most effort in testing with real feeds

## Notes

- Some feeds use non-standard elements (e.g., `<media:content>`)
- Consider fallback parsing for alternate formats
- URL validation should be lenient (some feeds have edge cases)
- Consider caching parsed audio URLs in persistence layer
