# Issue 03.3.4.1: Extend PlaybackError Enum with Network/Missing URL Cases

**Status**: âœ… Complete (2026-01-08)

**Priority**: High

**Parent**: 03.3.4 - Unplayable Episode UX & Diagnostics (#269)

**GitHub Issue**: [#318](https://github.com/ezigus/zpod/issues/318)

**Estimated Effort**: 30 minutes

## Description

Extend the existing `PlaybackError` enum in `SharedUtilities/PlaybackAlerts.swift` to support missing audio URL and network error cases. These are currently not represented but are needed for the edge-case tests in Issue 03.3.2.7.

## Problem Statement

**Current State**:
- `PlaybackError` has: `.episodeUnavailable`, `.resumeStateExpired`, `.persistenceCorrupted`, `.streamFailed`, `.unknown`
- No specific case for **missing audioURL** (nil URL)
- No specific case for **network errors** (timeout, connection failed)
- No way to distinguish recoverable vs non-recoverable errors

**Target State**:
- Add `.missingAudioURL` case
- Add `.networkError` case  
- Add `.timeout` case
- Add `isRecoverable` computed property
- Add `userMessage` computed property
- Maintain backward compatibility with existing error cases

## Technical Design

### New Error Cases

```swift
// Packages/SharedUtilities/Sources/SharedUtilities/PlaybackAlerts.swift

public enum PlaybackError: Equatable, Sendable {
  // Existing cases
  case episodeUnavailable
  case resumeStateExpired
  case persistenceCorrupted
  case streamFailed
  case unknown(message: String?)
  
  // NEW: Network/URL errors (Issue 03.3.4.1)
  case missingAudioURL
  case networkError
  case timeout
}

public extension PlaybackError {
  // NEW: Recoverability check
  var isRecoverable: Bool {
    switch self {
    case .networkError, .timeout:
      return true  // User can retry
    case .missingAudioURL, .episodeUnavailable, .resumeStateExpired, .persistenceCorrupted, .streamFailed, .unknown:
      return false  // Cannot recover
    }
  }
  
  // NEW: User-facing message
  var userMessage: String {
    switch self {
    case .missingAudioURL:
      return "This episode doesn't have audio available"
    case .networkError:
      return "Unable to load episode. Check your connection."
    case .timeout:
      return "Loading timed out. Tap to retry."
    case .episodeUnavailable:
      return "The episode you were listening to is no longer available."
    case .resumeStateExpired:
      return "Your previous listening session expired."
    case .persistenceCorrupted:
      return "We couldn't access your last listening position."
    case .streamFailed:
      return "Playback failed. Please try again."
    case .unknown(let message):
      return message ?? "An unknown error occurred"
    }
  }
  
  // Existing descriptor() method - update to include new cases
  func descriptor() -> PlaybackAlertDescriptor {
    switch self {
    case .missingAudioURL:
      return PlaybackAlertDescriptor(
        title: "Audio Not Available",
        message: userMessage,
        style: .error
      )
    case .networkError:
      return PlaybackAlertDescriptor(
        title: "Connection Error",
        message: userMessage,
        style: .error
      )
    case .timeout:
      return PlaybackAlertDescriptor(
        title: "Request Timed Out",
        message: userMessage,
        style: .error
      )
    // ... existing cases remain unchanged
    }
  }
}
```

## Acceptance Criteria

- [ ] Add `.missingAudioURL` case to `PlaybackError` enum
- [ ] Add `.networkError` case to `PlaybackError` enum
- [ ] Add `.timeout` case to `PlaybackError` enum
- [ ] Add `isRecoverable` computed property
- [ ] Add `userMessage` computed property
- [ ] Update `descriptor()` method for new cases
- [ ] All existing tests still pass (backward compatibility)
- [ ] New cases are `Equatable` and `Sendable`

## Files to Modify

- `Packages/SharedUtilities/Sources/SharedUtilities/PlaybackAlerts.swift` (~40 lines added)

## Testing Strategy

### Unit Tests (add to SharedUtilitiesTests)

```swift
func testPlaybackErrorRecoverability() {
  XCTAssertTrue(PlaybackError.networkError.isRecoverable)
  XCTAssertTrue(PlaybackError.timeout.isRecoverable)
  XCTAssertFalse(PlaybackError.missingAudioURL.isRecoverable)
  XCTAssertFalse(PlaybackError.streamFailed.isRecoverable)
}

func testPlaybackErrorUserMessages() {
  XCTAssertEqual(
    PlaybackError.missingAudioURL.userMessage,
    "This episode doesn't have audio available"
  )
  XCTAssertEqual(
    PlaybackError.networkError.userMessage,
    "Unable to load episode. Check your connection."
  )
}
```

## Dependencies

- **None** - This is the foundation for other 03.3.4.x issues
- **Unblocks**: 03.3.4.2 (Mini-Player Error UI)
- **Unblocks**: 03.3.4.3 (Expanded Player Error UI)

## Notes

**Why separate `networkError` and `timeout`?**
- Different user messages
- Timeout specifically indicates the request took too long
- Network error is more general (connection failed, DNS issues, etc.)

**Backward Compatibility**:
- All existing error cases remain unchanged
- Existing `descriptor()` calls still work
- New properties are additive (don't break existing code)

**Deferred Cases (Not in Scope)**:
- `.serverError` - Could be added if we need to distinguish server-side failures from client network issues
- `.formatNotSupported` - Could be added if AVPlayer reports unsupported codec/format errors
- These can be added in a follow-up issue if needed; the current scope covers the most common error scenarios
