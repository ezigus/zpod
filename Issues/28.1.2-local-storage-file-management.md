# Issue 28.1.2 - Local Storage and File Management

**Status:** Complete  
**Priority:** High  
**Category:** Core Services  
**Created:** 2026-01-05  
**Completed:** 2026-02-10  
**Parent Issue:** 28.1

## Description

Implement storage management for downloaded episode audio files, including file organization, space monitoring, deletion, and metadata tracking.

## Spec Reference

See `spec/offline-playback.md`:
- Downloaded Episodes Storage Location
- Storage Space Monitoring
- Manual Episode Deletion
- Bulk Episode Deletion

## Objectives

1. Store downloaded audio files in app Documents directory
2. Organize files by podcast/episode for easy management
3. Track storage usage per podcast and globally
4. Provide APIs to delete individual or bulk episodes
5. Handle edge cases (storage full, file corruption, orphaned files)
6. Maintain mapping between episodes and local file URLs

## API Design

```swift
@MainActor
public final class DownloadStorageManager: ObservableObject {
    // Singleton instance
    static let shared = DownloadStorageManager()
    
    // Storage queries
    func isDownloaded(episodeID: String) -> Bool
    func localURL(for episodeID: String) -> URL?
    func downloadedEpisodeIDs() -> [String]
    
    // Storage operations
    func moveDownloadedFile(from tempURL: URL, for episode: Episode) async throws -> URL
    func deleteDownload(for episodeID: String) async throws
    func deleteAllDownloads(for podcastID: String) async throws
    func deleteAllDownloads() async throws
    
    // Storage monitoring
    func totalStorageUsed() -> Int64  // Bytes
    func storageUsed(by podcastID: String) -> Int64
    func availableDeviceStorage() -> Int64
    func downloadedEpisodeCount() -> Int
    
    // Maintenance
    func cleanupOrphanedFiles() async
    func verifyFileIntegrity(for episodeID: String) async -> Bool
}

public struct StorageInfo {
    let totalUsed: Int64
    let availableSpace: Int64
    let episodeCount: Int
    let podcastBreakdown: [String: PodcastStorageInfo]
}

public struct PodcastStorageInfo {
    let podcastID: String
    let podcastTitle: String
    let storageUsed: Int64
    let episodeCount: Int
}
```

## Implementation Requirements

### File Organization

**Directory Structure:**
```
Documents/
└── Downloads/
    ├── <podcast-id-1>/
    │   ├── <episode-id-1>.m4a
    │   ├── <episode-id-2>.mp3
    │   └── metadata.json  (episode info, download date)
    ├── <podcast-id-2>/
    │   ├── <episode-id-3>.m4a
    │   └── metadata.json
    └── .storage-index.json  (global index)
```

**Benefits:**
- Easy bulk deletion by podcast
- Storage breakdown per podcast
- Metadata preserved alongside audio
- Easy cleanup of orphaned files

### Core Functionality

1. **File Naming**
   - Sanitize episode IDs for filesystem compatibility
   - Preserve original extension (.mp3, .m4a, .aac, .wav)
   - No URL encoding in filenames (use episode ID directly)

2. **Atomic Operations**
   - Downloads write to temp directory first
   - Move to final location only on success
   - Use `FileManager.replaceItemAt()` for atomic moves
   - Never leave partial/corrupted files

3. **Metadata Storage**
   - Store per-podcast `metadata.json` with episode list
   - Include: episode ID, title, download date, file size
   - Global index for fast "is downloaded?" queries
   - Update atomically on every change

4. **Storage Monitoring**
   - Cache storage calculations (recalculate on change)
   - Use `FileManager.attributesOfItem()` for file sizes
   - Monitor device storage with `systemFreeSize` attribute
   - Alert user when storage is low (< 500 MB remaining)

5. **Deletion**
   - Single episode: Remove file + update metadata
   - Bulk podcast: Remove entire podcast directory
   - Global cleanup: Iterate all podcasts
   - Update index after every deletion

6. **Integrity Checks**
   - Verify file exists at expected path
   - Check file size matches metadata
   - Optionally validate audio format (AVAsset)
   - Remove corrupted files and mark for re-download

### Testing Requirements

1. **Unit Tests** (`Packages/PlaybackEngine/Tests/`)
   - Create directory structure for new podcast
   - Move downloaded file to correct location
   - Delete individual episode
   - Bulk delete all episodes for podcast
   - Calculate storage used correctly
   - Cleanup orphaned files

2. **Integration Tests** (`IntegrationTests/`)
   - Download → Store → Verify → Delete workflow
   - Simulate storage full scenario
   - Restore state after app restart

3. **Manual Tests**
   - Open Files app → Browse to Downloads directory
   - Verify file structure matches design
   - Delete app → Reinstall → Verify files persist

## Acceptance Criteria

- [ ] Downloads stored in `Documents/Downloads/<podcast-id>/<episode-id>.<ext>`
- [ ] Metadata JSON files track episode info per podcast
- [ ] Global index enables fast "is downloaded?" queries
- [ ] Storage usage calculated accurately (per podcast, total)
- [ ] Device storage availability monitored
- [ ] Single episode deletion works correctly
- [ ] Bulk podcast deletion removes entire directory
- [ ] Orphaned file cleanup removes files without metadata entries
- [ ] File integrity verification detects corrupted files
- [ ] All operations are atomic (no partial states)
- [ ] Unit tests cover all storage operations
- [ ] Integration test covers full download-to-delete lifecycle

## Dependencies

- **Requires:** Episode model, DownloadManager (28.1.1)
- **Blocks:** 28.1.5 (playback coordinator needs storage queries)
- **Related:** 28.1.8 (episode metadata persistence for Siri snapshots)

## Technical Notes

### Atomic File Move

```swift
func moveDownloadedFile(from tempURL: URL, for episode: Episode) async throws -> URL {
    let finalURL = downloadURL(for: episode)
    
    // Create podcast directory if needed
    try FileManager.default.createDirectory(at: finalURL.deletingLastPathComponent(), 
                                           withIntermediateDirectories: true)
    
    // Atomic move
    try FileManager.default.moveItem(at: tempURL, to: finalURL)
    
    // Update metadata
    try await updateMetadata(for: episode, fileURL: finalURL)
    
    return finalURL
}
```

### Storage Calculation

```swift
func totalStorageUsed() -> Int64 {
    let downloadsURL = documentsDirectory.appendingPathComponent("Downloads")
    
    guard let enumerator = FileManager.default.enumerator(at: downloadsURL, 
                                                          includingPropertiesForKeys: [.fileSizeKey]) else {
        return 0
    }
    
    var totalSize: Int64 = 0
    for case let fileURL as URL in enumerator {
        guard let attributes = try? FileManager.default.attributesOfItem(atPath: fileURL.path),
              let fileSize = attributes[.size] as? Int64 else { continue }
        totalSize += fileSize
    }
    
    return totalSize
}
```

### Metadata Format

```json
{
  "podcastID": "podcast-123",
  "podcastTitle": "My Favorite Podcast",
  "episodes": [
    {
      "episodeID": "ep-456",
      "title": "Episode 1",
      "fileName": "ep-456.m4a",
      "fileSize": 52428800,
      "downloadDate": "2026-01-05T10:30:00Z"
    }
  ],
  "totalSize": 52428800,
  "lastUpdated": "2026-01-05T10:30:00Z"
}
```

## Out of Scope

- Cloud sync of downloaded files (future)
- Automatic cleanup policies (future)
- File encryption (future security enhancement)
- Compression of metadata (not needed for scale)

## Dev Log

Document file structure decisions, edge cases handled, and test results in:
`dev-log/28.1.2-local-storage-file-management.md`

---

**Related Issues:** 28.1 (parent), 28.1.1 (download manager), 28.1.6 (UI integration)  
**Estimated Effort:** 1-2 days
