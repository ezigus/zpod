# Issue 28.1.4 - Network Monitoring and Adaptation

**Status:** Open  
**Priority:** Medium  
**Category:** Core Services  
**Created:** 2026-01-05  
**Parent Issue:** 28.1

## Description

Implement network monitoring to detect connection type, bandwidth, and interruptions, enabling adaptive behavior for downloads and streaming.

## Spec Reference

See `spec/streaming-playback.md`:
- Network Loss During Playback
- Network Recovery and Resume
- Network Type Change (Wi-Fi to Cellular)
- Bandwidth Estimation and Adjustment

See `spec/offline-playback.md`:
- Wi-Fi Only Download Setting
- Cellular Download Warning
- Download Resume After Network Loss

## Objectives

1. Monitor network reachability (connected, disconnected)
2. Detect network type (Wi-Fi, cellular, ethernet)
3. Estimate available bandwidth
4. Publish network state changes via async streams
5. Provide APIs for conditional operations (Wi-Fi only, etc.)

## API Design

```swift
@MainActor
public final class NetworkMonitor: ObservableObject {
    // Singleton instance
    static let shared = NetworkMonitor()
    
    // Published state
    @Published private(set) var isConnected: Bool = false
    @Published private(set) var connectionType: ConnectionType = .none
    @Published private(set) var estimatedBandwidth: Bandwidth = .unknown
    
    // State queries
    func currentStatus() -> NetworkStatus
    func isWiFiAvailable() -> Bool
    func isCellularAvailable() -> Bool
    
    // Bandwidth estimation
    func measureBandwidth() async -> Bandwidth
    
    // State streams
    var networkStatusUpdates: AsyncStream<NetworkStatus> { get }
}

public enum ConnectionType {
    case none
    case wifi
    case cellular
    case ethernet
    case unknown
}

public enum Bandwidth {
    case fast  // > 2 Mbps
    case medium  // 500 Kbps - 2 Mbps
    case slow  // < 500 Kbps
    case unknown
    
    var bitsPerSecond: Int64? { /* ... */ }
}

public struct NetworkStatus {
    let isConnected: Bool
    let connectionType: ConnectionType
    let bandwidth: Bandwidth
    let timestamp: Date
}
```

## Implementation Requirements

### Core Functionality

1. **NWPathMonitor Integration**
   ```swift
   import Network
   
   let monitor = NWPathMonitor()
   monitor.pathUpdateHandler = { [weak self] path in
       Task { @MainActor in
           self?.updateNetworkStatus(path)
       }
   }
   monitor.start(queue: DispatchQueue.global(qos: .utility))
   ```

2. **Connection Type Detection**
   - Use `NWPath.usesInterfaceType()` to check .wifi, .cellular, .wiredEthernet
   - Prefer Wi-Fi over cellular when both available
   - Update `connectionType` on every path change

3. **Bandwidth Estimation**
   - Passive: Monitor download speeds from existing transfers
   - Active: Download small test file (10KB) and measure time
   - Update estimate every 30 seconds during active transfers
   - Classify into fast/medium/slow tiers

4. **Network Interruption Detection**
   - Detect when `path.status == .unsatisfied`
   - Publish `.disconnected` event
   - Notify download/streaming engines to pause operations

5. **Network Recovery Detection**
   - Detect when `path.status == .satisfied` after being unsatisfied
   - Publish `.reconnected` event with new connection type
   - Notify engines to resume operations

### Testing Requirements

1. **Unit Tests** (`Packages/SharedUtilities/Tests/`)
   - Network status updates
   - Connection type detection
   - Bandwidth classification
   - State stream emission

2. **Integration Tests** (`IntegrationTests/`)
   - Simulate network disconnect during download
   - Verify pause behavior
   - Simulate network reconnect
   - Verify resume behavior

3. **Manual Tests** (Simulator)
   - Toggle airplane mode → verify disconnect event
   - Switch Wi-Fi to cellular → verify type change
   - Use Network Link Conditioner → verify bandwidth detection

## Acceptance Criteria

- [ ] NetworkMonitor singleton implemented with NWPathMonitor
- [ ] `isConnected` accurately reflects network availability
- [ ] `connectionType` correctly identifies Wi-Fi, cellular, ethernet
- [ ] `estimatedBandwidth` classifies connection as fast/medium/slow
- [ ] Network status changes published via AsyncStream
- [ ] Disconnection events trigger pause in downloads/streaming
- [ ] Reconnection events trigger automatic resume
- [ ] Connection type changes handled seamlessly (Wi-Fi ↔ cellular)
- [ ] Unit tests cover status updates and classifications
- [ ] Integration test simulates disconnect/reconnect cycle
- [ ] All spec scenarios from `streaming-playback.md` (network section) pass

## Dependencies

- **Requires:** None (standalone service)
- **Used By:** 28.1.1 (download manager), 28.1.3 (streaming engine)

## Technical Notes

### NWPathMonitor Setup

```swift
private let monitor = NWPathMonitor()
private let monitorQueue = DispatchQueue(label: "us.zig.zpod.network-monitor")

func startMonitoring() {
    monitor.pathUpdateHandler = { [weak self] path in
        let status = self?.parseNetworkStatus(from: path) ?? .disconnected
        
        Task { @MainActor in
            self?.updateStatus(status)
        }
    }
    
    monitor.start(queue: monitorQueue)
}

private func parseNetworkStatus(from path: NWPath) -> NetworkStatus {
    let isConnected = path.status == .satisfied
    
    var connectionType: ConnectionType = .none
    if path.usesInterfaceType(.wifi) {
        connectionType = .wifi
    } else if path.usesInterfaceType(.cellular) {
        connectionType = .cellular
    } else if path.usesInterfaceType(.wiredEthernet) {
        connectionType = .ethernet
    }
    
    return NetworkStatus(
        isConnected: isConnected,
        connectionType: connectionType,
        bandwidth: estimatedBandwidth,
        timestamp: Date()
    )
}
```

### Bandwidth Estimation (Passive)

```swift
func updateBandwidthEstimate(bytesReceived: Int64, duration: TimeInterval) {
    let bytesPerSecond = Double(bytesReceived) / duration
    let bitsPerSecond = bytesPerSecond * 8
    
    let bandwidth: Bandwidth
    if bitsPerSecond > 2_000_000 {  // 2 Mbps
        bandwidth = .fast
    } else if bitsPerSecond > 500_000 {  // 500 Kbps
        bandwidth = .medium
    } else {
        bandwidth = .slow
    }
    
    Task { @MainActor in
        self.estimatedBandwidth = bandwidth
    }
}
```

### Integration with Download Manager

```swift
// In DownloadManager
init(networkMonitor: NetworkMonitor = .shared) {
    self.networkMonitor = networkMonitor
    
    Task {
        for await status in networkMonitor.networkStatusUpdates {
            handleNetworkStatusChange(status)
        }
    }
}

private func handleNetworkStatusChange(_ status: NetworkStatus) {
    if !status.isConnected {
        pauseAllDownloads()
    } else {
        resumeQueuedDownloads()
    }
}
```

## Out of Scope

- VPN detection
- Proxy configuration handling
- Network quality scoring beyond 3 tiers
- Custom network profiles

## Dev Log

Document network monitoring patterns, edge cases, and test results in:
`dev-log/28.1.4-network-monitoring-adaptation.md`

---

**Related Issues:** 28.1 (parent), 28.1.1 (download manager), 28.1.3 (streaming engine)  
**Estimated Effort:** 1-2 days
