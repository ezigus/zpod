# Issue 03.3.2.3: Playback AVPlayer Test Suite

**Status**: ⚠️ In Review (Blocked by 03.3.2.6 - Test Audio Infrastructure)

**Priority**: High

**Parent**: 03.3.2 - AVPlayer Playback Engine (#267)

**GitHub Issue**: [#299](https://github.com/ezigus/zpod/issues/299)

**Estimated Effort**: 2 hours

## Description

Create a dedicated test suite for playback position validation using the real AVPlayer engine. These tests validate the full audio pipeline integration (AVPlayer → EnhancedEpisodePlayer → UI) with actual audio streaming.

## Problem Statement

**Current State**:
- No UI tests validate real AVPlayer integration
- Production audio path untested in automated tests
- Risk of AVPlayer callback/observer integration bugs going undetected

**Target State**:
- `PlaybackPositionAVPlayerTests.swift` explicitly uses production AVPlayer
- 5 tests covering core playback position scenarios with real audio
- Validates AVPlayer time observer → state publisher → UI flow
- Longer timeouts and tolerances account for real-time jitter

## Technical Design

### Test Class Structure

```swift
/// UI tests for playback position using the AVPlayer engine (real audio).
///
/// **Issue**: 03.3.2.3 - Playback AVPlayer Test Suite
/// **Mode**: AVPlayer (production mode, real audio streaming)
/// **Spec**: `zpod/spec/playback.md` - Core Playback Behavior
///
/// These tests validate position UI updates with actual AVPlayer integration.
/// Position updates come from AVPlayer's periodic time observer, not a simulated ticker.
/// Longer execution (~20-30 seconds per test), validates real audio pipeline.
///
/// **CI Note**: These tests are BLOCKING. Failures indicate AVPlayer integration issues
/// that would affect production users.
///
/// **CI Job**: UITests-PlaybackAVPlayer
final class PlaybackPositionAVPlayerTests: XCTestCase, PlaybackPositionTestSupport {
    nonisolated(unsafe) var app: XCUIApplication!
    static let logger = Logger(subsystem: "us.zig.zpod", category: "PlaybackPositionAVPlayerTests")
    
    // MARK: - AVPlayer-Specific Timeouts
    
    /// Longer timeout for AVPlayer operations (buffering, network latency)
    private let avplayerTimeout: TimeInterval = 10.0
    
    /// More tolerant position delta for real-time playback jitter
    private let avplayerPositionTolerance: TimeInterval = 2.0
    
    @MainActor
    private func launchApp() {
        // Launch WITHOUT UITEST_DISABLE_AUDIO_ENGINE to use real AVPlayer
        app = launchConfiguredApp(
            environmentOverrides: [
                "UITEST_POSITION_DEBUG": "1"
                // Note: NO "UITEST_DISABLE_AUDIO_ENGINE" key → uses real AVPlayer
            ]
        )
    }
    
    // Test methods...
}
```

### Key Differences from Ticker Tests

| Aspect | Ticker Tests | AVPlayer Tests |
|--------|--------------|----------------|
| Timeout | 5s | 10s (buffering time) |
| Position tolerance | ±0.1s | ±0.5s (real-time jitter) |
| Position source | TimerTicker (deterministic) | AVPlayer time observer |
| Audio output | None | Real audio streams |
| CI execution time | ~15 seconds | ~30-45 seconds |
| Flakiness risk | Low | Medium (network/hardware) |
| Environment | UITEST_DISABLE_AUDIO_ENGINE=1 | No flag (production path) |

## Acceptance Criteria

- [x] `PlaybackPositionAVPlayerTests.swift` created with 6 test methods (was 5, added seek-while-paused)
- [x] All tests set `UITEST_DISABLE_AUDIO_ENGINE=0` via `launchWithPlaybackMode(.avplayer)`
- [x] All tests conform to `PlaybackPositionTestSupport` protocol
- [x] Test 1: Position advances during AVPlayer playback
- [x] Test 2: Position stops when AVPlayer paused
- [x] Test 3: Position resumes after AVPlayer resumed
- [x] Test 4: Seeking calls AVPlayer.seek(to:) and updates position
- [x] Test 5: Mini-player reflects AVPlayer state changes
- [x] Test 6: Seeking while paused calls AVPlayer.seek(to:) (spec line 83: "playing or paused")
- [x] All tests use 10s timeout for position advancement
- [x] All tests use ±0.5s tolerance for position stability
- [x] Seek parsing failures cause hard test failure (no silent passes)
- [ ] All tests complete in <2.5 minutes total (was <2min, extended for 1 new test)
- [ ] All tests pass locally via `./scripts/run-xcode-tests.sh -t PlaybackPositionAVPlayerTests` (blocked by 03.3.2.6)

## Spec References

See `zpod/spec/playback.md`:

### Test 1 & 5: Timeline Advancement During Playback (lines 62-68)
```gherkin
Given an episode is playing
When the playback is in progress
Then the timeline position advances
And the elapsed time is updated in the player
And the lock screen / Control Center shows the current position
```

**Critical Validation**: Position updates come from AVPlayer's periodic time observer (0.5s interval), not a timer.

### Test 2: Pausing Playback (lines 69-75)
```gherkin
Given an episode is playing
When the user taps the pause button
Then playback stops immediately
And the progress bar stops advancing
```

**Critical Validation**: AVPlayer.pause() called and time observer stops firing updates.

### Test 3: Resuming Playback (lines 76-82)
```gherkin
Given an episode is paused
When the user taps the play button
Then playback resumes from the previous position
And the progress bar continues advancing
```

**Critical Validation**: AVPlayer.play() called and time observer resumes firing updates.

### Test 4: Seeking to Position (lines 83-87)
```gherkin
Given an episode is playing or paused
When the user drags the progress slider
Then playback jumps to the selected position immediately
```

**Critical Validation**: AVPlayer.seek(to:toleranceBefore:toleranceAfter:completionHandler:) called with correct CMTime.

## Files to Create

| File | Lines | Purpose |
|------|-------|---------|
| `zpodUITests/PlaybackPositionAVPlayerTests.swift` | ~200 | AVPlayer test suite |

## Implementation Steps

### Step 1: Create Test File (10 minutes)

1. Create `zpodUITests/PlaybackPositionAVPlayerTests.swift`
2. Add file header with issue reference and critical notes
3. Add imports: `OSLog`, `XCTest`
4. Define class conforming to `XCTestCase` and `PlaybackPositionTestSupport`
5. Add `app` property and `logger`
6. Add `avplayerTimeout` and `avplayerPositionTolerance` constants
7. Add `setUpWithError()` and `tearDownWithError()`
8. Add `launchApp()` helper with AVPlayer mode (no disable flag)

### Step 2: Implement Test 1 - Position Advancement (20 minutes)

```swift
/// **Spec**: Timeline Advancement During Playback
/// **Critical**: Validates AVPlayer position callbacks flow to UI.
///
/// Unlike ticker mode, position updates come from AVPlayer's periodic time observer.
/// This test verifies the full integration: AVPlayer → EnhancedEpisodePlayer → UI.
@MainActor
func testExpandedPlayerProgressAdvancesDuringPlayback() throws {
    // Given: Episode is playing with real AVPlayer
    launchApp()
    guard startPlayback() else {
        XCTFail("Failed to start playback")
        return
    }
    
    guard expandPlayer() else {
        XCTFail("Failed to expand player")
        return
    }
    
    // AVPlayer may need time to buffer and start streaming
    let initialValue = getSliderValue()
    XCTAssertNotNil(initialValue, "Progress slider should have an initial value")
    let initialPosition = extractCurrentPosition(from: initialValue)
    
    // When: Wait for position to advance (AVPlayer updates every 0.5s)
    // Use longer timeout for AVPlayer (buffering + network latency)
    let updatedValue = waitForPositionAdvancement(beyond: initialValue, timeout: avplayerTimeout)
    
    // Then: Position should advance (validates AVPlayer → UI pipeline)
    XCTAssertNotNil(updatedValue, "Progress slider should have advanced with AVPlayer")
    let updatedPosition = extractCurrentPosition(from: updatedValue)
    
    if let initial = initialPosition, let updated = updatedPosition {
        XCTAssertGreaterThan(updated, initial,
            "AVPlayer position should advance from \(initial)s to \(updated)s")
        // More tolerant assertion for real-time playback
        XCTAssertGreaterThanOrEqual(updated - initial, 0.5,
            "AVPlayer should advance at least 0.5s (one update cycle)")
    } else {
        XCTFail("Could not parse position values")
    }
}
```

### Step 3: Implement Test 2 - Pause Stops Position (20 minutes)

```swift
/// **Spec**: Pausing Playback
/// **Critical**: Validates AVPlayer.pause() stops position updates.
@MainActor
func testPositionStopsAdvancingWhenPaused() throws {
    launchApp()
    guard startPlayback(), expandPlayer() else {
        XCTFail("Failed to start playback and expand player")
        return
    }
    
    // Wait for AVPlayer to start streaming and advance position
    let initialValue = getSliderValue()
    _ = waitForPositionAdvancement(beyond: initialValue, timeout: avplayerTimeout)
    
    // When: Pause playback (this calls AVPlayer.pause())
    let pauseButton = app.buttons.matching(identifier: "Expanded Player Pause").firstMatch
    XCTAssertTrue(pauseButton.waitForExistence(timeout: adaptiveShortTimeout))
    pauseButton.tap()
    
    // Verify play button appears (confirms paused state)
    let playButton = app.buttons.matching(identifier: "Expanded Player Play").firstMatch
    XCTAssertTrue(playButton.waitForExistence(timeout: adaptiveShortTimeout))
    
    // Then: Position should stop advancing
    let pausedValue = getSliderValue()
    // More tolerant for AVPlayer (may have one more callback after pause)
    let positionStable = verifyPositionStable(at: pausedValue, forDuration: 2.0, tolerance: 0.5)
    XCTAssertTrue(positionStable, "Position should remain stable when paused (within 0.5s)")
}
```

### Step 4: Implement Test 3 - Resume Advances Position (20 minutes)

```swift
/// **Spec**: Resuming Playback
/// **Critical**: Validates AVPlayer.play() resumes position updates.
@MainActor
func testPositionResumesAdvancingAfterPause() throws {
    launchApp()
    guard startPlayback(), expandPlayer() else {
        XCTFail("Failed to start playback and expand player")
        return
    }
    
    // Pause playback
    let pauseButton = app.buttons.matching(identifier: "Expanded Player Pause").firstMatch
    XCTAssertTrue(pauseButton.waitForExistence(timeout: adaptiveShortTimeout))
    pauseButton.tap()
    
    let playButton = app.buttons.matching(identifier: "Expanded Player Play").firstMatch
    XCTAssertTrue(playButton.waitForExistence(timeout: adaptiveShortTimeout))
    
    let pausedValue = getSliderValue()
    let pausedPosition = extractCurrentPosition(from: pausedValue)
    
    // When: Resume playback (calls AVPlayer.play())
    playButton.tap()
    XCTAssertTrue(pauseButton.waitForExistence(timeout: adaptiveShortTimeout))
    
    // Then: Position should advance (may need time to resume streaming)
    let resumedValue = waitForPositionAdvancement(beyond: pausedValue, timeout: avplayerTimeout)
    XCTAssertNotNil(resumedValue, "Position should advance after resuming AVPlayer")
    
    if let paused = pausedPosition,
       let resumed = extractCurrentPosition(from: resumedValue) {
        XCTAssertGreaterThan(resumed, paused,
            "AVPlayer position should advance from \(paused)s to \(resumed)s after resume")
    }
}
```

### Step 5: Implement Test 4 - Seeking Updates Position (25 minutes)

```swift
/// **Spec**: Seeking to Position
/// **Critical**: Validates AVPlayer.seek(to:) updates position correctly.
@MainActor
func testSeekingUpdatesPositionImmediately() throws {
    logBreadcrumb("testSeekingUpdatesPositionImmediately (AVPlayer): launch app")
    launchApp()
    guard startPlayback(), expandPlayer() else {
        XCTFail("Failed to start playback and expand player")
        return
    }
    
    let initialValue = getSliderValue()
    logSliderValue("initial (AVPlayer)", value: initialValue)
    
    // When: Seek to 50% position (calls AVPlayer.seek(to:))
    let slider = app.sliders.matching(identifier: "Progress Slider").firstMatch
    XCTAssertTrue(slider.waitForExistence(timeout: adaptiveShortTimeout))
    
    logBreadcrumb("testSeekingUpdatesPositionImmediately (AVPlayer): seek to 50%")
    let preSeekValue = getSliderValue()
    slider.adjust(toNormalizedSliderPosition: 0.5)
    
    // Then: Wait for position to change (AVPlayer seek may take time)
    // Use longer stabilization window for AVPlayer seek completion
    let seekedValue = waitForUIStabilization(
        afterSeekingFrom: preSeekValue,
        timeout: 5.0,  // Longer for AVPlayer seek
        minimumDelta: 3.0,
        stabilityWindow: 0.5  // Longer stability window
    )
    logSliderValue("seeked (AVPlayer)", value: seekedValue)
    XCTAssertNotNil(seekedValue, "Slider value should change after AVPlayer seek")
    
    // Verify position continues advancing after seek
    let finalValue = waitForPositionAdvancement(beyond: seekedValue, timeout: avplayerTimeout)
    logSliderValue("final (AVPlayer)", value: finalValue)
    XCTAssertNotNil(finalValue, "Position should continue advancing after AVPlayer seek")
}
```

### Step 6: Implement Test 5 - Mini-Player State (10 minutes)

```swift
/// **Spec**: Timeline Advancement During Playback (Mini-Player)
/// **Critical**: Validates mini-player UI updates with real AVPlayer state.
@MainActor
func testMiniPlayerReflectsPlaybackState() throws {
    launchApp()
    guard startPlayback() else {
        XCTFail("Failed to start playback")
        return
    }
    
    // Then: Mini-player should show pause button (AVPlayer is playing)
    let miniPlayer = miniPlayerElement(in: app)
    XCTAssertTrue(miniPlayer.exists)
    
    let pauseButton = app.buttons.matching(identifier: "Mini Player Pause").firstMatch
    XCTAssertTrue(pauseButton.waitForExistence(timeout: adaptiveShortTimeout),
        "Mini player should show pause button when AVPlayer is playing")
    
    // When: Pause via mini-player (calls AVPlayer.pause())
    pauseButton.tap()
    
    // Then: Play button should appear (AVPlayer is paused)
    let playButton = app.buttons.matching(identifier: "Mini Player Play").firstMatch
    XCTAssertTrue(playButton.waitForExistence(timeout: adaptiveShortTimeout),
        "Mini player should show play button when AVPlayer is paused")
}
```

### Step 7: Validate Tests (15 minutes)

1. Build zpodUITests target
2. Run AVPlayer tests: `./scripts/run-xcode-tests.sh -t zpodUITests/PlaybackPositionAVPlayerTests`
3. Verify all 5 tests pass
4. Verify total execution time < 2 minutes
5. Check for flakiness (run 3 times)
6. Listen for audio output during test execution (optional)

## Testing Strategy

### Local Validation
```bash
# Build tests
xcodebuild -workspace zpod.xcworkspace -scheme zpod build-for-testing

# Run AVPlayer suite only
./scripts/run-xcode-tests.sh -t zpodUITests/PlaybackPositionAVPlayerTests

# Expected output:
# Test Suite 'PlaybackPositionAVPlayerTests' passed at 2026-01-04 10:20:45.123
# Executed 5 tests, with 0 failures (0 unexpected) in 87.456 (88.123) seconds
```

### Flakiness Monitoring
- Run suite 3 times consecutively
- All runs should pass
- If >1 failure in 3 runs, increase timeouts/tolerances

### CI Integration (Next Phase)
- Will be added to `UITests-PlaybackAVPlayer` job in CI workflow
- Expected execution time: ~5 minutes (includes simulator provisioning + buffering)
- Job is BLOCKING (must pass to merge)

## Dependencies

- **03.3.2.1**: Shared infrastructure (protocol, helpers) MUST be complete
- **03.3.2**: AVPlayerPlaybackEngine implementation (already complete)
- **Next**: 03.3.2.4 (CI configuration) will add this suite to CI

## Notes

### Why AVPlayer Tests Are Critical

These tests are the ONLY automated validation that:
1. AVPlayer time observer fires callbacks
2. Callbacks reach EnhancedEpisodePlayer
3. State publisher emits position updates
4. UI reflects AVPlayer state changes
5. Production audio path works end-to-end

**Without these tests, users could see UI updates but hear no audio (or vice versa).**

### AVPlayer Timing Characteristics

- Buffering delay: 1-3 seconds on first play
- Time observer interval: 0.5 seconds (configured in AVPlayerPlaybackEngine)
- Seek completion: 0.5-2 seconds (async operation)
- Position jitter: ±0.1-0.5 seconds typical
- Network latency: Variable (use generous timeouts)

### Tolerance Rationale

| Tolerance | Value | Rationale |
|-----------|-------|-----------|
| Position advancement timeout | 10s | 2x ticker (accounts for buffering) |
| Position stability tolerance | ±0.5s | AVPlayer may fire one callback after pause |
| Seek stabilization window | 0.5s | Allow for async seek completion |
| Seek timeout | 5s | Longer than ticker for network latency |

### Debugging Failed Tests

**Test fails with "Progress slider should have advanced"**:
- Check network connectivity
- Increase `avplayerTimeout` to 15s
- Verify episode URL is valid and accessible
- Check simulator audio output settings

**Test fails with "Position should remain stable"**:
- Increase `avplayerPositionTolerance` to 1.0s
- Check for residual time observer callbacks
- Verify AVPlayer.pause() is actually called

**Test hangs or times out**:
- Check for modal dialogs (permissions, etc.)
- Verify Quick Play button tap worked
- Check mini-player actually appeared

## Estimated Effort

**2 hours total**:
- File setup: 10 minutes
- Test 1 (advancement): 20 minutes
- Test 2 (pause): 20 minutes
- Test 3 (resume): 20 minutes
- Test 4 (seeking): 25 minutes
- Test 5 (mini-player): 10 minutes
- Validation and fixes: 15 minutes

## Success Criteria

| Criterion | Verification | Status |
|-----------|--------------|--------|
| All 5 tests implemented | File contains 5 test methods | ⏳ |
| All tests pass locally | run-xcode-tests.sh passes | ⏳ |
| Total execution < 2 minutes | Check test log timing | ⏳ |
| Minimal flakiness | 3/3 passes | ⏳ |
| AVPlayer mode verified | No UITEST_DISABLE_AUDIO_ENGINE flag | ⏳ |
| Protocol conformance | Uses shared helpers | ⏳ |
| Longer timeouts used | 10s for advancement, 5s for seek | ⏳ |
| Tolerant assertions | ±0.5s for stability | ⏳ |
