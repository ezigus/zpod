# 02.7.2 - CI Test Flakiness: Phase 2 - Root Cause Analysis

**Parent Issue**: #145 (02.7 - CI Test Flakiness - Investigation & Infrastructure)
**Phase**: 2 of 4
**Timeline**: 2 weeks
**Goal**: Understand WHY tests are flaky and categorize by root cause
**Depends On**: #02.7.1 (Phase 1 - Identification & Metrics)

## Description

Analyze the top flakiest tests identified in Phase 1 to understand their failure patterns and root causes. Categorize failures by type (timing, environment, state pollution, etc.) to inform infrastructure improvements in Phase 3.

## Prerequisites

From Phase 1 (#02.7.1):
- ✅ Top 10 flakiest tests identified
- ✅ CI logs and test results accessible
- ✅ Baseline flakiness metrics established

## Tasks

### Week 1: Failure Pattern Analysis
- [ ] **Review CI logs** for top 10 flaky tests
  - Extract failure messages and stack traces
  - Identify common error patterns
  - Screenshot/document failure states

- [ ] **Reproduce failures locally**
  - Run flaky tests 100x locally: `./scripts/test-flakiness.sh TestName 100`
  - Compare local vs CI failure patterns
  - Identify CI-specific vs general flakiness

- [ ] **Categorize failures** by pattern:
  - **Timing/Synchronization**: Element not found, timeout errors
  - **Race Conditions**: Inconsistent state, order-dependent failures
  - **Environmental**: CI-specific (slower machines, network issues)
  - **State Pollution**: Test affects subsequent tests, improper cleanup
  - **Animation/Transitions**: Taps during animations, unstable frames
  - **Element Discovery**: SwiftUI lazy loading, view hierarchy delays

### Week 2: Infrastructure Gap Analysis
- [ ] **Group tests by common root cause**
  - E.g., "All 3 navigation tests fail due to tab bar animation timing"

- [ ] **Identify missing infrastructure**
  - No retry mechanism for element discovery?
  - No stable wait primitives (frame stabilization)?
  - Insufficient cleanup between tests?

- [ ] **Document fix patterns** for each category
  - What infrastructure would prevent this category?
  - What best practices should tests follow?

## Acceptance Criteria

- [ ] **All Top 10 Flaky Tests Analyzed**: Each has documented root cause with evidence
- [ ] **Failures Categorized**: Percentage breakdown by category (e.g., 40% timing, 30% environment, etc.)
- [ ] **Common Patterns Identified**: Groups of tests sharing same root cause
- [ ] **Infrastructure Gaps Documented**: Specific missing tools/helpers that would prevent failures
- [ ] **Fix Recommendations Created**: Per-category guidance for Phase 3 and Phase 4

## Deliverables

### 1. Root Cause Analysis Report
**File**: `dev-log/02.7.2-root-cause-analysis.md`

**Contents**:
```markdown
# Flakiness Root Cause Analysis

## Summary

- Tests analyzed: 10 (top flakiest)
- Analysis period: 2 weeks
- Categories identified: 6

## Failure Category Breakdown

| Category | % of Failures | # Tests | Examples |
|----------|---------------|---------|----------|
| Timing/Synchronization | 40% | 4 | testNavigate, testSwipePersistence |
| Environmental (CI-specific) | 25% | 2 | testLockScreen, testCarPlay |
| Race Conditions | 20% | 2 | testTabBar, testPlaylist |
| State Pollution | 10% | 1 | testSettings |
| Animation/Transitions | 5% | 1 | testModalDismiss |

## Detailed Analysis

### Test: CoreUINavigationTests.testTabBarNavigation (15% failure rate)

**Root Cause**: Race condition in tab bar selection
**Evidence**:
- CI logs show "element not found" for selected tab
- Occurs when tapping tab before animation completes
- Local reproduction: 12/100 runs failed

**Failure Pattern**:
```
1. Tap tab bar item "Library"
2. Test expects isSelected=true immediately
3. Tab bar animation in progress (0.3s)
4. Element query fails before animation completes
```

**Fix Approach**:
- Wait for tab bar isSelected state before proceeding
- Add animation completion wait helper

**Infrastructure Needed**:
- `waitForAnimationComplete(on: tabBar)` helper
- Stable element query that retries during transitions
```

### 2. Infrastructure Recommendations
**File**: `dev-log/02.7.2-infrastructure-recommendations.md`

**Contents**:
```markdown
# Infrastructure Recommendations for Phase 3

## High Priority

### 1. Retry Mechanism (Addresses 40% of failures)
**Problem**: Element queries fail during transitions/animations
**Solution**: Implement retry wrapper with exponential backoff
**Impact**: Would fix 4/10 flakiest tests

### 2. Animation Wait Helpers (Addresses 25% of failures)
**Problem**: No way to wait for SwiftUI animations to complete
**Solution**: Frame stabilization check, animation completion detection
**Impact**: Would fix timing-related failures

### 3. Environmental Isolation (Addresses 10% of failures)
**Problem**: Tests don't clean up state properly
**Solution**: Standardized tearDown with UserDefaults/Keychain cleanup
**Impact**: Prevents state pollution between tests

## Medium Priority

### 4. CI-Specific Timeouts
**Problem**: CI machines slower than local, default timeouts too short
**Solution**: Detect CI environment, multiply timeouts by 1.5-2x
**Impact**: Reduces environmental flakiness

## Low Priority (Test-Specific Fixes)

### 5. Test-Specific Waits
**Problem**: Some tests have unique synchronization needs
**Solution**: Custom wait predicates for specific scenarios
**Impact**: Surgical fixes for outlier cases
```

### 3. Fix Pattern Catalog
**File**: `docs/testing/flakiness-fix-patterns.md`

**Contents**: Reusable patterns for fixing common flakiness categories

```markdown
# Flakiness Fix Patterns

## Pattern 1: Timing/Synchronization Failures

**Symptom**: "Element not found", timeout errors
**Root Cause**: Querying elements before they materialize

**Before (Flaky)**:
```swift
let button = app.buttons["Submit"]
button.tap()  // Fails if button not materialized yet
```

**After (Fixed)**:
```swift
let button = app.buttons["Submit"]
XCTAssertTrue(button.waitForExistence(timeout: 5.0))
button.tap()
```

## Pattern 2: Race Conditions

**Symptom**: Inconsistent failures, order-dependent
**Root Cause**: Accessing state during async updates

**Before (Flaky)**:
```swift
app.tabBars.buttons["Library"].tap()
XCTAssertTrue(app.tabBars.buttons["Library"].isSelected)  // Flaky!
```

**After (Fixed)**:
```swift
let libraryTab = app.tabBars.buttons["Library"]
libraryTab.tap()
let predicate = NSPredicate { _, _ in libraryTab.isSelected }
let expectation = XCTNSPredicateExpectation(predicate: predicate, object: nil)
XCTAssertEqual(XCTWaiter.wait(for: [expectation], timeout: 2.0), .completed)
```
```

## Success Metrics

**Before Phase 2**:
- Root causes: Unknown
- Fix patterns: None documented
- Infrastructure gaps: Unknown

**After Phase 2**:
- Root causes: Documented for top 10 flaky tests
- Fix patterns: Catalog of proven patterns
- Infrastructure gaps: Prioritized list for Phase 3
- Categories identified: Clear breakdown of failure types

## Tools & Scripts

### Script: Test Flakiness Locally
**File**: `scripts/test-flakiness.sh`
```bash
#!/bin/bash
# Runs a test N times to reproduce flakiness locally
# Usage: ./scripts/test-flakiness.sh SwipePersistenceTests::testFoo 100

TEST_NAME=$1
ITERATIONS=${2:-100}
FAILURES=0

for i in $(seq 1 $ITERATIONS); do
  echo "Run $i/$ITERATIONS..."
  if ! xcodebuild test -only-testing:"$TEST_NAME" > /dev/null 2>&1; then
    FAILURES=$((FAILURES + 1))
  fi
done

echo "Failures: $FAILURES/$ITERATIONS ($(echo "scale=1; $FAILURES*100/$ITERATIONS" | bc)%)"
```

## Notes

**What This Phase Provides**:
- ✅ Deep understanding of WHY tests are flaky
- ✅ Actionable data for Phase 3 (infrastructure)
- ✅ Fix patterns for Phase 4 (targeted fixes)
- ✅ Prevents whack-a-mole (addresses root causes, not symptoms)

**What This Phase Does NOT Do**:
- ❌ Fix flaky tests (that's Phase 4)
- ❌ Build infrastructure (that's Phase 3)
- ❌ Just symptoms (we identify ROOT causes)

## References

- Parent: #145 (02.7 - CI Test Flakiness Master Issue)
- Prerequisites: #02.7.1 (Phase 1 metrics)
- CI Logs: Check GitHub Actions run artifacts
- Local Testing: Use `scripts/test-flakiness.sh`
