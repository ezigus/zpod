# Issue 27.1.1.1: Episode Persistence (Schema + CRUD + Hydration + Hardening)

## Priority
High

## Status
⏳ Pending (Blocked by 27.1.1)

## Description
Implement full episode persistence in SwiftData, including schema design, CRUD operations, episode hydration in repository methods, playback position reset fix, and error hardening. This fixes the episode gap that currently breaks CarPlay, search indexing, and persistence features.

This is a comprehensive deliverable combining schema, CRUD, and hardening to avoid shipping "dead schema" or creating merge conflicts from incremental steps.

## Acceptance Criteria

### Schema & Entity
- [ ] `EpisodeEntity` @Model created with all 17 Episode fields
- [ ] `toDomain()` / `fromDomain()` / `updateFrom()` conversion methods implemented
- [ ] Schema compiles with `PodcastEntity` + `EpisodeEntity`
- [ ] App launches without migration errors

### CRUD & Hydration
- [ ] `add()` persists `podcast.episodes` to `EpisodeEntity`
- [ ] `find(id:)` returns podcast with episodes populated
- [ ] `all()` returns podcasts with episodes populated
- [ ] `remove(id:)` cascade deletes all episodes for podcast
- [ ] CarPlay `episodeLookup` finds episodes
- [ ] `EpisodeIndexSource.documents()` returns episodes

### Reset & Siri
- [ ] `resetAllPlaybackPositions()` operates on persisted episodes (not no-op)
- [ ] Positive Siri refresh tests: `testSuccessfulAddTriggersRefresh`, `testSuccessfulUpdateTriggersRefresh`, `testSuccessfulRemoveTriggersRefresh`

### Error Hardening
- [ ] `PodcastEntity.toDomain()` handles invalid `feedURLString` without crashing (log/skip)
- [ ] Test: malformed feed URL fixture; assert repository excludes bad rows

### Tests
- [ ] Unit tests for episode domain conversion round-trip
- [ ] Unit tests for episode persistence (add/find/remove)
- [ ] Integration test: episodes survive app restart

## Implementation Approach

### Step 1: EpisodeEntity Schema
Create `Packages/Persistence/Sources/Persistence/EpisodeEntity.swift`:

```swift
@available(iOS 17, macOS 14, watchOS 10, *)
@Model
public final class EpisodeEntity {
    @Attribute(.unique) public var id: String
    public var podcastId: String  // Foreign key
    public var title: String
    public var podcastTitle: String
    public var episodeDescription: String?  // 'description' is reserved
    public var audioURLString: String?
    public var artworkURLString: String?
    public var pubDate: Date?
    public var duration: TimeInterval?
    public var playbackPosition: Int
    public var isPlayed: Bool
    public var downloadStatus: String  // rawValue
    public var isFavorited: Bool
    public var isBookmarked: Bool
    public var isArchived: Bool
    public var rating: Int?
    public var dateAdded: Date

    // Domain conversion methods
    public func toDomain() -> Episode { /* ... */ }
    public static func fromDomain(_ episode: Episode, podcastId: String) -> EpisodeEntity { /* ... */ }
    public func updateFrom(_ episode: Episode) { /* ... */ }
}
```

Update `zpod/ZpodApp.swift` schema:
```swift
let schema = Schema([
    LibraryFeature.Item.self,
    PodcastEntity.self,
    EpisodeEntity.self  // NEW
])
```

### Step 2: CRUD with Episode Hydration

**Update `all()` to include episodes:**
```swift
public func all() -> [Podcast] {
    serialQueue.sync {
        let descriptor = FetchDescriptor<PodcastEntity>()
        guard let entities = try? modelContext.fetch(descriptor) else { return [] }
        return entities.compactMap { entity in
            guard let podcast = entity.toDomainSafe() else { return nil }
            let episodes = fetchEpisodes(forPodcastId: entity.id)
            return podcast.withEpisodes(episodes)
        }
    }
}
```

**Update `add(_:)` to persist episodes:**
```swift
public func add(_ podcast: Podcast) {
    let didSave = serialQueue.sync { () -> Bool in
        // ... existing duplicate check ...

        let entity = PodcastEntity.fromDomain(podcast)
        modelContext.insert(entity)

        // Persist episodes
        for episode in podcast.episodes {
            let episodeEntity = EpisodeEntity.fromDomain(episode, podcastId: podcast.id)
            modelContext.insert(episodeEntity)
        }

        return saveContext()
    }
    if didSave { refreshSiriSnapshotsIfNeeded() }
}
```

**Update `remove(id:)` to cascade delete:**
```swift
public func remove(id: String) {
    let didSave = serialQueue.sync { () -> Bool in
        guard let entity = fetchEntity(id: id) else { return false }

        // Delete all episodes for this podcast
        let episodeEntities = fetchEpisodeEntities(forPodcastId: id)
        for episodeEntity in episodeEntities {
            modelContext.delete(episodeEntity)
        }

        modelContext.delete(entity)
        return saveContext()
    }
    if didSave { refreshSiriSnapshotsIfNeeded() }
}
```

### Step 3: Reset Fix (Using Persisted Episodes)

```swift
public func resetAllPlaybackPositions() {
    let didSave = serialQueue.sync { () -> Bool in
        let allEpisodes = fetchAllEpisodeEntities()
        guard !allEpisodes.isEmpty else { return false }

        var didUpdate = false
        for entity in allEpisodes where entity.playbackPosition != 0 {
            entity.playbackPosition = 0
            didUpdate = true
        }

        guard didUpdate else { return false }
        return saveContext()
    }
    if didSave {
        refreshSiriSnapshotsIfNeeded()
        logger.info("Reset all episode playback positions")
    }
}
```

### Step 4: FeedURL Safety

Update `PodcastEntity.toDomain()`:
```swift
public func toDomainSafe() -> Podcast? {
    guard let feedURL = URL(string: feedURLString) else {
        // Log and skip - don't crash on corrupted data
        return nil
    }
    return Podcast(
        id: id,
        title: title,
        // ... rest of fields ...
        feedURL: feedURL,
        // ...
    )
}
```

## Known Limitations
- None - this issue addresses the episode gap fully

## Specification References
- `dev-log/27.1-podcast-persistence-foundation.md` - Architecture context
- `dev-log/27.1.1.1-episode-persistence.md` - Implementation timeline

## Dependencies
- **Blocked by**: Issue 27.1.1 (must be merged first)
- **Blocks**: Issue 27.1.1.2 (Episode Sync)

## Estimated Effort
5-6 hours

## Success Metrics
- Episodes persist across app restarts
- CarPlay finds persisted episodes
- Search indexes persisted episodes
- Playback position reset works (not no-op)
- No crashes from invalid feed URLs

## Testing Strategy

### Unit Tests
```bash
./scripts/run-xcode-tests.sh -t PersistenceTests/EpisodeEntityTests
./scripts/run-xcode-tests.sh -t PersistenceTests/SwiftDataPodcastRepositoryTests
```

### Integration Tests
```bash
./scripts/run-xcode-tests.sh -t IntegrationTests/PodcastPersistenceIntegrationTests
```

### Manual Verification
- [ ] App launches without migration crash
- [ ] Subscribe to podcast → episodes appear
- [ ] Kill app, relaunch → episodes still present
- [ ] Search for episode by title → found in results
- [ ] CarPlay: episodeLookup finds persisted episode
- [ ] Reset playback positions → actually resets (not no-op)
- [ ] Siri refresh triggered on add/update/remove (check logs)
- [ ] Malformed feedURL in DB → app doesn't crash, row skipped

### Full Regression
```bash
./scripts/run-xcode-tests.sh
```

## Related Issues
- Issue 27.1.1 - Persistence Package Migration (prerequisite)
- Issue 27.1.1.2 - Episode Sync (Upsert Rules) (follow-up)
- Issue 27.1 - Podcast Persistence Foundation (parent)
