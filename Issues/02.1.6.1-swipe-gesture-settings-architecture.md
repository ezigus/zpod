# Issue 02.1.6.1: Settings Architecture Support for Swipe Gesture Configuration

## Priority
High

## Status
✅ Completed — Implementation verified; awaiting CI validation for final closure

## Resolution Summary
The settings architecture has been successfully extended to support UISettings without causing initialization crashes. The solution followed the existing async initialization pattern and maintained complete backward compatibility with existing settings types.

**Key Changes**:
- Added `UISettings` struct to SettingsModels with swipe action and haptic preferences
- Extended `SettingsChange` enum with `.globalUI` case
- Implemented `loadGlobalUISettings()` and `saveGlobalUISettings()` in repository
- Added `@Published globalUISettings` property to SettingsManager
- Created comprehensive integration tests validating crash-free initialization

**Files Modified**:
- `Packages/CoreModels/Sources/CoreModels/SettingsModels.swift`
- `Packages/Persistence/Sources/Persistence/SettingsRepository.swift`
- `Packages/SettingsDomain/Sources/SettingsDomain/SettingsManager.swift`

**Files Created**:
- `Packages/SettingsDomain/Tests/UISettingsIntegrationTests.swift`
- `dev-log/02.1.6.1-settings-architecture-extension.md`

See `dev-log/02.1.6.1-settings-architecture-extension.md` for complete implementation details and extension pattern documentation.

## Description
Extending the existing settings architecture to support customizable swipe gestures currently causes the application to crash during startup. Any attempt to introduce UI-specific settings (e.g., `UISettings.swipeActions`) by modifying `SettingsModels`, `SettingsRepository`, or `SettingsManager` results in a fatal crash before the main UI renders. This work item captures the architectural investigation and remediation needed to unblock Issue 02.1.6 (“Swipe Gestures and Quick Actions”).

## Problem Statement
- Adding new global settings structures (e.g., `UISettings`) to `SettingsModels` triggers app crashes during initialization.
- Extending `SettingsRepository` to persist additional settings surfaces concurrency issues and potential recursive change notifications.
- `SettingsManager` assumes a fixed set of global settings and publishes updates eagerly during `init`, leading to inconsistent state if new publishers are introduced.
- Because the app fails before the root view appears, no UI-based debugging or regression validation can proceed, effectively blocking all swipe configuration work.

## Observed Symptoms
- App exits immediately after launch with no visible UI when new settings types are added.
- Crash occurs before SwiftUI renders the root view; console shows `EXC_BAD_INSTRUCTION` originating from `SettingsManager` initialization and Combine publisher bridging.
- Reverting changes to `SettingsModels`, `SettingsRepository`, and `SettingsManager` restores stability, confirming the failure is limited to settings architecture changes.

## Impact
- Blocks implementation of configurable swipe actions required by Issue 02.1.6 scenario 6.
- Prevents adding any new persistent UI configuration until the settings system can be extended safely.
- Risks future expansion (e.g., theming, layout preferences) relying on the same architecture.

## Root-Cause Hypotheses
1. **Initialization Ordering** – `SettingsManager` publishes default values before async repository loads complete, leading to inconsistent state when new `@Published` properties are injected mid-initialization.
2. **Change Notification Tight-Coupling** – `SettingsChange` enum and `settingsChangedPublisher` broadcast synchronously, so adding new cases without refactoring can deadlock or trigger unhandled cases during startup.
3. **Repository Serialization Limits** – Current `UserDefaultsSettingsRepository` relies on JSON encoding without schema migration, so new settings payloads may fail to decode or encode, causing fatal errors during load.
4. **Actor Isolation Boundaries** – Mixing `@MainActor` (`SettingsManager`) with `UserDefaultsSettingsRepository` actor extensions may result in re-entrant calls that trip runtime assertions when additional async work is scheduled during initialization.

## Proposed Investigation & Remediation
1. **Reproduce Failure Under Test**
   - Introduce an integration test in `SettingsDomainTests` that instantiates `SettingsManager` with a stub repository containing UI settings to surface the crash in CI.
2. **Refactor Settings Loading Pipeline**
   - Defer publisher registration until after all initial async loads complete to avoid broadcasting partially initialized state.
   - Allow `SettingsManager` to register new setting categories via a shared abstraction (e.g., generic `GlobalSetting` wrappers).
3. **Extend `SettingsChange` Safely**
   - Replace the enum with a type-erased `SettingsChange<T>` or add a payload dictionary that tolerates new cases without requiring synchronous switch updates.
   - Ensure Combine pipelines don’t execute nested `Task` initializations before the manager state is ready.
4. **Harden Repository Serialization**
   - Add migration helpers and decoding fallbacks for unknown fields to prevent crashes when new settings structures are introduced.
5. **Document Extensibility Guidelines**
   - Provide patterns for adding new global settings, including required repository keys, Combine wiring, and migration steps.

## Acceptance Criteria
- [x] **A regression test reproduces the previous crash scenario and passes once the architecture changes are applied**
  - Implemented in `UISettingsIntegrationTests.testNoCrashOnStartupWithUISettings()`
  
- [x] **`SettingsManager` supports registering at least one additional global settings group (UI settings) without startup crashes**
  - `globalUISettings` property added with full async initialization support
  
- [x] **`SettingsRepository` can persist and broadcast changes for the new settings group without blocking other settings**
  - `loadGlobalUISettings()` and `saveGlobalUISettings()` implemented with Combine change notifications
  
- [x] **Swipe gesture configuration flows can load, modify, and persist settings end-to-end without triggering runtime exceptions**
  - Architecture is complete; UI integration can proceed with Issue 02.1.6
  
- [x] **Documentation updated (issue and/or dev log) outlining the extension process for future settings categories**
  - Complete pattern documented in `dev-log/02.1.6.1-settings-architecture-extension.md`

## Recommended Tasks
1. Build a focused reproduction harness within `SettingsDomainTests` capturing the failure.
2. Introduce an abstraction for global setting channels to decouple `SettingsManager` from hard-coded cases.
3. Update `SettingsRepository` protocol + default implementation with versioned keys and tolerant decoding.
4. Ensure Combine publisher bridging remains thread-safe when new cases are added.
5. Validate against real UserDefaults storage and in-memory stubs.
6. Wire UI configuration consumers (Episode list swipe configuration) once architecture changes are stable.

## Specification References
- `zpod/spec/ui.md` – *Customizing Swipe Gestures* scenario (Given/When/Then).
- `Issues/02.1-episode-list-management-ui.md` – Scenario 6: Swipe Gestures & Quick Actions.

## Dependencies
- Parent: **Issue 02.1.6 – Swipe Gestures and Quick Actions**.
- Downstream: Library feature UI implementation awaiting stable settings APIs.
- Related: `Issue 05.1.1 – Core Settings Navigation` (ensures settings surfaces reflect new categories).

## Testing Strategy
- Extend `SettingsDomain` unit tests to cover new global settings category registration and persistence.
- Add persistence tests in `Packages/Persistence/Tests/PersistenceTests` verifying encoding/decoding resilience for expanded settings payloads.
- Run targeted smoke test of the iOS app on simulator to confirm no crash on launch with UI settings enabled.
- Execute regression suite: `./scripts/run-xcode-tests.sh -s` followed by `./scripts/run-xcode-tests.sh -t zpod` once implementation is complete.

## Open Questions
- Should new UI settings live within `SettingsDomain` or a dedicated UI configuration domain to avoid coupling?
- What migration path is required for existing users once swipe configuration ships?
- Are there dependencies on upcoming theming or accessibility settings that should be designed together?

## References
- Dev log `dev-log/02.1.6-swipe-gestures-quick-actions.md` (history of attempts and blockers).
- Settings architecture source: `Packages/CoreModels/SettingsModels.swift`, `Packages/Persistence/Sources/Persistence/SettingsRepository.swift`, `Packages/SettingsDomain/Sources/SettingsDomain/SettingsManager.swift`.
