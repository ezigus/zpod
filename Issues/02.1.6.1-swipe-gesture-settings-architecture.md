# Issue 02.1.6.1: Settings Architecture Support for Swipe Gesture Configuration

## Priority
High

## Status
üîÑ Open ‚Äî tracked in GitHub Issue [#93](https://github.com/ezigus/zpod/issues/93)

## Description
Extending the existing settings architecture to support customizable swipe gestures currently causes the application to crash during startup. Any attempt to introduce UI-specific settings (e.g., `UISettings.swipeActions`) by modifying `SettingsModels`, `SettingsRepository`, or `SettingsManager` results in a fatal crash before the main UI renders. This work item captures the architectural investigation and remediation needed to unblock Issue 02.1.6 (‚ÄúSwipe Gestures and Quick Actions‚Äù).

## Problem Statement
- Adding new global settings structures (e.g., `UISettings`) to `SettingsModels` triggers app crashes during initialization.
- Extending `SettingsRepository` to persist additional settings surfaces concurrency issues and potential recursive change notifications.
- `SettingsManager` assumes a fixed set of global settings and publishes updates eagerly during `init`, leading to inconsistent state if new publishers are introduced.
- Because the app fails before the root view appears, no UI-based debugging or regression validation can proceed, effectively blocking all swipe configuration work.

## Observed Symptoms
- App exits immediately after launch with no visible UI when new settings types are added.
- Crash occurs before SwiftUI renders the root view; console shows `EXC_BAD_INSTRUCTION` originating from `SettingsManager` initialization and Combine publisher bridging.
- Reverting changes to `SettingsModels`, `SettingsRepository`, and `SettingsManager` restores stability, confirming the failure is limited to settings architecture changes.

## Impact
- Blocks implementation of configurable swipe actions required by Issue 02.1.6 scenario 6.
- Prevents adding any new persistent UI configuration until the settings system can be extended safely.
- Risks future expansion (e.g., theming, layout preferences) relying on the same architecture.

## Root-Cause Hypotheses
1. **Initialization Ordering** ‚Äì `SettingsManager` publishes default values before async repository loads complete, leading to inconsistent state when new `@Published` properties are injected mid-initialization.
2. **Change Notification Tight-Coupling** ‚Äì `SettingsChange` enum and `settingsChangedPublisher` broadcast synchronously, so adding new cases without refactoring can deadlock or trigger unhandled cases during startup.
3. **Repository Serialization Limits** ‚Äì Current `UserDefaultsSettingsRepository` relies on JSON encoding without schema migration, so new settings payloads may fail to decode or encode, causing fatal errors during load.
4. **Actor Isolation Boundaries** ‚Äì Mixing `@MainActor` (`SettingsManager`) with `UserDefaultsSettingsRepository` actor extensions may result in re-entrant calls that trip runtime assertions when additional async work is scheduled during initialization.

## Proposed Investigation & Remediation
1. **Reproduce Failure Under Test**
   - Introduce an integration test in `SettingsDomainTests` that instantiates `SettingsManager` with a stub repository containing UI settings to surface the crash in CI.
2. **Refactor Settings Loading Pipeline**
   - Defer publisher registration until after all initial async loads complete to avoid broadcasting partially initialized state.
   - Allow `SettingsManager` to register new setting categories via a shared abstraction (e.g., generic `GlobalSetting` wrappers).
3. **Extend `SettingsChange` Safely**
   - Replace the enum with a type-erased `SettingsChange<T>` or add a payload dictionary that tolerates new cases without requiring synchronous switch updates.
   - Ensure Combine pipelines don‚Äôt execute nested `Task` initializations before the manager state is ready.
4. **Harden Repository Serialization**
   - Add migration helpers and decoding fallbacks for unknown fields to prevent crashes when new settings structures are introduced.
5. **Document Extensibility Guidelines**
   - Provide patterns for adding new global settings, including required repository keys, Combine wiring, and migration steps.

## Acceptance Criteria
- [ ] A regression test reproduces the previous crash scenario and passes once the architecture changes are applied.
- [ ] `SettingsManager` supports registering at least one additional global settings group (UI settings) without startup crashes.
- [ ] `SettingsRepository` can persist and broadcast changes for the new settings group without blocking other settings.
- [ ] Swipe gesture configuration flows can load, modify, and persist settings end-to-end without triggering runtime exceptions.
- [ ] Documentation updated (issue and/or dev log) outlining the extension process for future settings categories.

## Recommended Tasks
1. Build a focused reproduction harness within `SettingsDomainTests` capturing the failure.
2. Introduce an abstraction for global setting channels to decouple `SettingsManager` from hard-coded cases.
3. Update `SettingsRepository` protocol + default implementation with versioned keys and tolerant decoding.
4. Ensure Combine publisher bridging remains thread-safe when new cases are added.
5. Validate against real UserDefaults storage and in-memory stubs.
6. Wire UI configuration consumers (Episode list swipe configuration) once architecture changes are stable.

## Specification References
- `zpod/spec/ui.md` ‚Äì *Customizing Swipe Gestures* scenario (Given/When/Then).
- `Issues/02.1-episode-list-management-ui.md` ‚Äì Scenario 6: Swipe Gestures & Quick Actions.

## Dependencies
- Parent: **Issue 02.1.6 ‚Äì Swipe Gestures and Quick Actions**.
- Downstream: Library feature UI implementation awaiting stable settings APIs.
- Related: `Issue 05.1.1 ‚Äì Core Settings Navigation` (ensures settings surfaces reflect new categories).

## Testing Strategy
- Extend `SettingsDomain` unit tests to cover new global settings category registration and persistence.
- Add persistence tests in `Packages/Persistence/Tests/PersistenceTests` verifying encoding/decoding resilience for expanded settings payloads.
- Run targeted smoke test of the iOS app on simulator to confirm no crash on launch with UI settings enabled.
- Execute regression suite: `./scripts/run-xcode-tests.sh -s` followed by `./scripts/run-xcode-tests.sh -t zpod` once implementation is complete.

## Open Questions
- Should new UI settings live within `SettingsDomain` or a dedicated UI configuration domain to avoid coupling?
- What migration path is required for existing users once swipe configuration ships?
- Are there dependencies on upcoming theming or accessibility settings that should be designed together?

## References
- Dev log `dev-log/02.1.6-swipe-gestures-quick-actions.md` (history of attempts and blockers).
- Settings architecture source: `Packages/CoreModels/SettingsModels.swift`, `Packages/Persistence/Sources/Persistence/SettingsRepository.swift`, `Packages/SettingsDomain/Sources/SettingsDomain/SettingsManager.swift`.
