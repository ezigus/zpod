# Issue 03.3.4.4: Add Error Detection to AVPlayerPlaybackEngine

**Status**: ðŸ†• Proposed

**Priority**: High

**Parent**: 03.3.4 - Unplayable Episode UX & Diagnostics (#269)

**Estimated Effort**: 1 hour (reduced - some infrastructure already exists)

## Description

Add error detection and mapping in `AVPlayerPlaybackEngine` to catch missing audio URLs, network failures, and timeouts, then emit appropriate `PlaybackError` types.

## Problem Statement

**Current State**:
- `AVPlayerPlaybackEngine` detects some failures via AVPlayer status observation
- Emits generic `.streamFailed` error for all failure cases
- No distinction between missing URL, network error, timeout, etc.
- No diagnostic logging of error details

**Already Implemented** (reduces scope):
- `EnhancedEpisodePlayer.play()` already checks for nil `audioURL` (line 187-194)
- Currently emits `.episodeUnavailable` â†’ needs change to `.missingAudioURL`
- `onError` callback already wired from `AVPlayerPlaybackEngine` â†’ `EnhancedEpisodePlayer.failPlayback()`
- `EpisodePlaybackState.failed` case already exists and is emitted properly

**Target State**:
- Detect missing `audioURL` before attempting playback
- Map AVPlayer errors to specific `PlaybackError` cases
- Emit `.missingAudioURL`, `.networkError`, `.timeout` appropriately
- Log detailed error information for debugging
- Emit errors through `EnhancedEpisodePlayer.failPlayback(error:)`

## Technical Design

### Pre-Playback URL Validation

```swift
// Packages/PlaybackEngine/Sources/AVPlayerPlaybackEngine.swift

public func play(episode: Episode, from position: TimeInterval) {
  // NEW: Check for missing URL before attempting playback
  guard let audioURL = episode.audioURL else {
    Logger.error("Cannot play episode '\(episode.title)': missing audioURL")
    onError?(.missingAudioURL)
    return
  }
  
  // Existing playback logic...
  let playerItem = AVPlayerItem(url: audioURL)
  player.replaceCurrentItem(with: playerItem)
  // ...
}
```

### AVPlayer Error Mapping

```swift
// Map AVPlayer/AVPlayerItem errors to PlaybackError
private func mapAVError(_ error: NSError) -> PlaybackError {
  // Check error domain and code
  switch (error.domain, error.code) {
  // Network errors
  case (NSURLErrorDomain, NSURLErrorNotConnectedToInternet),
       (NSURLErrorDomain, NSURLErrorNetworkConnectionLost),
       (NSURLErrorDomain, NSURLErrorCannotFindHost),
       (NSURLErrorDomain, NSURLErrorCannotConnectToHost):
    return .networkError
    
  // Timeout errors
  case (NSURLErrorDomain, NSURLErrorTimedOut):
    return .timeout
    
  // AVFoundation-specific errors
  case (AVFoundationErrorDomain, _):
    // Check if it's a format/codec issue
    if error.localizedDescription.contains("format") {
      return .streamFailed  // Could add .formatNotSupported if needed
    }
    return .streamFailed
    
  // Default fallback
  default:
    return .unknown(message: error.localizedDescription)
  }
}
```

### Error Observation and Handling

```swift
// Update existing AVPlayer status observation
private func observePlayerStatus() {
  player.publisher(for: \.status)
    .sink { [weak self] status in
      switch status {
      case .failed:
        guard let error = self?.player.error as? NSError else {
          self?.onError?(.streamFailed)
          return
        }
        
        let playbackError = self?.mapAVError(error) ?? .streamFailed
        
        // NEW: Detailed logging
        Logger.error("""
          AVPlayer playback failed:
          - Episode: \(self?.currentEpisode?.title ?? "unknown")
          - URL: \(self?.currentEpisode?.audioURL?.absoluteString ?? "nil")
          - Error: \(playbackError)
          - Underlying: \(error.localizedDescription)
          - Domain: \(error.domain)
          - Code: \(error.code)
          """)
        
        self?.onError?(playbackError)
        
      case .readyToPlay:
        // ...
      case .unknown:
        // ...
      }
    }
    .store(in: &cancellables)
}
```

### AVPlayerItem Failed Event Handling

```swift
// Also observe AVPlayerItem.didFailToPlayToEndTime notification
private func observePlayerItemFailure() {
  NotificationCenter.default.publisher(
    for: .AVPlayerItemFailedToPlayToEndTime
  )
  .sink { [weak self] notification in
    guard let error = notification.userInfo?[AVPlayerItemFailedToPlayToEndTimeErrorKey] as? NSError else {
      return
    }
    
    let playbackError = self?.mapAVError(error) ?? .streamFailed
    Logger.error("AVPlayerItem failed to play to end: \(playbackError)")
    self?.onError?(playbackError)
  }
  .store(in: &cancellables)
}
```

## Acceptance Criteria

- [ ] Pre-playback check for missing `audioURL` emits `.missingAudioURL`
- [ ] Network errors (no connection, host not found) emit `.networkError`
- [ ] Timeout errors emit `.timeout`
- [ ] AVPlayer status `.failed` triggers error mapping
- [ ] AVPlayerItem failure notification triggers error mapping
- [ ] Detailed error logging includes episode ID, URL, error details
- [ ] All error paths emit through `onError` callback
- [ ] Existing tests still pass (backward compatibility)
- [ ] New error cases are properly mapped

## Files to Modify

| File | Changes |
|------|---------|
| `Packages/PlaybackEngine/AVPlayerPlaybackEngine.swift` | Add `mapAVError()` method, update status observation to use error mapping, add logging (~60 lines) |
| `Packages/PlaybackEngine/EnhancedEpisodePlayer.swift` | Change `.episodeUnavailable` to `.missingAudioURL` for nil URL case (1 line change) |

## Testing Strategy

### Unit Tests (add to PlaybackEngineTests)

```swift
func testMissingAudioURLEmitsError() {
  let engine = AVPlayerPlaybackEngine()
  var receivedError: PlaybackError?
  
  engine.onError = { error in
    receivedError = error
  }
  
  let episode = Episode(/* audioURL: nil */)
  engine.play(episode, from: 0)
  
  XCTAssertEqual(receivedError, .missingAudioURL)
}

func testNetworkErrorMapping() {
  let nsError = NSError(
    domain: NSURLErrorDomain,
    code: NSURLErrorNotConnectedToInternet
  )
  
  let playbackError = engine.mapAVError(nsError)
  XCTAssertEqual(playbackError, .networkError)
}

func testTimeoutErrorMapping() {
  let nsError = NSError(
    domain: NSURLErrorDomain,
    code: NSURLErrorTimedOut
  )
  
  let playbackError = engine.mapAVError(nsError)
  XCTAssertEqual(playbackError, .timeout)
}
```

### Integration Tests (add to zpodUITests after 03.3.4 complete)

```swift
func testMissingURLTriggersErrorUI() {
  // Launch with episode that has nil audioURL
  // Tap play
  // Verify error UI appears with "doesn't have audio available"
}

func testNetworkErrorTriggersRetry() {
  // Launch with episode that will fail network
  // Tap play
  // Verify retry button appears
  // Tap retry
  // Verify new playback attempt
}
```

## Dependencies

- **Requires**: 03.3.4.1 (PlaybackError enum extension) - new error cases must exist first
- **Enables**: 03.3.4.2 (Mini-player error UI) - provides errors to display
- **Enables**: 03.3.4.3 (Expanded player error UI) - provides errors to display
- **Unblocks**: 03.3.2.7 edge-case tests

## Implementation Notes

### NSURLErrorDomain Error Codes

Common network errors to map:
- `NSURLErrorNotConnectedToInternet` (-1009)
- `NSURLErrorNetworkConnectionLost` (-1005)
- `NSURLErrorCannotFindHost` (-1003)
- `NSURLErrorCannotConnectToHost` (-1004)
- `NSURLErrorTimedOut` (-1001)

### Logging Strategy

Use structured logging with all relevant context:
- Episode ID and title
- Audio URL (if present)
- Playback Error type
- Underlying NSError details (domain, code, description)

This helps diagnose issues in production logs.

### Error Recovery Flow

1. Engine detects error (status change or notification)
2. Maps to appropriate `PlaybackError`
3. Logs detailed information
4. Calls `onError` callback
5. `EnhancedEpisodePlayer` receives error
6. Transitions to `.failed` state
7. UI layers observe state change
8. Error UI appears in mini/expanded player
9. User can retry (if recoverable)
10. Retry calls `play()` again, cycle repeats

> **Reminder**: make sure the `EnhancedEpisodePlayer` state machine, which already feeds `MiniPlayerViewModel`/`ExpandedPlayerViewModel`, receives the new errors so the published `.failed` state includes the mapped `PlaybackError`. This ensures the UI overlays trigger and the retry actions land back on the same playback service.
## Related Issues

- **03.3.4.1** - PlaybackError enum (must complete first)
- **03.3.4.2** - Mini-player error UI (consumes these errors)
- **03.3.4.3** - Expanded player error UI (consumes these errors)
- **03.3.2.7** - Edge-case tests (validates this works)
