# 02.7.3 - CI Test Flakiness: Phase 3 - Infrastructure Improvements

**Parent Issue**: #145 (02.7 - CI Test Flakiness - Investigation & Infrastructure)
**Phase**: 3 of 4
**Timeline**: 2-3 weeks (prioritized implementation)
**Goal**: Build CI reliability infrastructure (build resilience + test helpers)
**Depends On**: #02.7.2 (Phase 2 - Root Cause Analysis)

## ‚ö†Ô∏è Updated After Phase 1 Correction

**Critical Discovery**: 75% of CI failures are build/infrastructure issues, 25% are test failures.

**Updated Scope**: This phase now has TWO focus areas with different priorities:
1. **CRITICAL (Week 1-2)**: Build/Infrastructure Resilience (addresses 75% of failures)
2. **HIGH (Week 2-3)**: Test Infrastructure (addresses 25% of failures)

## Description

Implement reliability infrastructure at TWO levels based on Phase 2 root causes:

1. **CI Workflow Level** (CRITICAL): Add build/infrastructure resilience mechanisms (retry logic, caching, timeouts) to prevent 75% of failures
2. **Test Code Level** (HIGH): Create test infrastructure helpers that prevent test-level flakiness (retry helpers, wait primitives, cleanup)

## Prerequisites

From Phase 2 (#02.7.2):
- ‚úÖ Build/infrastructure failure root causes categorized (simulator, build, infra, etc.)
- ‚úÖ Test execution failure root causes categorized (timing, race conditions, etc.)
- ‚úÖ Infrastructure gaps identified for both levels
- ‚úÖ Fix recommendations prioritized by impact

## Infrastructure Components

---

## üî¥ CRITICAL: Build/Infrastructure Resilience (Addresses 75% of failures)

### 1. CI Workflow Simulator Retry Logic ‚≠ê **CRITICAL Priority**

**Problem Solved**: 40% of build/infra failures (~30% of total CI failures) from simulator boot issues
**Impact**: Prevents "simulator boot timeout", "device unavailable" failures

**Implementation**:
```yaml
# File: .github/workflows/ci.yml (simulator boot section)

- name: Boot Simulator with Retry
  id: boot-simulator
  run: |
    # Retry logic for simulator boot (3 attempts)
    for attempt in {1..3}; do
      echo "Attempt $attempt: Booting simulator..."

      # Clean up any existing simulator processes
      killall Simulator 2>/dev/null || true
      xcrun simctl shutdown all 2>/dev/null || true

      # Boot simulator with extended timeout
      if xcrun simctl boot "iPhone 15 Pro" --timeout 120; then
        echo "‚úÖ Simulator booted successfully"

        # Wait for simulator to be fully ready
        sleep 10

        # Verify simulator is responsive
        if xcrun simctl list devices | grep -q "Booted"; then
          echo "‚úÖ Simulator is responsive"
          exit 0
        fi
      fi

      if [ $attempt -lt 3 ]; then
        echo "‚ö†Ô∏è Boot failed, retrying in 10 seconds..."
        sleep 10
      fi
    done

    echo "‚ùå Failed to boot simulator after 3 attempts"
    exit 1
```

**Acceptance Criteria**:
- [ ] Retry logic added to CI workflow
- [ ] Extended timeout (120s) for simulator boot
- [ ] Simulator health check added
- [ ] Cleanup between retry attempts
- [ ] Tested on actual CI runs

---

### 2. SPM Dependency Caching ‚≠ê **CRITICAL Priority**

**Problem Solved**: 30% of build/infra failures (~22% of total CI failures) from SPM resolution/download failures
**Impact**: Prevents "dependency download timeout", "SPM resolution failed" errors

**Implementation**:
```yaml
# File: .github/workflows/ci.yml (before build step)

- name: Cache SPM Dependencies
  uses: actions/cache@v4
  with:
    path: |
      .build
      ~/Library/Developer/Xcode/DerivedData
      ~/Library/Caches/org.swift.swiftpm
    key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
    restore-keys: |
      ${{ runner.os }}-spm-

- name: Resolve SPM Dependencies with Retry
  run: |
    for attempt in {1..3}; do
      echo "Attempt $attempt: Resolving SPM dependencies..."

      if xcodebuild -resolvePackageDependencies -scheme zpod -configuration Debug; then
        echo "‚úÖ Dependencies resolved successfully"
        exit 0
      fi

      if [ $attempt -lt 3 ]; then
        echo "‚ö†Ô∏è Resolution failed, clearing cache and retrying..."
        rm -rf .build ~/Library/Developer/Xcode/DerivedData
        sleep 5
      fi
    done

    echo "‚ùå Failed to resolve dependencies after 3 attempts"
    exit 1
```

**Acceptance Criteria**:
- [ ] SPM cache added to CI workflow
- [ ] Retry logic for dependency resolution
- [ ] Cache invalidation on failure
- [ ] Verified cache hit rates >80%

---

### 3. Workflow Timeout Adjustments ‚≠ê **HIGH Priority**

**Problem Solved**: 20% of build/infra failures (~15% of total CI failures) from infrastructure timeouts
**Impact**: Prevents "workflow timeout", "step timeout" failures

**Implementation**:
```yaml
# File: .github/workflows/ci.yml

jobs:
  ui-tests-swipe:
    timeout-minutes: 60  # Increased from 30
    steps:
      - name: Run UI Tests
        timeout-minutes: 45  # Individual step timeout
        run: ./scripts/run-xcode-tests.sh -t SwipeConfigurationUITests
```

**Acceptance Criteria**:
- [ ] Workflow timeout increased to 60 minutes
- [ ] Individual step timeouts added
- [ ] Tested on slower CI runners

**Expected Total Impact**: These 3 could reduce CI failure rate from 93.4% to ~26%

---

## ‚ö†Ô∏è HIGH: Test Infrastructure (Addresses 25% of failures)

### 1. Retry Mechanism ‚≠ê **High Priority**

**Problem Solved**: 40% of flakiness from timing/synchronization issues
**Impact**: Prevents "element not found" failures during transitions

**Implementation**:
```swift
// File: zpodUITests/TestSupport/RetryHelpers.swift

extension XCTestCase {
  /// Retries an operation that may fail due to timing issues
  func retryOnFailure<T>(
    attempts: Int = 3,
    delay: TimeInterval = 0.5,
    operation: () throws -> T
  ) rethrows -> T {
    var lastError: Error?
    for attempt in 1...attempts {
      do {
        return try operation()
      } catch {
        lastError = error
        if attempt < attempts {
          Thread.sleep(forTimeInterval: delay)
        }
      }
    }
    throw lastError!
  }

  /// Retries element discovery with exponential backoff
  func retryElementDiscovery<T>(
    _ query: () -> XCUIElement,
    operation: (XCUIElement) throws -> T
  ) rethrows -> T {
    return try retryOnFailure(attempts: 3, delay: 0.5) {
      let element = query()
      guard element.exists else {
        throw TestError.elementNotFound
      }
      return try operation(element)
    }
  }
}
```

**Acceptance Criteria**:
- [ ] `retryOnFailure` helper implemented
- [ ] `retryElementDiscovery` helper implemented
- [ ] Unit tests for retry logic
- [ ] Documentation added to testing guide

---

### 2. Stable Wait Primitives ‚≠ê **High Priority**

**Problem Solved**: 25% of flakiness from animations/transitions
**Impact**: Prevents tapping elements mid-animation

**Implementation**:
```swift
// File: zpodUITests/TestSupport/StableWaitHelpers.swift

extension XCUIElement {
  /// Waits for element to exist AND have stable frame (not animating)
  func waitForStable(timeout: TimeInterval = 5.0) -> Bool {
    guard waitForExistence(timeout: timeout) else { return false }

    var lastFrame = frame
    let stabilityWindow: TimeInterval = 0.5  // Must be stable for 500ms
    let deadline = Date().addingTimeInterval(stabilityWindow)

    while Date() < deadline {
      Thread.sleep(forTimeInterval: 0.05)  // Check every 50ms
      if frame == lastFrame {
        return true  // Frame hasn't changed for 500ms
      }
      lastFrame = frame
      deadline = Date().addingTimeInterval(stabilityWindow)  // Reset timer
    }

    return true
  }

  /// Waits for animation to complete on element
  func waitForAnimationComplete(timeout: TimeInterval = 2.0) -> Bool {
    return waitForStable(timeout: timeout)
  }

  /// Waits for element to be hittable (exists, visible, not obscured)
  func waitForHittable(timeout: TimeInterval = 5.0) -> Bool {
    let predicate = NSPredicate { [weak self] _, _ in
      guard let element = self else { return false }
      return element.exists && element.isHittable
    }
    let expectation = XCTNSPredicateExpectation(predicate: predicate, object: nil)
    return XCTWaiter.wait(for: [expectation], timeout: timeout) == .completed
  }
}
```

**Acceptance Criteria**:
- [ ] `waitForStable` helper implemented
- [ ] `waitForAnimationComplete` helper implemented
- [ ] `waitForHittable` helper implemented
- [ ] Tested with real animation scenarios
- [ ] Documentation with examples

---

### 3. Environmental Isolation ‚≠ê **Medium Priority**

**Problem Solved**: 10% of flakiness from state pollution
**Impact**: Prevents tests from affecting each other

**Implementation**:
```swift
// File: zpodUITests/TestSupport/EnvironmentalIsolation.swift

protocol TestEnvironmentIsolation {
  func clearUserDefaults()
  func clearKeychain()
  func resetAppState()
}

extension XCTestCase: TestEnvironmentIsolation {
  /// Clears all UserDefaults to prevent state pollution
  func clearUserDefaults() {
    let defaults = UserDefaults.standard
    defaults.dictionaryRepresentation().keys.forEach {
      defaults.removeObject(forKey: $0)
    }
    defaults.synchronize()
  }

  /// Clears keychain items for test isolation
  func clearKeychain() {
    let secItemClasses = [
      kSecClassGenericPassword,
      kSecClassInternetPassword,
      kSecClassCertificate,
      kSecClassKey,
      kSecClassIdentity
    ]

    for itemClass in secItemClasses {
      let spec: [String: Any] = [kSecClass as String: itemClass]
      SecItemDelete(spec as CFDictionary)
    }
  }

  /// Terminates and relaunches app to clear in-memory state
  func resetAppState() {
    XCUIApplication().terminate()
    // App relaunched automatically in setUp
  }

  /// Standard cleanup for test isolation
  func performStandardCleanup() {
    clearUserDefaults()
    clearKeychain()
    // App termination happens in tearDown
  }
}

// Extend base test case to use standard cleanup
extension SwipeConfigurationTestCase {
  override func tearDown() {
    performStandardCleanup()
    super.tearDown()
  }
}
```

**Acceptance Criteria**:
- [ ] `clearUserDefaults` helper implemented
- [ ] `clearKeychain` helper implemented
- [ ] `performStandardCleanup` integrated into test base classes
- [ ] Verified tests don't affect each other
- [ ] Documentation on when to use

---

### 4. CI-Specific Timeout Adjustments **Medium Priority**

**Problem Solved**: 25% of flakiness from CI environment being slower
**Impact**: Prevents false timeouts on slower CI machines

**Implementation**:
```swift
// File: zpodUITests/TestSupport/CIConfiguration.swift

struct TestConfiguration {
  static let isCI: Bool = {
    ProcessInfo.processInfo.environment["CI"] != nil
  }()

  static let timeoutMultiplier: Double = {
    isCI ? 2.0 : 1.0  // Double timeouts in CI
  }()

  static func adaptiveTimeout(_ baseTimeout: TimeInterval) -> TimeInterval {
    return baseTimeout * timeoutMultiplier
  }
}

// Usage in tests:
let timeout = TestConfiguration.adaptiveTimeout(5.0)  // 5s local, 10s CI
XCTAssertTrue(element.waitForExistence(timeout: timeout))
```

**Acceptance Criteria**:
- [ ] CI detection logic implemented
- [ ] Adaptive timeout helper created
- [ ] Applied to test base classes
- [ ] Verified with actual CI runs
- [ ] Documentation on usage

---

### 5. Improved Element Discovery **High Priority**

**Problem Solved**: Lazy SwiftUI materialization causing "not found" errors
**Impact**: Handles SwiftUI's deferred rendering

**Implementation**:
```swift
// File: zpodUITests/TestSupport/ImprovedElementDiscovery.swift

extension XCUIElement {
  /// Discovers element with scroll-to-reveal if needed
  func discoverWithScrolling(
    in scrollView: XCUIElement,
    timeout: TimeInterval = 5.0
  ) -> Bool {
    if waitForExistence(timeout: timeout) {
      return true
    }

    // Element doesn't exist, try scrolling to reveal
    let maxScrollAttempts = 5
    for _ in 0..<maxScrollAttempts {
      scrollView.swipeUp()
      if waitForExistence(timeout: 1.0) {
        return true
      }
    }

    return false
  }

  /// Waits for element with automatic retry and logging
  func waitWithRetry(
    timeout: TimeInterval = 5.0,
    description: String? = nil
  ) -> Bool {
    let success = waitForExistence(timeout: timeout)
    if !success, let desc = description {
      print("[Test] Element not found: \(desc)")
    }
    return success
  }
}
```

**Acceptance Criteria**:
- [ ] `discoverWithScrolling` helper implemented
- [ ] `waitWithRetry` helper with logging
- [ ] Integrated into SwipeConfiguration test support
- [ ] Tested with lazy-loaded SwiftUI views
- [ ] Documentation with examples

---

## Deliverables

### 1. Test Infrastructure Files
```
zpodUITests/TestSupport/
‚îú‚îÄ‚îÄ RetryHelpers.swift              (retry mechanism)
‚îú‚îÄ‚îÄ StableWaitHelpers.swift         (animation/stability waits)
‚îú‚îÄ‚îÄ EnvironmentalIsolation.swift    (cleanup helpers)
‚îú‚îÄ‚îÄ CIConfiguration.swift           (CI-specific adjustments)
‚îî‚îÄ‚îÄ ImprovedElementDiscovery.swift  (better element finding)
```

### 2. Documentation
**File**: `docs/testing/preventing-flakiness.md`

**Contents**:
```markdown
# Preventing Test Flakiness

## Quick Reference

### Always Use Waits
‚ùå Bad: `app.buttons["Submit"].tap()`
‚úÖ Good: `let btn = app.buttons["Submit"]; XCTAssertTrue(btn.waitForExistence(timeout: 5.0)); btn.tap()`

### Wait for Stable Elements
‚ùå Bad: `element.tap()`  // May tap mid-animation
‚úÖ Good: `element.waitForStable(); element.tap()`

### Retry Flaky Operations
```swift
retryOnFailure {
  // Operation that might fail due to timing
  complexUIInteraction()
}
```

### Clean Up State
```swift
override func tearDown() {
  performStandardCleanup()  // Clears UserDefaults, Keychain
  super.tearDown()
}
```
```

### 3. Migration Guide
**File**: `docs/testing/flakiness-migration-guide.md`

Shows how to migrate existing tests to use new infrastructure

---

## Acceptance Criteria

- [ ] All 5 infrastructure components implemented
- [ ] Test support files created and documented
- [ ] Integrated into existing test base classes
- [ ] Documentation written (`preventing-flakiness.md`)
- [ ] Migration guide created for existing tests
- [ ] At least 3 existing flaky tests migrated as examples
- [ ] CI runs show reduced flakiness (measured weekly)

## Success Metrics

**Before Infrastructure**:
- Manual retry logic duplicated in tests
- No standard cleanup patterns
- Fixed timeouts fail in CI
- No animation/stability waits

**After Infrastructure**:
- Reusable helpers available to all tests
- Standard cleanup applied automatically
- Timeouts adjust for CI environment
- Animation waits prevent mid-transition taps
- Flakiness rate reduced by 50%+ (target)

## Migration Strategy

### Phase 1: Foundation (Week 1)
- Implement retry helpers
- Implement stable wait helpers
- Add to test base classes

### Phase 2: Integration (Week 2)
- Apply to top 3 flakiest tests
- Measure improvement
- Gather feedback

### Phase 3: Rollout (Week 3-4)
- Document patterns
- Migrate remaining flaky tests
- Update testing guidelines

## Notes

**This is Ongoing**:
- Infrastructure evolves as new patterns emerge
- Weekly reviews identify gaps
- Continuous improvement based on flakiness dashboard

**Benefits Beyond Flakiness**:
- ‚úÖ Easier to write new tests (helpers available)
- ‚úÖ Tests more readable (clear intent with helpers)
- ‚úÖ Faster test development (less debugging)
- ‚úÖ Knowledge transfer (documented patterns)

## References

- Parent: #145 (02.7 - CI Test Flakiness Master Issue)
- Prerequisites: #02.7.2 (Root cause analysis)
- Next: #02.7.4+ (Targeted fixes using this infrastructure)
- XCTest Best Practices: Apple WWDC sessions on UI testing
