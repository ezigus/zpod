# Issue 03.3.7: Player Tab Playback Wiring

**Status**: ðŸ†• Proposed

**Priority**: High

**Parent**: 03.3 - Audio Playback Implementation

**GitHub Issue**: [#272](https://github.com/ezigus/zpod/issues/272)

## Description

The Player tab in `ContentView.swift` currently uses a simplified placeholder player view and sample state. Replace it with the full player interface and wire it to the real `EpisodePlaybackService`, keeping the mini-player and full player in sync.

## Problem Statement

**Current State**:
- `ContentView.swift` has placeholder `@State` for playback
- Sample episodes use `example.com` URLs (non-playable)
- Mini-player shows fake/static data
- No connection to actual `EpisodePlaybackService`

**Target State**:
- Player tab embeds the full player UI (no duplicate simplified player)
- Player tab observes real `EpisodePlaybackService.statePublisher`
- Mini-player updates from real playback state
- Expanded player updates from real playback state
- Play/pause/seek commands go to real service

## Technical Analysis

### Current Placeholder Code (Likely)

```swift
// ContentView.swift - PLACEHOLDER
struct ContentView: View {
    @State private var isPlaying = false
    @State private var currentEpisode: Episode? = sampleEpisode
    @State private var currentPosition: TimeInterval = 0

    var body: some View {
        // Uses @State instead of real service
    }
}
```

### Target Architecture

```swift
// ContentView.swift - CORRECT
struct ContentView: View {
    @EnvironmentObject var playbackService: EpisodePlaybackService
    @StateObject private var miniPlayerViewModel: MiniPlayerViewModel

    init() {
        // ViewModel observes service
    }

    var body: some View {
        ZStack {
            TabView { /* tabs */ }

            if miniPlayerViewModel.hasActivePlayback {
                MiniPlayerView(viewModel: miniPlayerViewModel)
            }
        }
    }
}
```

## Acceptance Criteria

- [ ] Player tab renders `ExpandedPlayerView` (no simplified placeholder player)
- [ ] `ContentView` observes `EpisodePlaybackService` (not placeholder `@State`)
- [ ] Mini-player shows actual playback state
- [ ] Mini-player controls (play/pause) send commands to real service
- [ ] Expanded player shows actual playback state
- [ ] Expanded player controls work correctly
- [ ] Seeking updates real playback position
- [ ] Skip forward/backward work
- [ ] No placeholder/sample data in production
- [ ] SwiftUI previews still work (with stub service)

## Spec References

See `zpod/spec/spec.md` - User Interface and Experience:
- **Accessing the Mini-Player Pill**
- **Expanding the Mini-Player**
- **Hiding the Mini-Player**
- **Opening the Full Player from the Player Tab**

## Files to Modify

| File | Changes |
|------|---------|
| `Packages/LibraryFeature/Sources/LibraryFeature/ContentView.swift` | Replace placeholder with real service |
| `Packages/PlayerFeature/Sources/PlayerFeature/MiniPlayerView.swift` | Verify uses ViewModel correctly |
| `Packages/PlayerFeature/Sources/PlayerFeature/MiniPlayerViewModel.swift` | Verify observes service |
| `Packages/PlayerFeature/Sources/PlayerFeature/ExpandedPlayerView.swift` | Verify uses ViewModel correctly |
| `Packages/PlayerFeature/Sources/PlayerFeature/ExpandedPlayerViewModel.swift` | Verify observes service |

## Implementation Steps

### 1. Audit Current ContentView

```swift
// Check what's currently in ContentView.swift
// Identify placeholder @State properties
// Identify sample episode data
```

### 2. Inject PlaybackService via Environment

```swift
// zpodApp.swift
@main
struct ZpodApp: App {
    @StateObject private var playbackService = AVPlayerPlaybackEngine()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(playbackService)
        }
    }
}
```

### 3. Update ContentView to Use Service

```swift
// ContentView.swift
struct ContentView: View {
    @EnvironmentObject var playbackService: EpisodePlaybackService

    @StateObject private var miniPlayerVM: MiniPlayerViewModel

    init() {
        // Initialize ViewModel - will get service from environment
    }

    var body: some View {
        ZStack(alignment: .bottom) {
            TabView {
                // ... tabs
            }

            if miniPlayerVM.shouldShowMiniPlayer {
                MiniPlayerView(viewModel: miniPlayerVM)
                    .transition(.move(edge: .bottom))
            }
        }
    }
}
```

### 4. Verify MiniPlayerViewModel

```swift
// MiniPlayerViewModel.swift
@MainActor
public final class MiniPlayerViewModel: ObservableObject {
    @Published public var currentEpisode: Episode?
    @Published public var currentPosition: TimeInterval = 0
    @Published public var duration: TimeInterval = 0
    @Published public var isPlaying: Bool = false

    private var cancellable: AnyCancellable?
    private let playbackService: EpisodePlaybackService

    public init(playbackService: EpisodePlaybackService) {
        self.playbackService = playbackService
        subscribeToState()
    }

    private func subscribeToState() {
        cancellable = playbackService.statePublisher
            .receive(on: RunLoop.main)
            .sink { [weak self] state in
                self?.handleState(state)
            }
    }

    public func togglePlayPause() {
        if isPlaying {
            playbackService.pause()
        } else if let episode = currentEpisode {
            playbackService.play(episode: episode, duration: duration)
        }
    }
}
```

### 5. Remove Sample Episode Data

```swift
// Remove or gate behind DEBUG
#if DEBUG
let sampleEpisode = Episode(...)  // For previews only
#endif
```

## Testing Strategy

### Unit Tests
- ViewModel receives state updates from service
- ViewModel correctly maps state to properties
- ViewModel commands call service methods

### UI Tests
- Mini-player appears when playback starts
- Mini-player disappears when playback stops
- Controls work correctly

### Integration Tests
- Full flow: tap episode â†’ play â†’ mini-player updates
- Seeking â†’ position updates in UI

## Dependencies

- **03.3.2**: Real playback service must exist
- **03.3.6**: DI wiring must be configured
- ViewModels already exist (verify they work correctly)

## Estimated Effort

**Medium** - 3-4 hours
- Audit current code
- Remove placeholders
- Wire up environment injection
- Verify all controls work
- Update previews

## SwiftUI Preview Considerations

Previews need a stub service to render without real audio:

```swift
struct MiniPlayerView_Previews: PreviewProvider {
    static var previews: some View {
        MiniPlayerView(viewModel: .preview)
    }
}

extension MiniPlayerViewModel {
    static var preview: MiniPlayerViewModel {
        let vm = MiniPlayerViewModel(playbackService: StubPlaybackService())
        vm.currentEpisode = Episode.sample
        vm.isPlaying = true
        vm.currentPosition = 60
        vm.duration = 3600
        return vm
    }
}
```

## Notes

- Remove all `example.com` placeholder URLs
- Ensure real episodes from feed parsing are used
- Consider showing "No episode playing" state in mini-player
- Tab bar should not be obscured by mini-player (see 03.2)
