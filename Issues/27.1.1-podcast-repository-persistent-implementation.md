# Issue 27.1.1: Podcast Repository Persistent Implementation

**Status**: ðŸ”„ REOPENED (2026-01-25 â€” move to Persistence package + harden tests)
**Priority**: P0 - CRITICAL (Technical Debt - Production using test code)
**Created**: 2026-01-02
**Completed**: 2026-01-15
**Category**: Architecture / Persistence

## Description

Implement a production-grade `PodcastRepository` using SwiftData for persistent storage of podcast library data. Currently, the zpod app uses `InMemoryPodcastManager` which loses all data on app restart, preventing users from maintaining a persistent podcast library.

## Problem Statement

**Current State**:
- Production app (`zpod/ZpodApp.swift`) imports and uses `InMemoryPodcastManager` from TestSupport
- All podcast subscriptions, folder organization, and metadata lost on app restart
- TestSupport package incorrectly linked into production builds
- Two duplicate implementations of `InMemoryPodcastManager` exist:
  - `Packages/TestSupport/Sources/TestSupport/InMemoryPodcastManager.swift`
  - `zpod/Controllers/PodcastManager.swift`

**Impact**:
- âŒ Users lose all podcasts when app closes
- âŒ Test code shipping in production builds
- âŒ No real persistence layer for podcast library
- âŒ Violates architectural guidelines (Persistence layer missing)

## Acceptance Criteria

- [x] ~~Create `PodcastRepository.swift` in `Packages/Persistence/Sources/Persistence/`~~ âœ… Created `SwiftDataPodcastManager.swift` in `zpod/Persistence/` (see deviation notes)
- [x] Implement `PodcastManaging` protocol with SwiftData persistence âœ…
- [x] Support all operations from protocol: âœ…
  - [x] `all()` - Fetch all podcasts âœ…
  - [x] `find(id:)` - Find by ID âœ…
  - [x] `add(_:)` - Add podcast âœ…
  - [x] `update(_:)` - Update podcast âœ…
  - [x] `remove(id:)` - Remove podcast âœ…
  - [x] `findByFolder(folderId:)` - Filter by folder âœ…
  - [x] `findByFolderRecursive(folderId:folderManager:)` - Recursive folder filter âœ…
  - [x] `findByTag(tagId:)` - Filter by tag âœ…
  - [x] `findUnorganized()` - Find unorganized podcasts âœ…
- [x] Implement SwiftData model for `Podcast` entity âœ… (PodcastEntity.swift)
- [x] Preserve Siri snapshot persistence functionality âœ…
- [x] ~~Add migration support for future schema changes~~ â³ Deferred (not needed yet)
- [x] Unit tests with in-memory ModelContainer for all operations âœ… (31 tests)
- [x] Integration tests with persistent ModelContainer âœ… (8 tests)
- [x] Thread-safe implementation with proper actor isolation âœ… (serial DispatchQueue)
- [x] Documentation with usage examples âœ…

## Reopened Scope (2026-01-25)

- [ ] Move the SwiftData-backed repository into `Packages/Persistence` with proper product export and rename to `SwiftDataPodcastRepository` (or `PodcastRepository`) for consistency.
- [ ] Decouple persistence from Siri snapshot creation (inject `SiriSnapshotRefreshing`; no internal coordinator construction).
- [ ] Add concurrency/error-path tests (save failure + concurrent calls) to validate thread-safety beyond happy paths.
- [ ] Keep ContentView/ZpodApp wiring pointed at the package type; ensure app/extension targets link only what they need.
- [ ] Update docs/dev-log/status once the above are complete; run targeted tests and CI before closing.

## Implementation Design

### SwiftData Model

```swift
import SwiftData
import CoreModels

@Model
final class PodcastEntity {
    @Attribute(.unique) var id: String
    var title: String
    var author: String
    var podcastDescription: String // 'description' reserved in SwiftData
    var artworkURL: String?
    var feedURL: String
    var categories: [String]
    var isSubscribed: Bool
    var dateAdded: Date
    var folderId: String?
    var tagIds: [String]

    // Relationship to episodes (if persisting episodes in SwiftData)
    @Relationship(deleteRule: .cascade) var episodes: [EpisodeEntity]

    init(id: String, title: String, /* ... */) {
        // Initialize all properties
    }

    // Conversion to/from CoreModels.Podcast
    func toDomain() -> Podcast { /* ... */ }
    static func fromDomain(_ podcast: Podcast) -> PodcastEntity { /* ... */ }
}
```

### Repository Implementation

```swift
import SwiftData
import CoreModels
import SharedUtilities

@ModelActor
public actor PodcastRepository: PodcastManaging {
    private let modelContainer: ModelContainer

    public init(modelContainer: ModelContainer) {
        self.modelContainer = modelContainer
        self.modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)
    }

    public func all() -> [Podcast] {
        let descriptor = FetchDescriptor<PodcastEntity>()
        let entities = try? modelContext.fetch(descriptor)
        return entities?.map { $0.toDomain() } ?? []
    }

    public func find(id: String) -> Podcast? {
        let predicate = #Predicate<PodcastEntity> { $0.id == id }
        let descriptor = FetchDescriptor(predicate: predicate)
        return try? modelContext.fetch(descriptor).first?.toDomain()
    }

    public func add(_ podcast: Podcast) {
        let entity = PodcastEntity.fromDomain(podcast)
        modelContext.insert(entity)
        try? modelContext.save()
        persistSiriSnapshots()
    }

    public func update(_ podcast: Podcast) {
        guard let entity = fetchEntity(id: podcast.id) else { return }
        entity.updateFrom(podcast)
        try? modelContext.save()
        persistSiriSnapshots()
    }

    public func remove(id: String) {
        guard let entity = fetchEntity(id: id) else { return }
        modelContext.delete(entity)
        try? modelContext.save()
        persistSiriSnapshots()
    }

    // Organization methods implementation...

    private func fetchEntity(id: String) -> PodcastEntity? {
        let predicate = #Predicate<PodcastEntity> { $0.id == id }
        let descriptor = FetchDescriptor(predicate: predicate)
        return try? modelContext.fetch(descriptor).first
    }

    private func persistSiriSnapshots() {
        // Move Siri snapshot logic here from InMemoryPodcastManager
    }
}
```

### Migration Considerations

- Initial schema version 1.0
- Plan for future migrations:
  - Episode persistence (currently transient in Podcast model)
  - Playback position tracking
  - Download state management
  - Custom artwork support

## Dependencies

- Depends on: `CoreModels` (PodcastManaging protocol, Podcast model)
- Depends on: `SharedUtilities` (AppGroup for Siri snapshots)
- Depends on: SwiftData framework (iOS 18+)

## Related Issues

- Issue 27.1.2: Migrate zpod app to use PodcastRepository
- Issue 27.1.3: Remove duplicate InMemoryPodcastManager implementations
- Issue 02.1.8.1: CarPlay Siri Data Wiring (uses PodcastManager for snapshots)

## Spec References

- Architecture guidelines in `AGENTS.md` Section 6: "Package structure includes Persistence layer"
- `zpod/spec/spec.md` - Podcast subscription and organization scenarios

## Testing Strategy

### Unit Tests (`PersistenceTests/PodcastRepositoryTests.swift`)

- [ ] Test CRUD operations with in-memory ModelContainer
- [ ] Test organization filtering (folders, tags, unorganized)
- [ ] Test concurrent access patterns (actor isolation)
- [ ] Test Siri snapshot persistence
- [ ] Test error handling (database errors, constraint violations)
- [ ] Test migration scenarios (future)

### Integration Tests

- [ ] Test with persistent ModelContainer
- [ ] Test data survives app restart (write, terminate, relaunch)
- [ ] Test integration with FolderManaging for recursive queries
- [ ] Test Siri snapshot accessibility from app group

## Implementation Notes

### Thread Safety

- Use `@ModelActor` for automatic thread-safe access
- All operations run on background context
- UI updates via `@MainActor` in consuming code

### Episode Persistence Strategy

**Decision Required**: Should episodes be persisted in SwiftData or remain transient?

**Option A - Transient Episodes (Current)**:
- Pros: Simpler implementation, matches current model
- Cons: Episodes re-downloaded on each app launch (from feed)

**Option B - Persistent Episodes**:
- Pros: Faster app launch, offline access to episode metadata
- Cons: More complex migrations, increased storage

**Recommendation**: Start with Option A (transient), migrate to Option B in future issue.

### Siri Snapshot Integration

- Preserve existing snapshot format (`SiriPodcastSnapshot`, `SiriEpisodeSnapshot`)
- Maintain compatibility with `zpodIntents` extension
- Continue writing to app group (`group.us.zig.zpod`)

## Known Risks

- **Breaking Change**: Existing in-memory data will be lost during migration (acceptable since nothing persists currently)
- **Performance**: SwiftData queries may be slower than in-memory dictionary lookups (profile and optimize if needed)
- **Migration Complexity**: Future schema changes require careful versioning

## Definition of Done

- [x] PodcastRepository implementation complete with all protocol methods âœ…
- [x] SwiftData models defined and tested âœ…
- [x] Unit tests passing (>90% code coverage) âœ…
- [x] Integration tests passing âœ…
- [x] Documentation written with code examples âœ…
- [x] Dev-log entry created documenting design decisions âœ…
- [x] Code review approved âœ…
- [x] Merged to main branch âœ…

## Implementation Notes

**Actual Implementation**: `SwiftDataPodcastManager` (not `PodcastRepository`)
**Location**: `zpod/Persistence/` (not `Packages/Persistence/`)

**Key Architectural Decisions**:

1. **App Target vs SPM Package**
   - **Planned**: Create in `Packages/Persistence/`
   - **Actual**: Created in `zpod/Persistence/`
   - **Reason**: Swift 6.x @Model macro expansion limitations across module boundaries
   - **Impact**: Tighter coupling to app, but avoids build system complexity
   - **Reference**: WWDC 2024 SwiftData best practices

2. **Serial DispatchQueue vs @ModelActor**
   - **Planned**: Use @ModelActor for automatic thread safety
   - **Actual**: Use serial DispatchQueue for explicit synchronization
   - **Reason**: PodcastManaging protocol has synchronous methods (not async)
   - **Impact**: ~0.1ms overhead per operation (negligible for UI-driven actions)
   - **Future**: Can migrate to @ModelActor + async protocol if needed

3. **Episode Persistence**
   - **Decision**: Episodes remain transient (not persisted in SwiftData)
   - **Reason**: Fetched from RSS feeds on demand
   - **Impact**: Simpler schema, always fresh episode data
   - **Future**: Add episode persistence in Issue 28.1 (Offline Streaming)

**Test Coverage**:
- 31 unit tests (`SwiftDataPodcastManagerTests.swift`)
- 8 integration tests (`PodcastPersistenceIntegrationTests.swift`)
- >90% line coverage of SwiftDataPodcastManager.swift

**Known Limitations**:
1. Tag filtering uses in-memory filter (O(n)) - acceptable for <10,000 podcasts
2. No schema migration framework yet - deferred until schema changes needed
3. Serial queue could become bottleneck at high concurrency - profile if issues arise

**Documentation**:
- Dev-log: `dev-log/27.1-podcast-persistence-foundation.md`
- Implementation Summary: `dev-log/implementation-summaries/27.1-podcast-persistence-foundation.md`

## Time Estimate

- Design & SwiftData models: 2 hours
- Core CRUD implementation: 3 hours
- Organization queries implementation: 2 hours
- Siri snapshot integration: 1 hour
- Unit tests: 3 hours
- Integration tests: 2 hours
- Documentation: 1 hour
- **Total**: ~14 hours

---

**Created**: 2026-01-02
**Blocker**: This blocks Issue 27.1.2 (migration to production)
**Technical Debt**: HIGH - Production app currently using test infrastructure
