# Issue 27.1.1: Podcast Repository Persistent Implementation

**Status**: ðŸ†• NEW
**Priority**: P0 - CRITICAL (Technical Debt - Production using test code)
**Created**: 2026-01-02
**Category**: Architecture / Persistence

## Description

Implement a production-grade `PodcastRepository` using SwiftData for persistent storage of podcast library data. Currently, the zpod app uses `InMemoryPodcastManager` which loses all data on app restart, preventing users from maintaining a persistent podcast library.

## Problem Statement

**Current State**:
- Production app (`zpod/ZpodApp.swift`) imports and uses `InMemoryPodcastManager` from TestSupport
- All podcast subscriptions, folder organization, and metadata lost on app restart
- TestSupport package incorrectly linked into production builds
- Two duplicate implementations of `InMemoryPodcastManager` exist:
  - `Packages/TestSupport/Sources/TestSupport/InMemoryPodcastManager.swift`
  - `zpod/Controllers/PodcastManager.swift`

**Impact**:
- âŒ Users lose all podcasts when app closes
- âŒ Test code shipping in production builds
- âŒ No real persistence layer for podcast library
- âŒ Violates architectural guidelines (Persistence layer missing)

## Acceptance Criteria

- [ ] Create `PodcastRepository.swift` in `Packages/Persistence/Sources/Persistence/`
- [ ] Implement `PodcastManaging` protocol with SwiftData persistence
- [ ] Support all operations from protocol:
  - [ ] `all()` - Fetch all podcasts
  - [ ] `find(id:)` - Find by ID
  - [ ] `add(_:)` - Add podcast
  - [ ] `update(_:)` - Update podcast
  - [ ] `remove(id:)` - Remove podcast
  - [ ] `findByFolder(folderId:)` - Filter by folder
  - [ ] `findByFolderRecursive(folderId:folderManager:)` - Recursive folder filter
  - [ ] `findByTag(tagId:)` - Filter by tag
  - [ ] `findUnorganized()` - Find unorganized podcasts
- [ ] Implement SwiftData model for `Podcast` entity
- [ ] Preserve Siri snapshot persistence functionality
- [ ] Add migration support for future schema changes
- [ ] Unit tests with in-memory ModelContainer for all operations
- [ ] Integration tests with persistent ModelContainer
- [ ] Thread-safe implementation with proper actor isolation
- [ ] Documentation with usage examples

## Implementation Design

### SwiftData Model

```swift
import SwiftData
import CoreModels

@Model
final class PodcastEntity {
    @Attribute(.unique) var id: String
    var title: String
    var author: String
    var podcastDescription: String // 'description' reserved in SwiftData
    var artworkURL: String?
    var feedURL: String
    var categories: [String]
    var isSubscribed: Bool
    var dateAdded: Date
    var folderId: String?
    var tagIds: [String]

    // Relationship to episodes (if persisting episodes in SwiftData)
    @Relationship(deleteRule: .cascade) var episodes: [EpisodeEntity]

    init(id: String, title: String, /* ... */) {
        // Initialize all properties
    }

    // Conversion to/from CoreModels.Podcast
    func toDomain() -> Podcast { /* ... */ }
    static func fromDomain(_ podcast: Podcast) -> PodcastEntity { /* ... */ }
}
```

### Repository Implementation

```swift
import SwiftData
import CoreModels
import SharedUtilities

@ModelActor
public actor PodcastRepository: PodcastManaging {
    private let modelContainer: ModelContainer

    public init(modelContainer: ModelContainer) {
        self.modelContainer = modelContainer
        self.modelExecutor = DefaultSerialModelExecutor(modelContext: modelContext)
    }

    public func all() -> [Podcast] {
        let descriptor = FetchDescriptor<PodcastEntity>()
        let entities = try? modelContext.fetch(descriptor)
        return entities?.map { $0.toDomain() } ?? []
    }

    public func find(id: String) -> Podcast? {
        let predicate = #Predicate<PodcastEntity> { $0.id == id }
        let descriptor = FetchDescriptor(predicate: predicate)
        return try? modelContext.fetch(descriptor).first?.toDomain()
    }

    public func add(_ podcast: Podcast) {
        let entity = PodcastEntity.fromDomain(podcast)
        modelContext.insert(entity)
        try? modelContext.save()
        persistSiriSnapshots()
    }

    public func update(_ podcast: Podcast) {
        guard let entity = fetchEntity(id: podcast.id) else { return }
        entity.updateFrom(podcast)
        try? modelContext.save()
        persistSiriSnapshots()
    }

    public func remove(id: String) {
        guard let entity = fetchEntity(id: id) else { return }
        modelContext.delete(entity)
        try? modelContext.save()
        persistSiriSnapshots()
    }

    // Organization methods implementation...

    private func fetchEntity(id: String) -> PodcastEntity? {
        let predicate = #Predicate<PodcastEntity> { $0.id == id }
        let descriptor = FetchDescriptor(predicate: predicate)
        return try? modelContext.fetch(descriptor).first
    }

    private func persistSiriSnapshots() {
        // Move Siri snapshot logic here from InMemoryPodcastManager
    }
}
```

### Migration Considerations

- Initial schema version 1.0
- Plan for future migrations:
  - Episode persistence (currently transient in Podcast model)
  - Playback position tracking
  - Download state management
  - Custom artwork support

## Dependencies

- Depends on: `CoreModels` (PodcastManaging protocol, Podcast model)
- Depends on: `SharedUtilities` (AppGroup for Siri snapshots)
- Depends on: SwiftData framework (iOS 18+)

## Related Issues

- Issue 27.1.2: Migrate zpod app to use PodcastRepository
- Issue 27.1.3: Remove duplicate InMemoryPodcastManager implementations
- Issue 02.1.8.1: CarPlay Siri Data Wiring (uses PodcastManager for snapshots)

## Spec References

- Architecture guidelines in `AGENTS.md` Section 6: "Package structure includes Persistence layer"
- `spec/library.md` - Podcast subscription management requirements

## Testing Strategy

### Unit Tests (`PersistenceTests/PodcastRepositoryTests.swift`)

- [ ] Test CRUD operations with in-memory ModelContainer
- [ ] Test organization filtering (folders, tags, unorganized)
- [ ] Test concurrent access patterns (actor isolation)
- [ ] Test Siri snapshot persistence
- [ ] Test error handling (database errors, constraint violations)
- [ ] Test migration scenarios (future)

### Integration Tests

- [ ] Test with persistent ModelContainer
- [ ] Test data survives app restart (write, terminate, relaunch)
- [ ] Test integration with FolderManaging for recursive queries
- [ ] Test Siri snapshot accessibility from app group

## Implementation Notes

### Thread Safety

- Use `@ModelActor` for automatic thread-safe access
- All operations run on background context
- UI updates via `@MainActor` in consuming code

### Episode Persistence Strategy

**Decision Required**: Should episodes be persisted in SwiftData or remain transient?

**Option A - Transient Episodes (Current)**:
- Pros: Simpler implementation, matches current model
- Cons: Episodes re-downloaded on each app launch (from feed)

**Option B - Persistent Episodes**:
- Pros: Faster app launch, offline access to episode metadata
- Cons: More complex migrations, increased storage

**Recommendation**: Start with Option A (transient), migrate to Option B in future issue.

### Siri Snapshot Integration

- Preserve existing snapshot format (`SiriPodcastSnapshot`, `SiriEpisodeSnapshot`)
- Maintain compatibility with `zpodIntents` extension
- Continue writing to app group (`group.us.zig.zpod`)

## Known Risks

- **Breaking Change**: Existing in-memory data will be lost during migration (acceptable since nothing persists currently)
- **Performance**: SwiftData queries may be slower than in-memory dictionary lookups (profile and optimize if needed)
- **Migration Complexity**: Future schema changes require careful versioning

## Definition of Done

- [ ] PodcastRepository implementation complete with all protocol methods
- [ ] SwiftData models defined and tested
- [ ] Unit tests passing (>90% code coverage)
- [ ] Integration tests passing
- [ ] Documentation written with code examples
- [ ] Dev-log entry created documenting design decisions
- [ ] Code review approved
- [ ] Merged to main branch

## Time Estimate

- Design & SwiftData models: 2 hours
- Core CRUD implementation: 3 hours
- Organization queries implementation: 2 hours
- Siri snapshot integration: 1 hour
- Unit tests: 3 hours
- Integration tests: 2 hours
- Documentation: 1 hour
- **Total**: ~14 hours

---

**Created**: 2026-01-02
**Blocker**: This blocks Issue 27.1.2 (migration to production)
**Technical Debt**: HIGH - Production app currently using test infrastructure
