# Issue 02.1.6.3: Modular Swipe Configuration Settings

## Description
Refactor the swipe gesture configuration persistence stack to decouple it from the monolithic `SettingsManager` / `UISettings` pipeline. Introduce modular configuration services and repositories so swipe actions—and future UI configurations—can persist, reload, and observe their state without racing global settings initialization. Establish a reusable registration/hosting model so each configurable feature owns its state, editing surface, and validation while the Settings interface focuses on layout and navigation.

## Objectives
- Design a dedicated configuration service abstraction (actor-safe) with pluggable storage backends (UserDefaults-backed, in-memory test double).
- Move swipe gesture settings to that service while keeping compatibility shims for existing consumers.
- Provide async observation/notification hooks so UI surfaces can subscribe to configuration changes rather than polling `SettingsManager`.
- Ensure persistence writes complete synchronously (or expose completion) so relaunches see the saved preset immediately.
- Document the migration path for other UI configuration features.

## Architecture Overview
- Define a `ConfigurableFeature` protocol in `SettingsDomain` that supplies metadata (identifier, display name, icon, navigation destination), async loaders/savers, validation, and a SwiftUI view factory that binds to a provided controller.
- Introduce a `FeatureConfigurationController` base class/struct that encapsulates draft state management, diffing, validation, and persistence orchestration for each feature. Controllers must be `@MainActor` aware while delegating storage to their service.
- Add a `FeatureConfigurationRegistry` owned by the Settings shell that discovers registered features (via dependency injection) and composes the settings list using reusable UI primitives (`SettingsFormSection`, `OptionPicker`, `PresetGrid`).
- Provide a swipe-specific feature module (`SwipeConfigurationFeature`) that registers itself, wraps the new swipe configuration service, and exposes automation-friendly hooks for tests (e.g., `await controller.waitForBaseline()`).
- Ensure the registry and controllers respect strict concurrency rules (actors/sendable types) and remain platform-agnostic for future watchOS/CarPlay integrations.

## Deliverables
1. Shared protocols, controllers, and registry infrastructure in `SettingsDomain` with unit coverage.
2. Refactored swipe configuration flow that consumes the registry + controller pattern, removes UIKit-specific shims, and restores standard SwiftUI interactions.
3. Integration tests verifying `save -> terminate -> relaunch -> load` using the new service; UI tests updated to wait on the controller baseline and interact with native SwiftUI controls.
4. Documentation updates (dev-log entry, inline README) describing how to register new features and migrate existing ones.
5. Migration checklist for dependent settings surfaces.

## Acceptance Criteria
1. `SwipeActionConfigurationViewModel` and `EpisodeListViewModel` rely on the new swipe configuration service for load/save/observations, no longer reading `SettingsManager.globalUISettings` directly.
2. The new service persists presets across relaunches deterministically (integration test proves save → relaunch → load returns latest config) and exposes completion signals awaited by the UI.
3. The Settings screen loads swipe configuration via the registry/controller pattern and renders using standard SwiftUI controls (no UIKit representables) while passing updated UITests.
4. Legacy `SettingsManager.updateGlobalUISettings` pathways continue to function during migration by delegating to the new service, with deprecation guidance captured in documentation.
5. Documentation (dev-log, SettingsDomain README snippet) describes how to register additional features and references follow-up issues for each adoption. CI passes with refreshed unit/integration/UI tests.

## Dependencies
- Completion of Issue 02.1.6.2 debugging so current swipe UI automation reflects the desired behaviour before refactor.
- Awareness of Issue 02.1.6.1 settings architecture changes (to avoid regressions).

## Spec References
- `Issues/02.1-episode-list-management-ui.md` – Scenario 6: Swipe gestures & quick actions.
- `zpod/spec/ui.md` – Customizing swipe gestures.
- `Issues/12.7-ui-test-reliability-ci-hardening.md` – Async wait expectations for UI tests.

## Testing Strategy
- Unit tests for the new configuration service (load, save, observation, failure handling).
- Integration tests exercising the storage backend (UserDefaults) and verifying deterministic persistence through app relaunch simulation.
- UI automation update: ensure configuration screens wait on service hydration and observe live updates.
- Regression pass on SettingsDomain tests to confirm legacy pathways remain intact during migration.

## Follow-up Migration Prompts
- **Smart List Background Automation** (`SmartListBackgroundSettingsView`, `DefaultSmartListBackgroundManager`): Create an issue to wrap the smart-list refresh configuration inside the registry/controller model, ensure toggles/sliders use shared settings components, and migrate persistence hooks to the modular service pattern.
- **Playback Preferences** (`PlaybackSettings`, playback settings UI stubs in App/LibraryFeature): Spin up an issue to surface playback speed/skip controls through a dedicated `PlaybackConfigurationFeature`, including validation and async observation of player defaults.
- **Download Policies** (`DownloadSettings`, retention policies, feed refresh cadence): Author an issue to modularize the download settings editor, enforce retention validation via controllers, and add integration tests covering per-podcast overrides.
- **Theme & Accessibility Toggles** (Issue 05.1 scope): Draft an issue to onboard appearance/accessibility switches into the registry, ensuring consistent layout and future cross-device sync.
- **Future Features Registry Onboarding**: Document in the dev log that any new settings feature must register through the `FeatureConfigurationRegistry` and supply controller + storage implementations before UI work begins.
