# Issue 27.1.1.3: Optional API Polish

## Priority
Low (Optional - Defer Unless Needed)

## Status
â³ Pending (Blocked by 27.1.1.2)

## Description
**Optional enhancement**: Add protocol-level helpers for episode-specific operations if direct repository access proves insufficient after episode persistence and sync are complete.

**Decision Point**: Only pursue this if there's a clear need after 27.1.1.2 ships. Changing `PodcastManaging` protocol affects `CoreModels`, `TestSupport`, and all consumers - avoid unless necessary.

## Acceptance Criteria
- [ ] Evaluate need after 27.1.1.2 is complete
- [ ] If needed: Add `findEpisode(id:)` to `PodcastManaging` protocol
- [ ] If needed: Add `updateEpisode(_:)` to `PodcastManaging` protocol
- [ ] Update all conforming types (`InMemoryPodcastManager`, `SwiftDataPodcastRepository`)
- [ ] Update test mocks and stubs
- [ ] All tests passing

## Implementation Approach (If Pursued)

### Potential API Additions

```swift
// In CoreModels/PodcastManaging.swift
public protocol PodcastManaging: Sendable {
    // ... existing methods ...

    /// Find a specific episode by ID across all podcasts
    func findEpisode(id: String) -> Episode?

    /// Update a single episode (e.g., playback position)
    func updateEpisode(_ episode: Episode)
}
```

### Implementation in SwiftDataPodcastRepository

```swift
public func findEpisode(id: String) -> Episode? {
    serialQueue.sync {
        let descriptor = FetchDescriptor<EpisodeEntity>(
            predicate: #Predicate { $0.id == id }
        )
        guard let entity = try? modelContext.fetch(descriptor).first else {
            return nil
        }
        return entity.toDomain()
    }
}

public func updateEpisode(_ episode: Episode) {
    let didSave = serialQueue.sync { () -> Bool in
        let descriptor = FetchDescriptor<EpisodeEntity>(
            predicate: #Predicate { $0.id == episode.id }
        )
        guard let entity = try? modelContext.fetch(descriptor).first else {
            return false
        }

        entity.updateFrom(episode)
        return saveContext()
    }
    if didSave { refreshSiriSnapshotsIfNeeded() }
}
```

### Alternative: Direct Repository Access

Most use cases can access episodes without protocol changes:

```swift
// Get all episodes across all podcasts
let allEpisodes = podcastManager.all().flatMap(\.episodes)

// Find episode by ID (manual search)
let episode = podcastManager.all()
    .flatMap(\.episodes)
    .first { $0.id == targetId }

// Update episode (via podcast update)
if var podcast = podcastManager.find(id: podcastId) {
    podcast.episodes = podcast.episodes.map { episode in
        episode.id == targetId ? updatedEpisode : episode
    }
    podcastManager.update(podcast)
}
```

## Decision Criteria

**Pursue this issue if:**
- Multiple call sites need episode-specific operations
- Performance suffers from scanning all episodes
- API consumers struggle with manual episode searches

**Skip this issue if:**
- Direct repository access is sufficient
- Few call sites need episode operations
- Protocol changes create more complexity than value

## Known Limitations
- Protocol changes affect all consumers (breaking API change)
- Requires updates to test mocks and stubs
- May complicate future persistence refactoring
- **Carry-over maintenance items (from 27.1.1.1 review):**
  - Test helpers are duplicated: `makeEpisode` in `Packages/Persistence/Tests/PersistenceTests/EpisodeEntityTests.swift` and `SwiftDataPodcastRepositoryTests.swift`, plus `makePodcast` in the repository tests overlap with `Packages/TestSupport/Sources/TestSupport/Mocks.swift`. Consolidate into TestSupport to keep defaults in sync with model changes.
  - No regression coverage ensures repository-backed episodes flow through consumers. Add focused tests for `EpisodeIndexSource.documents()` (search indexing) and the CarPlay `episodeLookup` closure (Packages/LibraryFeature/Sources/LibraryFeature/CarPlayDependencies.swift) once protocol/API decisions are made.

## Specification References
- `dev-log/27.1-podcast-persistence-foundation.md` - API design context

## Dependencies
- **Blocked by**: Issue 27.1.1.2 (evaluate need after sync is complete)
- **Blocks**: None

## Estimated Effort
2-3 hours (if pursued)

## Success Metrics
- API is simpler and more intuitive (if added)
- No performance regressions
- All consumers updated successfully

## Testing Strategy

### Unit Tests (If Pursued)
```bash
./scripts/run-xcode-tests.sh -t PersistenceTests
./scripts/run-xcode-tests.sh -t CoreModelsTests  # If protocol changed
```

### Full Regression
```bash
./scripts/run-xcode-tests.sh
```

## Related Issues
- Issue 27.1.1.2 - Episode Sync (prerequisite - evaluate need after completion)
- Issue 27.1 - Podcast Persistence Foundation (parent)
