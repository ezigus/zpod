# Issue 02.8: SwiftUI Lazy List Testing Patterns (Scroll-On-Demand Architecture)

## Priority
High - Improves test reliability and performance

## Status
ðŸ”„ Planned

## Description
Replace the current pre-materialization approach with industry-standard "scroll-on-demand" pattern for testing SwiftUI lazy Lists. This architectural improvement will eliminate test flakiness caused by SwiftUI's lazy unmaterialization while making tests faster and more maintainable.

## Problem Statement
The current testing approach pre-scrolls through entire sheets to materialize all sections, then scrolls back to top, hoping elements stay materialized. This has several issues:

1. **Fights SwiftUI's Design:** SwiftUI List uses lazy loading by design (Xcode 14+). Pre-materialization fights this instead of working with it.
2. **Non-Deterministic Failures:** Elements unmaterialize unpredictably (20% failure rate), requiring timeout increases to mask the underlying issue.
3. **Slower Tests:** Every test pays the cost of pre-scrolling, even when elements are already visible.
4. **Not Industry Standard:** Research shows the recommended pattern is "scroll when you need it, not before."

**Current Results:**
- Baseline: 33% pass rate (before fixes)
- With fixes + timeout increase: 80-95% pass rate
- Test duration: 55-58 seconds per test

**Expected Results with Scroll-On-Demand:**
- Pass rate: 95-100%
- Test duration: 40-50 seconds per test (10-15% faster)
- More maintainable and predictable

## Research Foundation

### Industry Best Practices
Based on comprehensive research of XCUITest + SwiftUI lazy loading patterns:

**Xcode 14+ Behavior Change:**
> "In Xcode 14, off-screen elements are NOT visible to the UITest process by default and will cause a test failure if an interaction is attempted. This is more in line with how Lazy Stacks worked in SwiftUI for Xcode 13."

**Recommended Pattern:**
> "Create a custom, configurable, swiping method that searches for your target element until it is found. The reason to create a custom swipe function as opposed to using the default forces you to hard code a set number of swipes."

### Sources
- [Testing UI Elements in SwiftUI with XCTest: Challenges and Solutions](https://medium.com/@paulmax_iOS_Dev/testing-ui-elements-in-swiftui-with-xctest-challenges-and-solutions-c09269238152)
- [Extracting Lazily Loaded Elements for UI Testing in a SwiftUI iOS App](https://betterprogramming.pub/ios-extracting-lazily-loaded-elements-for-ui-testing-5541ea190586)
- [How to Scroll to Element in XCUITest | BrowserStack](https://www.browserstack.com/guide/scroll-to-element-in-xcuitest)
- [Scrolling - XCUITest Guide](https://ashraf-ali-aa.github.io/XCUITest-Guide/docs/xcuitest/scrolling/)
- [Mastering Scroll to Element in XCUITest](https://33rdsquare.com/browser/browser-testing/mastering-scroll-to-element-in-xcuitest-an-in-depth-guide-for-ios-app-test-automation/)

## Acceptance Criteria

### Core Infrastructure
- [ ] Implement `scrollToElement()` helper that scrolls incrementally until element found
- [ ] Add `waitForExistence()` first (check if element already visible before scrolling)
- [ ] Include max scroll attempts to prevent infinite loops (default: 10)
- [ ] Support both upward and downward scrolling directions
- [ ] Provide clear error messages when element not found after max scrolls

### Remove Pre-Materialization
- [ ] Remove `materializeSections()` function from SwipeActionConfigurationView.swift
- [ ] Remove related materialization code (scrollTo calls, materializationComplete flag)
- [ ] Clean up UI code that was added solely for test pre-materialization
- [ ] Verify sheet still opens at top naturally (no test-specific scroll behavior)

### Update Test Helpers
- [ ] Replace `ensureVisibleInSheet()` with new scroll-on-demand helper
- [ ] Update `applyPreset()` to use scroll-on-demand pattern
- [ ] Update `removeAction()` and `addAction()` to use scroll-on-demand pattern
- [ ] Remove scroll attempt parameters (no longer needed)
- [ ] Simplify test setup (no waiting for materialization)

### Validation
- [ ] Run full SwipeConfiguration test suite 10 times (target: 10/10 pass)
- [ ] Measure performance improvement (expected: 10-15% faster)
- [ ] Verify all 18 SwipeConfiguration tests pass consistently
- [ ] Run on CI to validate stability in resource-constrained environment
- [ ] Compare failure rate before/after (target: <5% failure rate)

## Implementation Approach

### Phase 1: Core Helper Implementation (1-2 hours)

**File:** `zpodUITests/UITestHelpers.swift` (add new extension)

```swift
extension XCTestCase {
  /// Scrolls container until element is found or max attempts reached
  ///
  /// Industry-standard pattern for lazy-loaded SwiftUI Lists:
  /// 1. Wait first to see if element already visible (avoid unnecessary scrolling)
  /// 2. Scroll incrementally until found
  /// 3. Stop at max attempts to prevent infinite loops
  ///
  /// - Parameters:
  ///   - identifier: Accessibility identifier of target element
  ///   - container: Scrollable container (sheet, list, etc.)
  ///   - direction: Scroll direction (.up or .down)
  ///   - maxScrolls: Maximum scroll attempts (default: 10)
  ///   - waitTimeout: Timeout for initial existence check (default: 2s)
  /// - Returns: Element if found, nil otherwise
  @MainActor
  func scrollToElement(
    _ identifier: String,
    in container: XCUIElement,
    direction: ScrollDirection = .down,
    maxScrolls: Int = 10,
    waitTimeout: TimeInterval = 2.0
  ) -> XCUIElement? {
    let element = container.descendants(matching: .any)[identifier]

    // OPTIMIZATION: Check if element already visible (avoids scrolling in 70%+ of cases)
    if element.waitForExistence(timeout: waitTimeout) {
      logger.debug("[ScrollOnDemand] Element \(identifier) found without scrolling")
      return element
    }

    // Scroll incrementally until found
    logger.debug("[ScrollOnDemand] Scrolling to find \(identifier), max attempts: \(maxScrolls)")
    for attempt in 1...maxScrolls {
      switch direction {
      case .down:
        container.swipeUp()
      case .up:
        container.swipeDown()
      }

      // Brief wait for SwiftUI to materialize after scroll
      // Use shorter timeout (0.5s) since we're in a loop
      if element.waitForExistence(timeout: 0.5) {
        logger.debug("[ScrollOnDemand] Element \(identifier) found after \(attempt) scrolls")
        return element
      }
    }

    logger.warning("[ScrollOnDemand] Element \(identifier) not found after \(maxScrolls) scrolls")
    return nil
  }

  enum ScrollDirection {
    case up, down
  }
}
```

### Phase 2: Remove Pre-Materialization (30 minutes)

**File:** `Packages/LibraryFeature/Sources/LibraryFeature/SwipeActionConfigurationView.swift`

**Changes:**
1. Remove `materializeSections()` function (lines 171-193)
2. Remove `materializationComplete` state variable
3. Remove `.task { await materializeSections() }` call
4. Remove `"swipe-top"`, `"swipe-trailing"` scroll markers (if only used for materialization)

**Result:** UI code becomes simpler, no test-specific logic

### Phase 3: Update Test Helpers (1 hour)

**File:** `zpodUITests/SwipeConfigurationTestSupport+ActionManagement.swift`

**Update `applyPreset()`:**
```swift
@MainActor
func applyPreset(identifier: String) {
  guard let container = swipeActionsSheetListContainer() else {
    XCTFail("Swipe configuration sheet not found")
    return
  }

  // Scroll to preset button using scroll-on-demand pattern
  guard let presetButton = scrollToElement(identifier, in: container, direction: .down) else {
    XCTFail("Preset button \(identifier) not found after scrolling")
    return
  }

  tapElement(presetButton, description: identifier)
}
```

**Update `removeAction()`:**
```swift
@MainActor
@discardableResult
func removeAction(_ displayName: String, edgeIdentifier: String) -> Bool {
  guard let container = swipeActionsSheetListContainer() else { return false }
  let rowIdentifier = "SwipeActions.\(edgeIdentifier).\(displayName)"

  // Scroll to action row (usually near top, so likely already visible)
  guard let _ = scrollToElement(rowIdentifier, in: container, direction: .up) else {
    return false
  }

  let removeButton = app.buttons["Remove \(displayName)"].firstMatch
  guard removeButton.waitForExistence(timeout: postReadinessTimeout) else {
    return false
  }
  removeButton.tap()
  return true
}
```

**Update `addAction()`:**
```swift
@MainActor
@discardableResult
func addAction(_ displayName: String, edgeIdentifier: String) -> Bool {
  guard let container = swipeActionsSheetListContainer() else { return false }

  let addIdentifier = "SwipeActions.Add.\(edgeIdentifier)"

  // Scroll to "Add" button (usually near top, so likely already visible)
  guard let addMenu = scrollToElement(addIdentifier, in: container, direction: .up) else {
    return false
  }

  addMenu.tap()

  // Wait for picker to appear
  let pickerTitle = edgeIdentifier == "Leading"
    ? "Add Leading Action"
    : "Add Trailing Action"
  let pickerNavBar = app.navigationBars[pickerTitle].firstMatch
  _ = pickerNavBar.waitForExistence(timeout: adaptiveTimeout)

  // Find option in picker (may need to scroll)
  let optionIdentifier = "\(addIdentifier).\(displayName)"
  if let option = scrollToElement(optionIdentifier, in: container, direction: .down) {
    tapElement(option, description: "Add action option \(displayName)")
    _ = waitForElementToDisappear(pickerNavBar, timeout: postReadinessTimeout)
    return true
  }

  return false
}
```

**File:** `zpodUITests/SwipeConfigurationTestSupport+SheetUtilities.swift`

**Remove or simplify:**
- `ensureVisibleInSheet()` - Replace with `scrollToElement()` or remove entirely
- Remove `scrollAttempts` parameter from all function signatures
- Simplify `swipeActionsSheetListContainer()` - Remove materialization wait logic

### Phase 4: Update Tests (30 minutes)

**Files:**
- `zpodUITests/SwipePresetSelectionTests.swift`
- `zpodUITests/SwipeActionManagementTests.swift`
- `zpodUITests/SwipeToggleInteractionTests.swift`
- Other SwipeConfiguration test files

**Changes:**
1. Remove `materializationComplete` wait logic from test setup
2. Remove `scrollAttempts` parameters from helper calls
3. Simplify test code (helpers now handle scrolling internally)
4. Update comments to reflect new scroll-on-demand approach

### Phase 5: Validation (1 hour)

**Local Testing:**
```bash
# Run each test suite 10 times to validate consistency
for i in {1..10}; do
  echo "Run $i"
  ./scripts/run-xcode-tests.sh -t SwipePresetSelectionTests
done

for i in {1..10}; do
  echo "Run $i"
  ./scripts/run-xcode-tests.sh -t SwipeActionManagementTests
done

# Full regression
./scripts/run-xcode-tests.sh -t SwipeConfigurationUIDisplayTests
./scripts/run-xcode-tests.sh -t SwipeToggleInteractionTests
./scripts/run-xcode-tests.sh -t SwipeConfigurationPersistenceTests
./scripts/run-xcode-tests.sh -t SwipeExecutionTests
```

**Performance Measurement:**
- Record average test duration before/after
- Expected improvement: 10-15% faster (55s â†’ 47s per test)
- Measure on both local and CI

## Files to Modify

### UI Code (Remove Test-Specific Logic)
- `Packages/LibraryFeature/Sources/LibraryFeature/SwipeActionConfigurationView.swift`
  - Remove `materializeSections()` function
  - Remove materialization state and markers

### Test Infrastructure (New Pattern)
- `zpodUITests/UITestHelpers.swift`
  - Add `scrollToElement()` helper

### Test Support Files (Simplify)
- `zpodUITests/SwipeConfigurationTestSupport+ActionManagement.swift`
  - Update `applyPreset()`, `removeAction()`, `addAction()`
- `zpodUITests/SwipeConfigurationTestSupport+SheetUtilities.swift`
  - Simplify or remove `ensureVisibleInSheet()`
  - Remove scroll attempt parameters

### Test Files (Cleanup)
- `zpodUITests/SwipePresetSelectionTests.swift`
- `zpodUITests/SwipeActionManagementTests.swift`
- `zpodUITests/SwipeToggleInteractionTests.swift`
- Other SwipeConfiguration test files

## Dependencies
- Issue 12.2: Testing Framework Refactoring (provides base patterns)
- Replaces current pre-materialization approach in SwipeConfiguration tests

## Success Metrics

### Reliability
- **Target:** 95-100% pass rate (up from current 80%)
- **Measure:** Run each test suite 20 times locally + CI
- **Comparison:** Before (80%) vs After (95-100%)

### Performance
- **Target:** 10-15% faster test execution
- **Measure:** Average test duration across 10 runs
- **Comparison:** Before (55-58s) vs After (47-50s)

### Code Quality
- **Target:** Simpler, more maintainable code
- **Measure:**
  - Lines of code removed from UI (materialization logic)
  - Lines of code removed from tests (scroll attempt parameters)
  - Complexity reduction in test helpers

### Industry Alignment
- **Target:** Match industry best practices
- **Measure:** Code review confirms scroll-on-demand pattern matches research sources

## Estimated Effort
Medium - 3-4 hours total
- Phase 1: 1-2 hours (core helper)
- Phase 2: 30 minutes (remove UI code)
- Phase 3: 1 hour (update test helpers)
- Phase 4: 30 minutes (update tests)
- Phase 5: 1 hour (validation)

## Risk Analysis

### Risk 1: Tests break during migration
**Likelihood:** Medium
**Impact:** Medium
**Mitigation:**
- Implement in feature branch
- Test incrementally (one test suite at a time)
- Keep old helpers temporarily for fallback
- Run full regression before merging

### Risk 2: Scroll-on-demand is slower than expected
**Likelihood:** Low
**Impact:** Low
**Mitigation:**
- Benchmark before/after
- Optimize scroll attempts if needed
- Most elements already visible (no scrolling needed)

### Risk 3: New pattern introduces different flakiness
**Likelihood:** Very Low
**Impact:** Medium
**Mitigation:**
- Pattern is industry-proven (not experimental)
- 10-run validation catches early issues
- CI testing validates in resource-constrained env

## Notes
- This is the industry-standard approach based on comprehensive research
- Eliminates root cause of flakiness rather than masking with timeouts
- Makes UI code simpler by removing test-specific logic
- Provides foundation for testing other lazy-loaded SwiftUI Lists in the app
