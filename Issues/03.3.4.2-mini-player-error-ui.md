# Issue 03.3.4.2: Add Error State UI to Mini-Player

**Status**: ðŸ†• Proposed

**Priority**: High

**Parent**: 03.3.4 - Unplayable Episode UX & Diagnostics (#269)

**Estimated Effort**: 1.5 hours

## Description

Add error state display to the mini-player when playback fails. Show error icon, message, and retry button (for recoverable errors).

## Problem Statement

**Current State**:
- Mini-player shows play/pause button and progress
- When playback fails (`.failed` state), mini-player shows nothing useful
- User has no indication why audio won't play

**Target State**:
- Mini-player shows error indicator when in `.failed` state
- Error message is concise and user-friendly
- Retry button appears for recoverable errors
- Error clears when new episode selected

## Technical Design

### Step 1: Expose Error State in ViewModel (Critical Prerequisite)

**Problem**: The current `MiniPlayerViewModel` does not expose the raw `EpisodePlaybackState` or error info to views. The ViewModel only exposes `displayState: MiniPlayerDisplayState`, which doesn't include the `PlaybackError`.

**Solution**: Add error field to `MiniPlayerDisplayState`:

```swift
// Packages/PlayerFeature/Sources/PlayerFeature/MiniPlayerViewModel.swift

public struct MiniPlayerDisplayState: Equatable, Sendable {
  public static let hidden = MiniPlayerDisplayState(
    isVisible: false,
    isPlaying: false,
    episode: nil,
    currentPosition: 0,
    duration: 0,
    error: nil  // NEW
  )

  public var isVisible: Bool
  public var isPlaying: Bool
  public var episode: Episode?
  public var currentPosition: TimeInterval
  public var duration: TimeInterval
  public var error: PlaybackError?  // NEW: expose error to view

  public init(
    isVisible: Bool,
    isPlaying: Bool,
    episode: Episode?,
    currentPosition: TimeInterval,
    duration: TimeInterval,
    error: PlaybackError? = nil  // NEW: default nil for non-error states
  ) {
    self.isVisible = isVisible
    self.isPlaying = isPlaying
    self.episode = episode
    self.currentPosition = currentPosition
    self.duration = duration
    self.error = error
  }
}

// Update handlePlaybackStateChange to pass error through:
case .failed(let episode, let position, let duration, let error):
  displayState = MiniPlayerDisplayState(
    isVisible: true,
    isPlaying: false,
    episode: episode,
    currentPosition: position,
    duration: duration,
    error: error  // NEW: pass error to display state
  )
```

### Step 2: Mini-Player Error Overlay

```swift
// Packages/PlayerFeature/Sources/PlayerFeature/MiniPlayerView.swift

@ViewBuilder
private var errorOverlay: some View {
  if let error = viewModel.displayState.error {
    HStack(spacing: 8) {
      Image(systemName: "exclamationmark.triangle.fill")
        .foregroundColor(.red)
        .accessibilityLabel("Error")
      
      Text(error.userMessage)
        .font(.caption)
        .foregroundColor(.secondary)
        .lineLimit(1)
      
      if error.isRecoverable {
        Button {
          viewModel.retryPlayback()
        } label: {
          Text("Retry")
            .font(.caption.bold())
        }
        .buttonStyle(.bordered)
        .accessibilityIdentifier("MiniPlayer.RetryButton")
      }
    }
    .padding(.horizontal, 12)
    .padding(.vertical, 8)
    .background(Color(.systemBackground))
    .accessibilityElement(children: .combine)
    .accessibilityIdentifier("MiniPlayer.ErrorOverlay")
  }
}
```

### Step 3: Integration into Mini-Player Layout

```swift
// Update MiniPlayerView body to include error overlay
var body: some View {
  VStack(spacing: 0) {
    if viewModel.displayState.error != nil {
      errorOverlay
    } else {
      // Existing playback controls
      normalControls
    }
  }
}
```

### Step 4: ViewModel Retry Logic

```swift
// Packages/PlayerFeature/Sources/PlayerFeature/MiniPlayerViewModel.swift

@MainActor
func retryPlayback() {
  // Use displayState which now contains error info
  guard displayState.error != nil,
        let episode = displayState.episode else { return }

  let position = displayState.currentPosition

  // Clear error and attempt playback again
  playbackService.play(episode, from: position)
}
```

## Acceptance Criteria

### ViewModel Changes
- [ ] `MiniPlayerDisplayState` struct has new `error: PlaybackError?` field
- [ ] `handlePlaybackStateChange(.failed)` passes error to `displayState`
- [ ] Non-error states set `error: nil` in `displayState`
- [ ] `retryPlayback()` method added to `MiniPlayerViewModel`

### View Changes
- [ ] Error overlay appears in mini-player when `displayState.error != nil`
- [ ] Error icon (exclamation triangle) is visible
- [ ] Error message uses `PlaybackError.userMessage`
- [ ] Retry button appears only for `isRecoverable` errors
- [ ] Retry button triggers `retryPlayback()` in viewmodel
- [ ] Error overlay has accessibility identifier `MiniPlayer.ErrorOverlay`
- [ ] Retry button has accessibility identifier `MiniPlayer.RetryButton`
- [ ] VoiceOver reads error state appropriately
- [ ] Error clears when new episode starts playing (error becomes nil)

## Files to Modify

| File | Changes |
|------|---------|
| `Packages/PlayerFeature/Sources/PlayerFeature/MiniPlayerViewModel.swift` | Add `error` field to `MiniPlayerDisplayState`, update `.failed` case handler, add `retryPlayback()` (+25 lines) |
| `Packages/PlayerFeature/Sources/PlayerFeature/MiniPlayerView.swift` | Add `errorOverlay` view, update body to show overlay when error present (+30 lines) |

## Testing Strategy

### Manual Testing

1. Launch app with missing audio URL episode
2. Tap play on episode
3. Verify mini-player shows:
   - Red exclamation icon
   - "This episode doesn't have audio available"
   - No retry button (not recoverable)

4. Simulate network error (airplane mode or invalid URL)
5. Tap play
6. Verify mini-player shows:
   - Red exclamation icon
   - "Unable to load episode. Check your connection."
   - Retry button

7. Tap retry button
8. Verify playback attempt is made again

### UI Tests (add to zpodUITests)

```swift
// Will be enabled after 03.3.4 completes
func testMiniPlayerShowsErrorForMissingURL() {
  // Launch with episode that has nil audioURL
  // Tap play
  // Verify error overlay exists
  let errorOverlay = app.otherElements["MiniPlayer.ErrorOverlay"]
  XCTAssertTrue(errorOverlay.waitForExistence(timeout: 5))
  
  // Verify no retry button (not recoverable)
  let retryButton = app.buttons["MiniPlayer.RetryButton"]
  XCTAssertFalse(retryButton.exists)
}

func testMiniPlayerShowsRetryForNetworkError() {
  // Launch with episode that will fail network load
  // Tap play
  // Verify error overlay with retry button
  let retryButton = app.buttons["MiniPlayer.RetryButton"]
  XCTAssertTrue(retryButton.waitForExistence(timeout: 5))
  
  // Tap retry
  retryButton.tap()
  
  // Verify retry was attempted (check for loading state or new error)
}
```

## Dependencies

- **Requires**: 03.3.4.1 (PlaybackError enum extension) - must be complete first
- **Unblocks**: 03.3.2.7 test `testMissingAudioURLShowsErrorNoRetry`
- **Unblocks**: 03.3.2.7 test `testNetworkErrorShowsRetryAndRecovers`

## Design Notes

### Layout Considerations

- **Compact**: Mini-player has limited vertical space
- **Priority**: Error message more important than episode title when failed
- **Truncation**: Use `.lineLimit(1)` on error message to prevent overflow

### Accessibility

- Error overlay combines icon + message + button into single announcement
- VoiceOver reads: "Error: [message]. [Retry button if present]"
- Retry button clearly labeled for screen reader users
- Confirm view model transitions back to normal playback state (clearing the `.failed` overlay) whenever `playbackService` reports a new episode so VoiceOver focus moves back to the regular mini-player controls.

## Related Issues

- **03.3.2.7** - AVPlayer edge-case tests (currently skipped, waiting for this UI)
- **03.3.4.3** - Expanded player error UI (parallel work, same pattern)
