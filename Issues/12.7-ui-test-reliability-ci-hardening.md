# Issue 12.7: UI Test Reliability & CI Resilience

## Priority
High

## Status
✅ Completed

## Description
Stabilize the UI regression suite on GitHub Actions by trimming oversized scenarios, scaling helper timeouts for hosted simulators, and improving diagnostics when waits expire. The goal is to eliminate recurring UI timeouts while preserving coverage mapped to `spec/ui.md`.

## Problem Statement
UI tests running on GitHub Actions hosted runners experience intermittent timeouts due to:
- Fixed timeout values that don't account for slower hosted simulator performance
- Insufficient diagnostic information when waits expire (no accessibility tree dump)
- Oversized test scenarios that navigate through multiple transitions in a single test
- Late prerequisite checks that waste CI time when features are unimplemented

## Key Actions
1. Add a `UITEST_TIMEOUT_SCALE` (or equivalent) environment override that adjusts `adaptiveTimeout` and `adaptiveShortTimeout`, defaulting CI runs to ≥ 1.5.
2. Emit detailed diagnostics (including `app.debugDescription`) from `waitForAnyElement`, `waitForLoadingToComplete`, and related helpers when they time out under CI.
3. Split or refactor long-running tests (e.g., `ContentDiscoveryUITests` acceptance flow, multi-select scenarios in `BatchOperationUITests`) so each case focuses on a single transition and exits early if prerequisites are missing.
4. Centralize app launch/navigation helpers and move `XCTSkip` checks ahead of deep navigation to reduce wasted runtime.
5. Shard `zpod.xctestplan` (or add complementary plans) so UI suites can run as smaller groups on Actions, with workflow updates to execute shards and archive per-shard logs.
6. Update `dev-log/` and `zpodUITests/TestSummary.md` to document the new strategy and any remaining edge cases.

## Acceptance Criteria

### Scenario 1: Timeout Scaling Available
- **Given** the UI test suite is running
- **When** the `UITEST_TIMEOUT_SCALE` environment variable is set
- **Then** `adaptiveTimeout` and `adaptiveShortTimeout` are multiplied by the scale factor
- **And** the scale factor defaults to 1.0 locally and ≥ 1.5 in CI

### Scenario 2: Enhanced Timeout Diagnostics
- **Given** a UI test helper timeout occurs
- **When** the helper function fails
- **Then** the failure message includes `app.debugDescription` showing the accessibility tree
- **And** the diagnostics help identify why the expected element did not appear

### Scenario 3: Decomposed Test Scenarios
- **Given** UI test files with oversized scenarios
- **When** tests are refactored
- **Then** each test case focuses on a single navigation transition
- **And** prerequisites are checked early with `XCTSkip` to avoid wasted runtime

### Scenario 4: CI Workflow Updated
- **Given** the GitHub Actions CI workflow
- **When** UI tests are executed
- **Then** the `UITEST_TIMEOUT_SCALE` environment variable is set appropriately
- **And** test artifacts are archived for debugging

### Scenario 5: Documentation Updated
- **Given** the implementation is complete
- **When** reviewing documentation
- **Then** `dev-log/` includes an entry documenting the changes
- **And** `zpodUITests/TestSummary.md` reflects the new execution pattern and flags

## Implementation Approach

### Phase 1: Timeout Scaling Infrastructure
1. Add `UITEST_TIMEOUT_SCALE` environment variable support to `UITestHelpers.swift`
2. Update `adaptiveTimeout` and `adaptiveShortTimeout` to honor the scale factor
3. Update CI workflow to set the environment variable

### Phase 2: Enhanced Diagnostics
1. Update `waitForAnyElement` to emit `app.debugDescription` on timeout
2. Update `waitForLoadingToComplete` to emit `app.debugDescription` on timeout
3. Update `waitForElement` to emit `app.debugDescription` on timeout
4. Update other relevant helper functions

### Phase 3: Test Decomposition (Optional - Only if Needed)
1. Review `ContentDiscoveryUITests` for oversized scenarios
2. Review `BatchOperationUITests` for oversized scenarios
3. Split tests as needed to focus on single transitions
4. Add early `XCTSkip` checks for prerequisites

### Phase 4: Documentation
1. Create dev-log entry documenting changes
2. Update `zpodUITests/TestSummary.md` with new patterns
3. Document any remaining edge cases or follow-up items

## Specification References
- `spec/ui.md` - All UI testing scenarios should continue to map to specification sections
- Related: Issue 12.2 (Testing Framework Refactoring)
- Related: Issue 12.4 (Performance Testing Patterns)
- Related: Issue 12.6 (Cross-Platform Testing Support)

## Dependencies
- Existing UI test infrastructure (`zpodUITests/UITestHelpers.swift`)
- GitHub Actions CI workflow (`.github/workflows/ci.yml`)
- Test plan configuration (`zpod.xctestplan`)

## Testing Strategy
1. Verify timeout scaling works locally by setting `UITEST_TIMEOUT_SCALE`
2. Verify enhanced diagnostics appear in test failure messages
3. Run tests both locally and in CI to ensure compatibility
4. Verify decomposed tests (if any) maintain coverage

## Success Metrics
1. Timeout scaling flag available and honored locally and in CI
2. Helper timeouts emit accessibility tree diagnostics on failure
3. Oversized tests are decomposed or guarded appropriately
4. Documentation reflects the new execution pattern

## Notes
- Start with minimal changes: timeout scaling and diagnostics
- Test decomposition and sharding are optional and should only be done if current tests show reliability issues
- Focus on infrastructure improvements that benefit all UI tests

## Implementation Notes (2025-09-30)
- **Completed**: Timeout scaling and enhanced diagnostics implemented successfully
- **Test Decomposition**: After review, determined current tests are appropriately structured and do not require decomposition
- **Test Structure**: Current tests focus on single user flows; apparent "size" comes from robust element discovery patterns (multiple strategies for finding elements)
- **Early Exits**: Tests already use XCTSkip and guard statements appropriately to exit early when prerequisites are missing
- **CI Configuration**: Workflow updated to use UITEST_TIMEOUT_SCALE=1.5 by default, providing 50% longer timeouts on hosted runners
