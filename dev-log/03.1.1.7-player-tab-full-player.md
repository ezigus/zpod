# Dev Log: Issue 03.1.1.7 – Player Tab Full Player

## 2026-01-01 16:20 ET – Intent & Design Notes

**Intent**: Replace the Player tab’s simplified player UI with the full player interface so there is a single, consistent player surface in the app.

**Design Notes**:
- Player tab embeds `ExpandedPlayerView` instead of a placeholder player.
- Full player remains accessible from the mini-player via sheet presentation.
- Use the shared playback service so state is consistent across mini and full player.
- Show a neutral empty state when no episode is active.
- Consider hiding the drag indicator when embedded in the tab.

**Diagram: Player Surface Routing**

```mermaid
flowchart LR
  A[Mini-Player Expanded] --> B[Full Player Sheet]
  C[Player Tab] --> D[ExpandedPlayerView (embedded)]
  B --> E[Shared Playback State]
  D --> E[Shared Playback State]
```

## 2026-01-12 10:29 ET – Refactor Blueprint

**Intent**: Align the Player tab’s sample playback flow with the Library quick-play architecture so the mini player and EpisodeDetailView observe the same `EnhancedEpisodePlayer` instance and logging pipeline.

**Spec links**:
- `zpod/spec/playback.md` → *Starting Episode Playback* scenario ensures tapping Play begins audio and updates the Now Playing state.
- `zpod/spec/playback.md` → *Pausing Playback* / *Resuming Playback* guard rail the expected behaviour for transport controls the mini player asserts.

**Plan**:
- Add a `PlayerTabController` beside the other Library playback helpers that resolves the UITest sample episode once, persists `/tmp/zpod-uitest-debug` metadata, and delegates to `PlaybackEnvironment.playbackService` so all UI surfaces observe the same state stream.
- Require callers to inject an `EpisodeDetailViewModel` and provide opt-in transport handlers so EpisodeDetailView just binds to the view model while the controller logs `playSampleEpisode()` / `pause()` requests.
- Rewrite `PlayerTabView` to build the controller during init, reuse its single `EpisodeDetailViewModel`, and feed both EpisodeDetailView + the embedded mini player with the shared playback state so UI tests no longer race separate `EnhancedEpisodePlayer` instances.

```mermaid
flowchart TD
  subgraph LibraryFeature
    PTV[PlayerTabView]
    PTC[PlayerTabController]
  end
  subgraph PlayerFeature
    EDVM[EpisodeDetailViewModel]
    EDV[EpisodeDetailView]
    MPVM[MiniPlayerViewModel]
  end
  PTV --> PTC ---|handlers + sample episode|--> EDVM --> EDV
  PTC -.shared service.- MPVM
  PTC -->|play/pause/skip| PlaybackService[(PlaybackEnvironment.playbackService)]
```

## 2026-01-12 17:55 ET – Diagnostics & Next Steps

**Summary**
- Implemented `PlayerTabController` + injected `EpisodeDetailViewModel` so the Player tab, mini player, and shared `EnhancedEpisodePlayer` all observe/drive the same actor-bound service. Added `/tmp/zpod-uitest-debug/player-tab-play-events.log` traces for every `loadEpisode`/`playPause` call.
- Reworked EpisodeDetailView + previews/tests to accept external view models (`@StateObject`), added UITest-only `PlayerTabPlaybackProxy` hook that listens for `Notification.Name.playerTabPlaySampleRequested`, and wired it into the `PlaybackDebugOverlayManager` button.
- Updated `PlaybackPositionAVPlayerTests` harness to launch with `UITEST_POSITION_DEBUG`, `UITEST_PLAYBACK_DEBUG`, and use the overlay button (`Playback.Debug.PlaySample`) instead of the deeply nested SwiftUI play button.

**Issue**
- Targeted run `./scripts/run-xcode-tests.sh -t zpodUITests/PlaybackPositionAVPlayerTests/testInterruptionPausesAndResumesPlayback` still fails: mini player never appears even though the debug overlay button is tapped (see `TestResults/TestResults_20260112_175436_test_zpodUITests-PlaybackPositionAVPlayerTests-testInterruptionPausesAndResumesPlayback.log`). `/tmp/zpod-uitest-debug/player-tab-play-events.log` shows repeated `EpisodeDetailView appeared` entries but **no** `[EpisodeDetailViewModel] playPause…` traces, so the proxy tap isn’t reaching `Controller.playSampleEpisode()`.

**Plan**
1. Replace the temporary overlay button with a notification-based hook that posts `.playerTabPlaySampleRequested` directly from tests (or convert the overlay to a simulator-level UIWindow as in the swipe debug overlay) so XCTest taps are guaranteed to be received.
2. Once taps reach the controller (confirmed by `player-tab-play-events.log` showing `playPause` lines), rerun the targeted AVPlayer test and, if needed, add the same hook to other playback UITests.
3. Only after the Player tab can reliably trigger `playSampleEpisode()` will we remove the SwiftUI proxy and rely solely on the notification hook for deterministic UI automation.
