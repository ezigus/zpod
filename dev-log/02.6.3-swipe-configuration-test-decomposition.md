# SwipeConfiguration UI Test Decomposition - Issue #02.6.3

**Date**: 2025-11-08 (ET)  
**Status**: ✅ Complete  
**Related Issue**: [#02.6.3](../Issues/02.6.3-swipe-configuration-test-decomposition.md)

## 2025-11-17 – PR Plan Refresh (ET)

- **Objective**: Align PR #134 description with the current optimization plan before making any new code/test edits. Work one step at a time; keep the dev-log and PR body in lockstep.
- **Approach for this step**:
  - Restate the optimization phases (low-hanging runtime wins, structural splits, CI matrix updates) in a concise, reviewer-friendly checklist for the PR body.
  - Include status markers so we can flip `[ ]` → `[x]` as each phase lands; do not start code until this plan is reflected in the PR.
  - Keep scope focused on planning only in this step; defer implementation until the PR text is updated.
- **PR body draft to paste**:
  - Summary: Planning pass to tighten Swipe Configuration UI suite per Issue #02.6.3; no code changes in this step.
  - Plan:
    - [ ] Phase 1 (runtime trims): shorter debug waits, conditional section waits, batched assertions, merge persistence+execution flow, reuse configuration sheet for read-only checks.
    - [ ] Phase 2 (structure): split ComplexIntegration back into ActionManagement, Persistence, Execution; expand UIDisplay to 3 tests to match original plan.
    - [ ] Phase 3 (CI matrix): move to 6-job swipe matrix (UIDisplay, PresetSelection, ToggleInteraction, ActionManagement, Persistence, Execution) with simulator isolation defaults.
  - Validation intent: after each phase, run targeted `./scripts/run-xcode-tests.sh -t zpodUITests/Swipe...` jobs, then full `./scripts/run-xcode-tests.sh` once phases complete.
- **Status**: PR #134 description updated with the above plan; ready to begin Phase 1 runtime trims.

### Phase 1 – Runtime Trims (approach before coding)

- **Debug waits**: Set `waitForDebugSummary` to default to `adaptiveShortTimeout` and thread that through `waitForDebugState` call sites; keep explicit longer timeouts only where seeds/relaunches need them so routine checks stop earlier.
- **Section materialization guard**: Add `waitForSectionIfNeeded` that skips the wait if a section/haptics toggle is already visible; basket this into `openConfigurationSheetFromEpisodeList`, `assertActionList`, and UIDisplay helpers to avoid redundant waits when the sheet is already loaded.
- **Batch debug assertions**: Introduce a helper to capture debug state once and assert multiple conditions, then rewrite `SwipeComplexIntegrationTests` to use a single state fetch per milestone instead of multiple sequential `waitForDebugSummary` polls.
- **Persistence + execution flow**: Combine the seeded persistence check and execution verification into one test to remove the extra relaunch while still validating both behaviors in sequence.
- **Read-only sheet reuse**: Keep UIDisplay validations on the first sheet instance in each test (no cross-test sharing) by caching the container and using the new `waitForSectionIfNeeded`, cutting the repeated section wait/attachment overhead for purely read-only checks.

### Phase 1 – Runtime Trims (completed 2025-11-16 ET)

- Implemented the runtime trims above: defaulted debug waits to short timeouts, added `waitForSectionIfNeeded` fast-paths, introduced `expectDebugState` for single-shot assertions, merged persistence+execution into one test, and reused the initial sheet instance for read-only checks.
- Added toggle materialization guard in `assertFullSwipeState` to avoid long polling—now ensures the toggle is visible once after the sheet loads instead of repeated waits.
- Validation: `./scripts/run-xcode-tests.sh -t zpodUITests/SwipeComplexIntegrationTests` ✅ (Result bundle: `TestResults/TestResults_20251116_190329_test_zpodUITests-SwipeComplexIntegrationTests.xcresult`; prior attempt failed on missing trailing full-swipe toggle before adding the visibility guard).

## 2025-11-16 Test Suite Optimization Plan (ET)

**Context**: After completing the hybrid tier refactoring and fixing all SwipeToggleInteractionTests, analyzed the current 4-file test structure against the original Issue #02.6.3 plan for optimization opportunities.

**Current State**:
- 4 test files, ~10 tests total:
  - `SwipeConfigurationUIDisplayTests.swift` - 1 test, 110 lines
  - `SwipePresetSelectionTests.swift` - 3 tests, 89 lines
  - `SwipeToggleInteractionTests.swift` - 3 tests, 146 lines
  - `SwipeComplexIntegrationTests.swift` - 3 tests, 225 lines (merged ActionManagement + Persistence + Execution)
- Estimated sequential time: ~567.7s (9.5 min)
- All tests meet ≤5 min acceptance criteria ✅

**Original Issue #02.6.3 Plan**:
- 6 files, 18 tests planned:
  - UIDisplay (3), ActionManagement (4), PresetSelection (3), ToggleInteraction (3), Persistence (3), Execution (2)
- Target: 40-50% execution time reduction via parallelization

**Key Bottlenecks Identified**:

1. **App Launch Overhead**: 4 files × ~10s = 40s fixed cost
2. **Configuration Sheet Navigation**: ~100s total (10 tests × 10s per `beginWithFreshConfigurationSheet()`)
3. **Section Materialization Waits**: 8s per fresh sheet open (4 sections × 2s)
4. **Debug State Polling**: 6 calls in ComplexIntegration using 10s timeout (~18s total)
5. **App Relaunch for Persistence**: Single test adds 15-20s for seed+relaunch
6. **Swipe Execution Test**: Heaviest single test at ~60-80s (seed, relaunch, navigation, swipes)

**Optimization Plan**:

**Phase 1: Low-Hanging Fruit** (Estimated savings: 53s sequential)
- Add `timeout` parameter to `waitForDebugSummary()` with default `adaptiveShortTimeout` (5s) ➜ 8s saved
- Implement `waitForSectionIfNeeded()` to skip redundant waits ➜ 5s saved
- Batch debug assertions in ComplexIntegration (capture state once, multiple assertions) ➜ 5s saved
- Merge Persistence+Execution into single test flow (eliminate duplicate relaunch) ➜ 15s saved
- Reuse configuration sheet for read-only UIDisplay tests ➜ 20s saved

**Phase 2: Structural Changes** (Enable CI parallelization)
- Split `SwipeComplexIntegrationTests.swift` into 3 files:
  - `SwipeActionManagementTests.swift` (testManagingActionsEndToEnd)
  - `SwipePersistenceTests.swift` (testSeededConfigurationPersists)
  - `SwipeExecutionTests.swift` (testLeadingAndTrailingSwipesExecute)
- Expand `SwipeConfigurationUIDisplayTests` to 3 tests per original plan:
  - `testConfigurationSheetOpensFromGear()` - navigation only
  - `testAllSectionsAppearInSheet()` - materialization check
  - `testDefaultActionsDisplayCorrectly()` - baseline validation

**Phase 3: CI Configuration**
- Update `.github/workflows/test.yml` matrix to 6 parallel jobs:
  - SwipeConfigurationUIDisplay, SwipePresetSelection, SwipeToggleInteraction
  - SwipeActionManagement, SwipePersistence, SwipeExecution
- Each file builds independently with isolated simulator + DerivedData

**Expected Results**:
- Sequential time: 567.7s → ~515s (9% reduction via timeout/wait optimizations)
- **Parallel CI time: 567.7s → 252.7s (55% reduction)** ✅ *Exceeds 40-50% target*
- Longest single test: SwipeToggleInteractionTests at 252.7s (still <5 min ✅)
- All tests maintain ≤1 relaunch criterion ✅

**Risks & Mitigations**:
1. **Shared sheet state causes flakes** → Only apply to read-only tests, reset for writes
2. **Split tests increase setup overhead** → CI parallelization absorbs cost (5 min parallel < 9.5 min sequential)
3. **Timeout reductions cause false failures** → Keep 10s for relaunch/seed, use 5s only for UI updates

**Success Metrics**:
- Sequential time: <520s (current 567.7s)
- Parallel CI time: <300s (target ~252.7s)
- Max test duration: <300s (current 252.7s ✅)
- Coverage: 18/18 tests (current 10/18)

**Implementation Status**: ⏸️ **PLAN ONLY** - No changes implemented yet. This serves as a roadmap for future optimization work when ready to expand test coverage and improve CI parallelization.

---

## 2025-11-16 Haptics Section Double State Management Fix (ET)

**Context**: After refactoring to eliminate `@State` duplication, tests failed:

```
testHapticToggleEnablesDisables - FAILED: No matches found for "SwipeActions.Haptics.Toggle"
```

**Root Cause #1**: SwiftUI List rendering bug - sections placed after `trailingSection` fail to render entirely
- Computed property `hapticsSection` never called (verified with debug prints)
- Identical code at position 2 (top of List) renders successfully  
- Identical code at position 6 (after `trailingSection`) renders nothing

**Root Cause #2**: Double state management anti-pattern throughout
- `SwipeActionConfigurationView`: Local `@State` duplicating `controller` properties
- `SettingsToggleRow`: Double `Binding($binding)` wrappers causing propagation issues
- `SettingsSegmentedPickerRow`: Same double-wrapper pattern

**Solution**:
1. **SwiftUI Bug Workaround**: Move `hapticsSection` to top of List (position 2, before other sections)
   - Added explanatory comment documenting the constraint
   - Verified rendering with 100+ Find operations in UI test logs

2. **Architecture Fix**: Direct `Binding(get:set:)` pattern throughout
   ```swift
   // OLD (double state):
   @State private var hapticsEnabledState: Bool = true
   SettingsToggleRow("...", isOn: $hapticsEnabledState)
   
   // NEW (direct binding):
   SettingsToggleRow(
     "Enable Haptic Feedback",
     isOn: Binding(
       get: { controller.hapticsEnabled },
       set: { controller.setHapticsEnabled($0) }
     )
   )
   ```

3. **Component Fixes**: Remove double-Binding wrappers
   ```swift
   // SettingsToggleRow.body:
   Toggle(title, isOn: $isOn)  // Direct $ prefix on @Binding parameter
     .onChange(of: isOn) { newValue in onToggle?(newValue) }
   ```

**Test Results**:
- ✅ `testHapticToggleEnablesDisables` - **PASSED** (73.066s)
- ✅ `testHapticStylePickerChangesValue` - **PASSED** (72.265s)
- ❌ `testFullSwipeToggleLeadingTrailing` - **FAILED** (unrelated feature, separate issue)
  - Expects `"SwipeActions.Leading.FullSwipe"` / `"SwipeActions.Trailing.FullSwipe"` identifiers
  - Full-swipe toggle UI not implemented yet
  - Test created during decomposition but feature incomplete

**Verification**:
```
Controller logs: setHapticsEnabled -> false/true (proper integration)
State tracking: unsaved=true after change, unsaved=false after restore (correct semantics)
UI snapshot: 100+ successful "Find the Switch" operations (rendering confirmed)
```

**Commit**: d1fc2f9 - Fix haptics section double state management

---

## Summary

Successfully decomposed the monolithic `SwipeConfigurationUITests.swift` (1,765 lines) into 6 focused test files with 18 total tests, plus a shared test support base class. This improves maintainability, reduces execution time through parallelization, and provides better CI visibility.

## 2025-11-11 Hybrid Tier Refactoring (ET)

**Context**: After 20+ commits attempting to stabilize the 6-job parallel swipe test matrix, tests continued to hang randomly in CI due to:

- `ZPOD_TEST_WITHOUT_BUILDING=1` race conditions with derived data restoration
- Parallel jobs competing for simulator resources and shared derived data
- App launch instrumentation increasing timeout sensitivity
- SwiftUI async rendering timing being non-deterministic under CI load
- **Root cause discovered**: Increasing `max-parallel` from 3 → 5 exceeded simulator isolation infrastructure capacity

**Solution**: Implemented **Hybrid Tier Architecture** (Option 3 from analysis):

**Tier 1 (Parallel Simple Tests)**: 3 jobs, each builds independently

- `SwipeConfigurationUIDisplayTests` - UI display verification
- `SwipePresetSelectionTests` - Preset application
- `SwipeToggleInteractionTests` - Toggle interactions

**Tier 2 (Combined Complex Tests)**: 1 job with merged integration suite

- **Created** `SwipeComplexIntegrationTests.swift` combining:
  - Action management tests (from `SwipeActionManagementTests`)
  - Persistence tests (from `SwipeConfigurationPersistenceTests`)
  - Execution tests (from `SwipeActionExecutionTests`)
- **Deleted** the 3 original test files

**CI Changes**:

- Reduced matrix from 6 jobs → 4 jobs
- Removed `ZPOD_TEST_WITHOUT_BUILDING=1` flag (all jobs build independently)
- Removed derived data artifact download/restoration steps
- Set `max-parallel: 5` with **future-proof simulator isolation**:
  - **Staggered provisioning**: 0-8s hash-based delay per job to avoid simultaneous creation
  - **Active monitoring**: Checks system load, waits if ≥5 simulators exist (up to 60s)
  - **Retry logic**: Up to 3 attempts for creation with exponential backoff (3s, 6s, 9s)
  - **Resource detection**: Identifies resource exhaustion errors and retries appropriately
  - **On-demand boot**: Simulators created but NOT booted; xcodebuild boots on-demand to avoid concurrent boot contention
  - **Graceful degradation**: Falls back to automatic destination if all retries fail
- Each job provisions dedicated simulator with isolated derived data sandbox

**Infrastructure Improvements (Future-Proofing)**:

The simulator isolation system now scales beyond 5 parallel jobs:

1. **Deterministic Staggering**: Hash-based delays (0-8s) prevent thundering herd during creation
2. **Capacity Monitoring**: Checks active simulator count, waits for availability
3. **Retry with Backoff**: 3 attempts with increasing delays (3s, 6s, 9s)
4. **Error Classification**: Detects resource vs configuration errors
5. **On-Demand Boot**: Removed pre-boot logic that caused Data Migration hangs with 5+ simultaneous boots
6. **Early Detection**: System can handle capacity limits gracefully instead of failing mysteriously

**Timeline Analysis**:

- **Oct 21**: `max-parallel: 1` (serial) to avoid contention
- **Oct 22**: `max-parallel: 3` with simulator isolation, no pre-boot ✅ **worked reliably**
- **Nov 9**: `max-parallel: 5` in separate swipe job ❌ **started hanging**
  - Simulator provisioning wasn't designed for 5 simultaneous creates
  - No staggering or capacity monitoring
  - Boot failures went undetected
- **Nov 11 (AM)**: Enhanced infrastructure with boot verification + `max-parallel: 5` ❌ **still hanging**
  - Added boot logic with retry/verification
  - Problem: 5 simulators booting simultaneously get stuck in "Data Migration - Gathering plugins" state
  - macOS can't handle concurrent boot load, especially Data Migration phase
- **Nov 12 (early AM)**: Removed pre-boot logic, return to on-demand boot ✅ **correct fix**
  - Simulators created but not booted in provisioning step
  - xcodebuild boots each simulator when needed (sequential, not parallel)
  - Matches working Oct 22 pattern

**Expected Outcomes**:

- **Reliability**: Eliminates race conditions, gracefully handles resource limits
- **Speed**: ~5-7 min total (4 parallel jobs vs previous 20-30 min with hangs)
- **Scalability**: Can increase beyond 5 when CI hosts gain more capacity
- **Achieves Issue 02.6.3 goals**: Smaller test files, faster execution, better maintainability

## 2025-11-08 Runtime Tightening

- **Execution instrumentation**: Added `SwipeActionHandler` + `EpisodeListViewModel` probes that broadcast the latest swipe execution via the hidden accessibility node `SwipeActions.Debug.LastExecution`. `SwipeActionExecutionTests` now tap the surfaced buttons, poll the probe, and verify the expected episode/action IDs without opening the real playlist sheet (guarded by `UITEST_STUB_PLAYLIST_SHEET`).
- **Persistence suite focus**: Replaced the catch-all `testSeededCustomConfigurationPersists` with `testLeadingActionsPersistFromSeed` + `testTrailingActionsPersistFromSeed`, both using `launchAppWithSeed` (no UI-driven configuration). Removed redundant `restoreDefaultConfiguration()` calls and extra `resetSwipeSettingsToDefault()` invocations inside `seedSwipeConfiguration` to keep each test to a single relaunch.
- **Measured runtimes (iPhone 16 • iOS 18.5 • `CODE_SIGNING_ALLOWED=NO`)**  
  - `SwipeConfigurationPersistenceTests`: 244.9s (4.08 min) via `xcodebuild test -workspace zpod.xcworkspace -scheme zpod -only-testing:zpodUITests/SwipeConfigurationPersistenceTests`.  
  - `SwipeActionExecutionTests`: 116.1s (1.93 min) via `xcodebuild test -workspace zpod.xcworkspace -scheme zpod -only-testing:zpodUITests/SwipeActionExecutionTests`.
- **Acceptance guardrails**: Kept the 5-minute runtime assertion in `SwipeConfigurationTestCase` and added per-test timestamp tracking so the execution probe must emit a new record each time an action runs.

## Changes Made

### Files Created

1. **`SwipeConfigurationUIDisplayTests.swift`** (119 lines, 3 tests)
   - `testConfigurationSheetOpensFromEpisodeList()` - Verifies sheet opens from episode list
   - `testConfigurationSheetShowsDefaultActions()` - Verifies default actions display
   - `testConfigurationSheetShowsHapticControls()` - Verifies haptic controls visible

2. **`SwipeActionManagementTests.swift`** (189 lines, 4 tests)
   - `testAddingSingleLeadingAction()` - Tests adding action to leading edge
   - `testAddingSingleTrailingAction()` - Tests adding action to trailing edge
   - `testRemovingLeadingAction()` - Tests removing action from leading edge
   - `testActionLimitEnforcementLeading()` - Tests 3-action cap enforcement

3. **`SwipePresetSelectionTests.swift`** (125 lines, 3 tests)
   - `testPlaybackPresetAppliesCorrectly()` - Tests Playback preset application
   - `testOrganizationPresetAppliesCorrectly()` - Tests Organization preset application
   - `testDownloadPresetAppliesCorrectly()` - Tests Download preset application

4. **`SwipeToggleInteractionTests.swift`** (145 lines, 3 tests)
   - `testHapticToggleEnablesDisables()` - Tests haptic toggle on/off
   - `testHapticStylePickerChangesValue()` - Tests haptic style picker changes
   - `testFullSwipeToggleLeadingTrailing()` - Tests full swipe toggles

5. **`SwipeConfigurationPersistenceTests.swift`** (129 lines, 3 tests)
   - `testManualConfigurationPersists()` - Tests manual config persistence across relaunches
   - `testHapticSettingPersists()` - Tests haptic settings persistence (uses seeding)
   - `testFullSwipeSettingPersists()` - Tests full swipe settings persistence (uses seeding)

6. **`SwipeActionExecutionTests.swift`** (183 lines, 2 tests)
   - `testLeadingSwipeActionsExecute()` - Tests leading swipe actions execute in episode list
   - `testTrailingSwipeActionsExecute()` - Tests trailing swipe actions execute in episode list

7. **`SwipeConfigurationTestSupport.swift`** (1,442 lines)
   - Shared base class `SwipeConfigurationTestCase` with all helper methods
   - Extracted from original file (lines 1-883 + 1207-1764)
   - Contains navigation, interaction, assertion, and debug helpers

**Total**: 18 tests across 6 files, 2,332 lines total (including shared support)

### Files Deleted

- ❌ **`SwipeConfigurationUITests.swift`** (1,765 lines) - Original monolithic file

### CI Configuration Updates

**Before**:

```yaml
- name: UITests-SwipeConfiguration
  tests: zpodUITests/SwipeConfigurationPersistenceUITests,zpodUITests/SwipeConfigurationExecutionUITests,zpodUITests/SwipeConfigurationPresetCyclingUITests,zpodUITests/SwipeConfigurationActionManagementUITests
```

**After** (6 independent jobs):

```yaml
- name: UITests-SwipeUIDisplay
  tests: zpodUITests/SwipeConfigurationUIDisplayTests
- name: UITests-SwipeActionManagement
  tests: zpodUITests/SwipeActionManagementTests
- name: UITests-SwipePresetSelection
  tests: zpodUITests/SwipePresetSelectionTests
- name: UITests-SwipeToggleInteraction
  tests: zpodUITests/SwipeToggleInteractionTests
- name: UITests-SwipePersistence
  tests: zpodUITests/SwipeConfigurationPersistenceTests
- name: UITests-SwipeExecution
  tests: zpodUITests/SwipeActionExecutionTests
```

### Documentation Updates

- ✅ Updated `zpodUITests/TestSummary.md` to document new test file structure
- ✅ Added descriptions for each test file and its purpose
- ✅ Documented CI parallelization benefits

## Benefits Achieved

### 1. **Improved Maintainability**

- Smaller, focused test files (119-189 lines) vs monolithic 1,765-line file
- Clear separation of concerns (display, action management, presets, toggles, persistence, execution)
- Each file has a single, well-defined responsibility

### 2. **Faster Execution Through Parallelization**

- Tests can run in parallel across 6 CI jobs instead of 1
- Simple tests (display, presets, toggles, action management) run quickly without app relaunches
- Complex tests (persistence, execution) isolated to separate jobs
- **Expected improvement**: 40-50% reduction in total SwipeConfiguration suite execution time

### 3. **Better CI Visibility**

- Granular job failures immediately identify which functionality broke
- Easier to pinpoint issues without wading through long test logs
- Independent job retries without re-running entire suite

### 4. **Easier Test Development**

- New tests can be added to focused files without navigating massive base class
- Test isolation ensures no hidden dependencies between test methods
- Reduced cognitive load when reading/modifying tests

## Technical Approach

### Test Decomposition Strategy

Followed the plan outlined in Issue #02.6.3:

1. **Phase 1**: Extracted simple tests (UI Display + Preset Selection)
2. **Phase 2**: Extracted interaction tests (Action Management + Toggles)
3. **Phase 3**: Extracted complex tests (Persistence + Execution)
4. **Phase 4**: Consolidated helpers into shared base class, deleted original file

### Shared Base Class Design

The `SwipeConfigurationTestCase` base class provides:

- **Navigation helpers**: `navigateToEpisodeList()`, `openSwipeConfigurationSheet()`
- **Configuration helpers**: `seedSwipeConfiguration()`, `resetSwipeSettingsToDefault()`
- **Interaction helpers**: `addAction()`, `removeAction()`, `applyPreset()`, `setHaptics()`, `setFullSwipeToggle()`
- **Assertion helpers**: `assertActionList()`, `assertHapticsEnabled()`, `assertFullSwipeState()`, `waitForDebugSummary()`
- **Debug helpers**: `currentDebugState()`, `parseDebugState()`, `logDebugState()`, `reportAvailableSwipeIdentifiers()`
- **Toggle helpers**: `resolveToggleSwitch()`, `currentStateIsOn()`, `tapToggle()`, `attachToggleDiagnostics()`
- **Container helpers**: `swipeActionsSheetListContainer()`, `ensureVisibleInSheet()`, `elementForAction()`

All test files inherit from this base class and have access to all helper methods.

### Test Isolation

Each test:

- Calls `initializeApp()` or `beginWithFreshConfigurationSheet()` to start with clean state
- Calls `restoreDefaultConfiguration()` at end to clean up
- Can run independently in any order

## 2025-11-16 16:38 — Full-Swipe Toggle Visibility Fix ✅

**Problem**: `testFullSwipeToggleLeadingTrailing` failing - toggles not found in UI hierarchy.

**Initial Approach (WRONG)**: Tried scrolling to toggles with 2-3 swipes.

- **User Guidance**: "Is the issue similar to haptics fix? Swiping multiple times makes no sense since page not big"
- **Realization**: Should be UI positioning, not scrolling (same pattern as haptics section fix)

**Root Cause Analysis**:

1. **Immediate Cause**: Toggles positioned AFTER "Add Action" buttons in each section
   - SwiftUI lazy-loaded rows → toggles materialized late or not at all
   - Solution: Move toggles BEFORE Add Action buttons (applied successfully)

2. **Deeper Cause**: Trailing section positioned below viewport
   - Cumulative height: Haptics (~407pt) + Presets (~323pt) + Leading (~230pt) = ~960pt
   - Viewport height: ~812pt
   - Trailing section started at ~960pt → **entire section not materialized by SwiftUI**

3. **SwiftUI Constraint**: Lazy-loads sections AND rows within sections
   - Scrolling can't materialize non-existent sections
   - Section swap (trailing before leading) just moved problem to opposite section

**Two-Part Solution**:

1. **UI Reordering** (within sections):

   ```swift
   Section(header: Text("Leading Actions")) {
     ForEach(controller.leadingActions, id: \.self) { action in
       actionRow(for: action, edge: .leading)
     }
     
     // ✅ MOVED BEFORE Add Action button
     SettingsToggleRow("Allow Full Swipe", isOn: ..., 
                       accessibilityIdentifier: "SwipeActions.Leading.FullSwipe")
     
     if controller.canAddMoreActions(to: .leading) {
       addActionTrigger(for: .leading)
     }
   }
   ```

2. **Section Reordering** (List-level):

   ```swift
   ScrollViewReader { proxy in
     List {
       Color.clear.frame(height: 0).id("swipe-top")
       
       hapticsSection.id("swipe-haptics")      // ~407pt (position 1)
       leadingSection.id("swipe-leading")      // ~230pt (position 2, NOW VISIBLE)
       trailingSection.id("swipe-trailing")    // ~230pt (position 3, NOW VISIBLE)
       presetsSection                          // ~323pt (position 4, can be below fold)
     }
   }
   ```

**Result**:

- Combined height before trailing: Haptics (~407pt) + Leading (~230pt) = ~637pt (within viewport)
- Trailing section: ~637pt-867pt (toggles positioned early in section → materialized)
- Both toggles immediately visible without scrolling

**Test Results**:

```text
✅ testFullSwipeToggleLeadingTrailing (passed)
✅ testHapticStylePickerChangesValue (passed)
✅ testHapticToggleEnablesDisables (passed)

3 tests, 0 failures, 252.7 seconds total
```

**Key Logs Showing Success**:

```text
[SwipeUITestDebug] Context: Sheet opened (initial) [scoped]
SwipeActions.Leading.FullSwipe    ✅ NOW VISIBLE
SwipeActions.Trailing.FullSwipe   ✅ NOW VISIBLE

[SwipeConfigDebug] UI toggled leading full swipe -> false   ✅ INTERACTION SUCCESS
[SwipeConfigDebug] UI toggled trailing full swipe -> true   ✅ INTERACTION SUCCESS
```

**Commit**: `be0a94e` - "[#02.6.3] Fix full-swipe toggle visibility with section reordering"

**Pattern Applied**:

1. User guidance: "Page not big" → structural reordering, not scrolling
2. Haptics fix pattern: Move critical elements early in their containers
3. Extended to section level: Move critical sections early in List

**Files Modified**:

- `SwipeActionConfigurationView.swift`: Presets moved to bottom, toggles before buttons
- `SwipeConfigurationTestSupport+Toggle.swift`: Removed all scrolling logic


- Uses seeding (base64 JSON environment variables) for persistence tests to avoid UserDefaults cross-launch issues

## Validation

### Code Changes

- ✅ All new test files created and inherit from base class
- ✅ Original monolithic file deleted
- ✅ CI workflow updated with 6 new jobs
- ✅ Documentation updated

### Test Structure

- ✅ Each test file has clear, focused purpose
- ✅ Tests follow Given/When/Then structure with descriptive names
- ✅ Proper use of XCTest assertion methods
- ✅ All tests properly isolated with setup/teardown

### CI Configuration

- ✅ 6 new jobs defined in matrix
- ✅ Each job references correct test file class name
- ✅ Jobs can run in parallel (max-parallel: 3)

## Next Steps

### Immediate

- Run full zpodUITests regression to verify all tests pass
- Monitor CI execution time to measure improvement
- Validate test isolation in parallel execution

### Future Enhancements

- Consider further splitting persistence tests (each relaunch as separate test)
- Add visual regression tests for swipe configuration UI layout
- Consolidate shared UI helpers across all test suites

## Metrics

**Before**:

- 1 file, 1,765 lines
- 4 test classes, 6 tests
- 1 CI job running sequentially
- Longest-running test suite in CI

**After**:

- 7 files (6 test files + 1 support), 2,332 lines total
- 6 test classes, 18 tests
- 6 CI jobs running in parallel
- Expected 40-50% execution time reduction

**Net Change**:

- +567 lines total (33% increase for better organization)
- +12 tests (200% increase in test coverage granularity)
- +6 CI jobs (600% increase in parallelization)

## 2025-11-09 — Preset Suite Stabilization

CI run #1100 exposed repeated timeouts in `SwipePresetSelectionTests` because the presets/haptics sections sit below the initial viewport and virtualization meant the controls did not exist until the sheet was scrolled. Fixes:

- Added a UI-test-only launch flag (`UITEST_AUTO_SCROLL_PRESETS`) that renders the preset section at the top of the sheet so the buttons enter the accessibility tree immediately, without affecting production builds.
- Hardened `ensureVisibleInSheet` with coordinate-based drag gestures, additional scroll attempts, and scoped identifier logging so any identifier—preset rows, toggle switches, etc.—forces the sheet to materialize the cell before we assert on it.
- Updated `applyPreset(_:)` and `resolveToggleSwitch(_:)` to call that helper up front, guaranteeing preset buttons and toggles are brought into view (and exist in the accessibility tree) before we wait for them.
- Left instrumentation hooks (`[SwipeUITestDebug] …`) in place so future CI captures include the sheet’s identifier inventory when visibility checks fail.

Validation:

- `scripts/run-xcode-tests.sh -t zpodUITests/SwipePresetSelectionTests/testPlaybackPresetAppliesCorrectly --sim "iPhone 16"` → ✅ (~48 s).
- `scripts/run-xcode-tests.sh -t zpodUITests/SwipePresetSelectionTests --sim "iPhone 16"` → ✅ (3 tests, ~2m23 s total).
- Re-pushed branch (commit `5bbc531`) so the updated suite runs inside CI matrix job `UITests-SwipePresetSelection`.

---

## 2025-11-10 — Derived Data Artifact Fix & UI Matrix Follow-up

- **Symptom:** CI run #1115 showed all six swipe suites executing but `SwipeToggleInteraction` failed looking for `SwipeActions.Haptics.*` identifiers, while `SwipePersistence` crashed with an early exit. On the subsequent run (#1116) the legacy UI suites never started; they stopped at “Extraction failed or incomplete – zpod.app not found” because we had just switched preflight to archive the entire DerivedData tree.
- **Fix:** Updated `.github/workflows/ci.yml` so every UI job (legacy + swipe + integration) restores the full DerivedData bundle via `scripts/ci/restore-host-app.sh`. That guarantees `.xctestrun` metadata, the host app, and all test bundles land in the correct path before `test-without-building` runs. Also ensured the pack step creates the `zpod` symlink before tarring.
- **Next investigations:** With the restoration plumbing fixed, the legacy suites should execute again. Remaining work is to reproduce the real test failures from #1115 (toggle controls missing, persistence runner crash) by pulling the artifacts (`test-UITests-SwipeToggleInteraction`, `test-UITests-SwipePersistence`) and re-running those suites locally.

Validation steps:

- `scripts/ci/restore-host-app.sh "$PWD/tmp_ci/DerivedData/UITests-SwipeUIDisplay" host-app` (invoked inside CI jobs) now moves the entire tree and re-validates `zpod.app`.
- `gh run view 19238899775` confirms the next run will use the updated restore step once pushed; current run cancelled to prevent further wasted minutes while the fix was staged.
- `scripts/run-xcode-tests.sh -t zpodUITests/SwipeToggleInteractionTests --sim "iPhone 17 Pro"` ✅
- `scripts/run-xcode-tests.sh -t zpodUITests/SwipeActionManagementTests --sim "iPhone 17 Pro"` ✅
- `scripts/run-xcode-tests.sh -t zpodUITests/SwipeConfigurationPersistenceTests --sim "iPhone 17 Pro"` ✅

### 2025-11-10 15:20 ET — Materialize Swipe Sections for UITests

- Root cause of the latest swipe-suite failures: SwiftUI `List` virtualization stopped instantiating rows that sit below the initial viewport, so identifiers such as `SwipeActions.Trailing.FullSwipe` and `SwipeActions.Haptics.Toggle` never entered the accessibility tree even though the tests were scrolling. CI artifacts confirmed the identifier snapshots only contained leading rows + preset buttons.
- Added a UITest-only environment flag (`UITEST_SWIPE_PRELOAD_SECTIONS`) that:
  - Enables a `ScrollViewReader` pass inside `SwipeActionConfigurationView` to programmatically scroll to the trailing + haptics sections once the baseline loads, ensuring the rows are instantiated, then scrolls back to the top.
  - Is set automatically by `SwipeConfigurationTestSupport` so every swipe suite benefits without code duplication.
- While touching the layout, also nudged `SwipeActionManagementTests.testActionLimitEnforcementLeading` to call `ensureVisibleInSheet` before asserting on the trailing add button, eliminating the brittle assumption that the button is already visible once the leading side hits the cap.
- Local reruns (see commands above) now surface all toggles/buttons immediately; the UITest helper no longer logs “unable to surface … after 16 attempts”.

### 2025-11-10 17:20 ET — Guard Rails for Swipe UIDisplay Job

- **CI signal:** Runs #1113/#1117/#1118 all showed `ui-tests-swipe (UITests-SwipeUIDisplay…)` sitting idle for 25–110 minutes with no XCTest output until the job was cancelled. The StandardOutput file in the xcresult was empty, which means the test runner never made it past the initial app launch.
- **Instrumentation:** Added `[SwipeUITestDebug]` logging around every stage of `launchConfiguredApp` (terminate → launch → main tab bar → batch overlay) so the next stuck run will at least show where we’re blocked. These logs emit both through `Logger` and `print`, so they land in the GitHub Actions log even before XCTest starts streaming `t = …` lines.
- **Test structure:** `SwipeConfigurationUIDisplayTests` now exercises the entire display scenario inside a single test case (`testConfigurationSheetDisplaysDefaultUI`). Previously we relaunched the app three separate times per suite to cover “open sheet”, “default actions”, and “haptic controls”, dramatically multiplying the time spent waiting for background overlays/navigation. Consolidating the assertions restores the single-launch behavior we had before splitting out the swipe suites.
- **Verification:** `scripts/run-xcode-tests.sh -t zpodUITests/SwipeConfigurationUIDisplayTests --sim "iPhone 17 Pro"` now completes locally (1 test, ~3m58 s) and produces the new launch debug breadcrumbs.

---

**Issue**: ezigus/zpod#131  
**Parent Issue**: ezigus/zpod#12.8 (UI Test Matrix Optimization)  
**Related**: ezigus/zpod#02.1.6.2 (Original Swipe Configuration Implementation)

---

## 2025-11-12 16:00 ET — SwiftUI List Lazy Rendering Race Condition

**Context**: CI run #1125 (after fixing boot hangs) showed 3 SwipeUI tests still failing with abnormally long execution times (115-175s vs normal 15-30s). Tests failed looking for `SwipeActions.Haptics.Toggle` element.

**Root Cause Analysis**:

1. **Time Sink Identified**: Tests spent 60-103 seconds in `resolveToggleSwitch()` exhaustively searching for missing element
   - Pattern: Sheet opens at t=46s → Start searching t=47-50s → 61 seconds of searching → Fails at t=116s
   - Search exhaustively tries: Switch, Button, Cell, TextField, SecureTextField, Image, StaticText, Other, Any (each with retries)

2. **UI Hierarchy Investigation**: Logs showed other SwipeActions sections rendered correctly:
   - ✅ `SwipeActions.Leading.FullSwipe` - Present
   - ✅ `SwipeActions.Trailing.FullSwipe` - Present
   - ✅ `SwipeActions.Debug.StateSummary` - Present
   - ❌ `SwipeActions.Haptics.Toggle` - **Missing from accessibility tree**

3. **Source Code Analysis**:
   - `SwipeActionConfigurationView.swift` line 121: `hapticsSection.id("swipe-haptics")` unconditionally included in List
   - Lines 24-25: `@State` vars properly declared (`hapticsEnabledState`, `hapticStyleState`)
   - Lines 36-37: `@State` vars properly initialized in `init()` from controller values
   - Line 84: `onReceive(controller.$draft)` updates state binding
   - Lines 173-199: `hapticsSection` defined with `SettingsToggleRow` at line 178

4. **Materialization Logic Discovery**:
   - Line 20: `shouldForceMaterialization` flag checks `UITEST_SWIPE_PRELOAD_SECTIONS` env var
   - Lines 258-275: `materializeSectionsIfNeeded()` function scrolls to force SwiftUI lazy rendering
   - **Critical**: Uses **3 sequential `DispatchQueue.main.asyncAfter` calls with 0.2s delays each**
   - Total materialization time: **0.6 seconds**
   - Scrolls: `swipe-trailing` (0.2s) → `swipe-haptics` (0.4s) → back to top (0.6s)

5. **Race Condition**:
   - `openSwipeConfigurationSheet()` waits for sheet to appear (line 220: `waitForBaselineLoaded()`)
   - **BUT**: No wait for materialization scroll sequence to complete!
   - Tests immediately call `setHaptics()` → `resolveToggleSwitch()` before 0.6s scroll finishes
   - Element doesn't exist yet → 60+ seconds wasted in exhaustive search → Test fails

**Fix Implemented**:

**Fix Implemented**:

Added `waitForSectionMaterialization()` helper function:

- Location: `SwipeConfigurationTestSupport+Debug.swift` after `waitForBaselineLoaded()`
- Purpose: Wait up to 2 seconds for `SwipeActions.Haptics.Toggle` to appear in accessibility tree
- Called from: `openSwipeConfigurationSheet()` immediately after `waitForBaselineLoaded()`
- Rationale: Ensures SwiftUI's async scroll sequence (0.6s total) completes before tests interact with elements

**Expected Outcomes**:

1. Test execution time: 115-175s → 15-30s (reduce by 4-6x)
2. Element search failures eliminated (haptics section now materialized)
3. No more exhaustive 60-second searches for missing elements
4. All 3 failing tests should pass

**Files Modified**:

- `zpodUITests/SwipeConfigurationTestSupport+Navigation.swift`: Added `waitForSectionMaterialization()` call
- `zpodUITests/SwipeConfigurationTestSupport+Debug.swift`: Added helper function with 2s timeout

**Validation**:

- Pending: Local test run interrupted (build time)
- Next: Push to CI and monitor run for test duration + pass rate

---

**Issue**: ezigus/zpod#131  
**Parent Issue**: ezigus/zpod#12.8 (UI Test Matrix Optimization)  
**Related**: ezigus/zpod#02.1.6.2 (Original Swipe Configuration Implementation)

## 2025-11-13 CI Test Failures & TextField Focus Issues (ET)

**Context**: CI run #19349031066 had 2 test failures:
1. **SwipePresetSelectionTests**: `testPlaybackPresetAppliesCorrectly` - Save button never enabled
2. **ContentDiscoveryUITests**: `testRSSURLInput` - Keyboard timeout waiting to appear  

Plus 54+ subscript syntax uses (`app.buttons["ID"]`) that create duplicate identifier issues.

**Investigation** (CI run #19349031066):

Downloaded test artifacts (147.2 MB) and analyzed logs:
- **SwipePresetSelection failure timeline**:
  - t=76.90s: Playback preset button tapped successfully
  - t=77.31s: Tap synthesized, app idled at t=78.57s  
  - t=82-85s: Save button queried multiple times but `isEnabled` never becomes `true`
  - Root cause: **APPLICATION BUG** not test issue

- **ContentDiscovery failure timeline**:
  - t=17.56s: TextField.tap() synthesized
  - t=17.86s: App idled
  - t=19.63s: Start waiting for keyboard
  - t=20.78s-86.27s: Keyboard NEVER appeared (waited 70+ seconds!)
  - Root cause: `TextField.tap()` doesn't reliably focus fields in iOS simulator CI

**Root Cause Analysis**:
1. **SwipePresetSelection Bug**: `.disabled()` modifier on `Text` child instead of `Button` parent
   - File: `SwipeActionConfigurationView.swift` line 111
   - SwiftUI applies `.disabled()` to Text appearance only, not Button's enabled state
   - UI tests check `button.isEnabled` which always returns `true`

2. **ContentDiscovery Bug**: `TextField.tap()` + keyboard wait anti-pattern
   - Pattern: `tap()` → wait for keyboard → wait for focus → `typeText()`
   - Problem: `tap()` doesn't reliably focus text fields in simulator
   - XCUITest retries 3 times, each time keyboard never appears
   - User questioned timeout increase (correct instinct!) - should fix root cause, not mask symptom

3. **Subscript Syntax**: 54+ uses of `app.buttons["ID"]` instead of `.matching(identifier:).firstMatch`

**Fixes Applied**:

### Fix 1: Save Button .disabled() Placement ✅
Moved `.disabled()` from Text to Button in `SwipeActionConfigurationView.swift`

### Fix 2: TextField Interaction Pattern ✅
**Discovered**: `XCUIElement.typeText()` requires the element to ALREADY have focus. Must tap first.

**Correct pattern**:
```swift
searchField.tap()
searchField.typeText("query")
// NO waits, NO keyboard checks, NO retries
```

**Removed from ContentDiscoveryUITests** (85 lines eliminated):
- All `app.keyboards.firstMatch.waitForExistence()` checks
- All `waitUntil()` polling loops with `pollInterval`
- All complex retry logic for field values
- All redundant existence checks after operations

**Tests fixed**: `testRSSURLInput`, `testSearchFunctionality`, `testSearchClearButton`, `testSearchFilters`, `testSearchResponsiveness`

### Fix 3: Subscript Syntax Conversion ✅
Applied `.matching(identifier:).firstMatch` to all 42 remaining subscript uses across 5 test support files.

**Test Results** (Local validation):
- **Before**: 5 failures (ContentDiscovery: keyboard focus issues)
- **After**: 1 failure (`testSearchFieldInput` - intermittent search result timing)
- **Tests passing**: 11/12 ContentDiscoveryUITests now reliable

**Key Lessons**:
1. **Don't increase timeouts to mask symptoms** - investigate WHY expected state never arrives
2. **TextField.tap() is unreliable in CI** - doesn't consistently focus or show keyboard  
3. **Proper pattern**: `tap()` then `typeText()` - no waits needed
4. **UI tests should be direct and immediate** - no polling, no retries, no fallback logic
5. **Application bugs can look like test failures** - always verify implementation first

---

## 2025-11-15 — Debug Overlay Accessibility & Persistence Check Fix (ET)

**Context**: Continuing work from PR #134 on issue #02.6.3. After 8+ iterations trying different approaches to make debug overlay buttons discoverable by XCUITest (UIWindow configurations, timing strategies, AppDelegate), all approaches failed because the overlay existed at a different window level and SwiftUI sheets blocked accessibility queries.

**Breakthrough**: User suggested notification-based hook architecture: "do you need to create a hook in the application code that is available to connect to if we are in debug/test mode? wouldn't that be easier? basically it is always there (the hook) but only has things attached to it when we are debug mode"

**Solution Implemented**:

### Notification-Based Hook Architecture ✅

**zpodApp.swift** (lines 7-26):
- Added `Notification.Name.appDidInitialize` extension
- Posts notification in `init()` after hardware keyboard/Siri/CarPlay setup
- Hook is **always present** but only connected in test mode

**SwipeDebugOverlayManager.swift** (lines 7-57):
- Listens for `.appDidInitialize` notification only when `UITEST_SWIPE_DEBUG=1`
- Observer property: `nonisolated(unsafe) private var observer: NSObjectProtocol?`
- Callback wraps `showDefaultPresetsIfNeeded()` in `Task { @MainActor in }`
- Properly removes observer in `deinit`

**Test Evidence**:
- Test log shows overlay working perfectly:
  - t=75.03s: Find "SwipeActions.Debug.ApplyPreset.Playback.Toolbar" Button ✅
  - t=75.19s: Tap "SwipeActions.Debug.ApplyPreset.Playback.Toolbar" Button ✅
  - t=92-93s: Found all Playback preset actions (Play, Add to Playlist, Download, Favorite) ✅

### Persistence Check Fix ✅

**Problem**: Tests failed at new assertion point (line 190 in SwipeConfigurationTestSupport.swift):
```swift
guard let settings = decodedGlobalUISettings()?.swipeActions else {
  XCTFail("Unable to decode persisted swipe configuration from test suite defaults")
  return
}
```

**Root Cause**: `assertPersistedSwipeConfiguration()` was being called prematurely in `SwipePresetSelectionTests`. Tests were:
1. Applying preset (updates draft only) ✅
2. Waiting for Save button to be enabled ✅
3. **Asserting persistence** ❌ (Nothing saved yet!)

The issue description (Issue #02.6.3) clearly separates concerns:
- **SwipePresetSelectionTests**: Verify presets apply correctly (UI state)
- **SwipeConfigurationPersistenceTests**: Verify save/relaunch cycle (UserDefaults)

**Fix Applied** (SwipePresetSelectionTests.swift):
```swift
@MainActor
private func assertConfiguration(
  leadingActions: [String],
  trailingActions: [String]
) {
  // Verify preset applied to draft configuration (UI state)
  assertActionList(
    leadingIdentifiers: leadingActions.map { "SwipeActions.Leading.\($0)" },
    trailingIdentifiers: trailingActions.map { "SwipeActions.Trailing.\($0)" }
  )
  // Note: Persistence validation happens in SwipeConfigurationPersistenceTests
  // after Save button is tapped. These preset tests only verify draft state.
}
```

**Test Results**:
- ✅ `testPlaybackPresetAppliesCorrectly` - 104.9s (passed)
- ✅ `testOrganizationPresetAppliesCorrectly` - 106.2s (passed)  
- ✅ `testDownloadPresetAppliesCorrectly` - 104.3s (passed)
- **Total**: 3 tests, 315.4s, 0 failures

**Key Achievements**:
1. **Notification-based hooks** are superior to timing-based approaches
2. **Always-present hooks with conditional listeners** provide clean separation
3. **Test logs are definitive proof** of XCUITest discoverability
4. **Persistence validation requires matching expectations** - preset application ≠ save action

**Files Modified**:
- `zpod/zpodApp.swift`: Added notification hook
- `Packages/LibraryFeature/Sources/LibraryFeature/SwipeDebugOverlayManager.swift`: Added listener (new file)
- `Packages/LibraryFeature/Sources/LibraryFeature/SwipeDebugPresetEntry.swift`: Made public (new file)
- `zpodUITests/SwipePresetSelectionTests.swift`: Removed premature persistence check

---

## 2025-11-15 — SwipeConfigurationUIDisplayTests Navigation Issue (ET)

**Context**: After successfully fixing SwipePresetSelectionTests (all 3 tests passing), attempted to validate all Tier 1 simple tests together by running:
```bash
./scripts/run-xcode-tests.sh -t zpodUITests/SwipeConfigurationUIDisplayTests,zpodUITests/SwipePresetSelectionTests,zpodUITests/SwipeToggleInteractionTests
```

**Problem Discovered**: `SwipeConfigurationUIDisplayTests.testConfigurationSheetDisplaysDefaultUI` failed after 235.9 seconds with navigation/context issue.

**Error Details**:
```
Failed to get matching snapshot: No matches found for first query match sequence:
  `Descendants matching type Any` -> `Elements matching predicate '"SwipeActions.Leading.Mark Played" IN identifiers'`
```

**Debug Logs Show**:
- `[SwipeUITestDebug] unable to surface SwipeActions.Trailing.Delete after 4 attempts`
- `[SwipeUITestDebug] unable to surface SwipeActions.Trailing.Archive after 4 attempts`
- Element tree shows: `CollectionView, identifier: 'Episode List View'` (wrong context!)
- Test spent 180+ seconds (t=120s to t=230s) scrolling episode list trying to find config elements

**Root Cause Analysis**: Test appears to be searching for configuration sheet elements in the episode list view context instead of the configuration sheet itself. This is a **navigation/view hierarchy issue**, not an accessibility problem.

**Comparison with Working Tests**:
- ✅ SwipePresetSelectionTests: Successfully navigates to config sheet, applies presets, verifies UI
- ❌ SwipeConfigurationUIDisplayTests: Opens sheet but queries are targeting wrong view context

**Next Steps**:
1. Review `SwipeConfigurationUIDisplayTests.swift` to understand how it opens the configuration sheet
2. Compare navigation setup with working preset tests
3. Determine if sheet is not opening properly or if element queries are targeting wrong view hierarchy
4. Fix navigation/context issue so test finds elements in configuration sheet context
5. Validate all Tier 1 simple tests pass together

**Status**: Investigation in progress - SwipePresetSelectionTests fully working (3/3 passing), SwipeConfigurationUIDisplayTests requires navigation/context fix.

## 2025-11-15 — Swipe UI verification + full regression (ET)

**Intent**: Confirm the toolbar/overlay seams are behaving on CI by re-running the swipe preset suite in isolation, double-check the display test, and then drive the full automation script so we have a clean baseline before pushing.

**Actions**
1. ✅ Re-ran each preset test individually so we have deterministic xcresults per scenario:
   - `./scripts/run-xcode-tests.sh -t zpodUITests/SwipePresetSelectionTests/testDownloadPresetAppliesCorrectly`
     → `TestResults/TestResults_20251115_095824_test_zpodUITests-SwipePresetSelectionTests-testDownloadPresetAppliesCorrectly.{log,xcresult}`
   - `./scripts/run-xcode-tests.sh -t zpodUITests/SwipePresetSelectionTests/testOrganizationPresetAppliesCorrectly`
     → `TestResults/TestResults_20251115_100039_test_zpodUITests-SwipePresetSelectionTests-testOrganizationPresetAppliesCorrectly.{log,xcresult}`
   - `./scripts/run-xcode-tests.sh -t zpodUITests/SwipePresetSelectionTests/testPlaybackPresetAppliesCorrectly`
     → `TestResults/TestResults_20251115_100310_test_zpodUITests-SwipePresetSelectionTests-testPlaybackPresetAppliesCorrectly.{log,xcresult}`
   Each case now exercises the toolbar seam (no fallbacks), taking ~100–110s with zero failures.
2. ✅ Spot-checked `SwipeConfigurationUIDisplayTests` (`TestResults/TestResults_20251115_094443…`) to ensure the navigation fix is holding.
3. ✅ Ran the full script `./scripts/run-xcode-tests.sh` (syntax → AppSmoke → workspace build → every SwiftPM package → IntegrationTests → zpodUITests). Latest bundles live under the `TestResults_20251115_1014xx_*` prefix and all phases returned success.

**Outcome**
- Swipe preset automation is healthy again—no pending retries, and each preset has its own fresh log/xcresult pair for review.
- Full regression completed successfully, so the branch is "green" and ready for PR updates/push after this dev-log entry lands.

## 2025-11-15 — CI Failure Investigation: Conditional Compilation Guard (ET)

**Intent**: Investigate why all 4 swipe UI test jobs fail in CI workflow run #1142 (exit code 65) while same tests pass locally. User requested investigation and insights (not implementation) on the problem.

### Investigation Process

1. **CI Failure Pattern** (Workflow Run #1142):
   - All 4 swipe test jobs failing with exit code 65:
     - `UITests-SwipePresetSelection` (3 tests)
     - `UITests-SwipeUIDisplay` (6 tests)
     - `UITests-SwipeToggleInteraction` (3 tests)
     - `UITests-SwipeComplexIntegration` (6 tests)
   - Tests can't find debug preset buttons (`.SwipeActions.Debug.ApplyPreset.Playback.Toolbar`)
   - Local execution: All tests passing (e.g., SwipePresetSelectionTests 3/3, 315.4s)

2. **Code Flow Analysis**:
   - Traced notification-based hook architecture:
     - `zpodApp.swift` init() → posts `.appDidInitialize` notification
     - `SwipeDebugOverlayManager` → listens for notification when `UITEST_SWIPE_DEBUG=1`
     - Test infrastructure → sets `UITEST_SWIPE_DEBUG=1` in `baseLaunchEnvironment`
   - **ROOT CAUSE DISCOVERED**: Conditional compilation guard in `zpodApp.swift`:
     ```swift
     #if canImport(LibraryFeature)
       NotificationCenter.default.post(name: .appDidInitialize, object: nil)
     #endif
     ```
   - **Why it fails in CI**: Compile-time check prevents notification from being compiled if LibraryFeature linking differs between local and CI builds
   - **Why it works locally**: LibraryFeature apparently available during local compilation

3. **Architectural Analysis**:
   - **Compile-time vs Runtime Conditional**: Using `#if canImport()` is wrong approach for debug hooks
   - **Observer Pattern Principle**: Posting notifications is zero-cost when unlistened—should be unconditional
   - **Correct Pattern**: Hook (notification post) always present, listener conditionally attached at runtime
   - **Current Mismatch**:
     - ❌ zpodApp.swift: Compile-time conditional (`#if canImport(LibraryFeature)`)
     - ✅ SwipeDebugOverlayManager: Runtime conditional (`ProcessInfo.environment["UITEST_SWIPE_DEBUG"] == "1"`)

### Solution Implemented

Removed the `#if canImport(LibraryFeature)` guard from `zpodApp.swift`:

```swift
init() {
  disableHardwareKeyboard()
  configureSiriSnapshots()
  configureCarPlayDependencies()

  // Always post initialization notification - debug tools can listen if needed
  // This is harmless when nothing is listening (zero cost, loose coupling)
  NotificationCenter.default.post(name: .appDidInitialize, object: nil)
}
```

### Rationale

- **Architecturally Correct**: Notifications designed for loose coupling—posting has zero cost when unlistened
- **Eliminates Build Dependencies**: No longer dependent on compile-time LibraryFeature availability
- **Runtime Safety**: Observer only registers when `UITEST_SWIPE_DEBUG=1` (existing runtime check)
- **CI/Local Consistency**: Hook always available in both environments

**Verification**:

1. ✅ Build verification: `./scripts/run-xcode-tests.sh -b zpod`
   - 22 targets compiled successfully
   - 0 errors, 0 warnings

2. ✅ Local test validation: `./scripts/run-xcode-tests.sh -t zpodUITests/SwipePresetSelectionTests/testPlaybackPresetAppliesCorrectly`
   - Test passed: 108.991 seconds, 0 failures
   - Debug overlay appeared correctly (found all preset buttons)
   - Preset applied successfully (Play + Add to Playlist actions verified)

3. ✅ Committed: 31b6ccd "[#02.6.3] Remove conditional compilation guard from notification post"

4. ⏳ **CI Validation Pending**: Pushed to PR #134 branch `copilot/decompose-swipeconfiguration-ui-tests`
   - Will monitor next workflow run to confirm all 4 swipe test jobs pass
   - Expected: All tests find debug overlay, apply presets, verify configurations

### Key Learnings

- **Conditional Compilation Pitfalls**: `#if canImport()` creates environment-specific behavior; avoid for debug hooks
- **Observer Pattern Best Practices**: Notifications should be unconditional; listeners selectively attach
- **CI/Local Parity**: Compile-time conditionals can mask issues that only surface in different build environments
- **Debug Infrastructure**: Always-present hooks + runtime-conditional listeners = robust test infrastructure

**Status**: Fix implemented, validated locally, pushed to CI. Awaiting workflow run results to confirm all 4 swipe test jobs pass.

---

## 2025-11-16 — Swipe toggle regression: broadened root-cause plan (ET)

**Current state**
- Even after reverting to the 2025-11-10 known-good controller/view/tests and simplifying the haptics row to a plain switch, `SwipeToggleInteractionTests` still fail; the debug summary stays `haptics=true`/`unsaved=false`.
- Instrumentation in the toggle closure and controller setters never fires → the tap is not reaching the bound handler.
- Scoped identifier/tree dumps are not appearing in xcodebuild logs, suggesting either the sheet context is wrong or stdout/attachments aren’t captured as expected.

**Hypotheses (broad)**
1) **Wrong view/controller under test**: Navigation may be presenting a different sheet or a new controller instance; taps interact with a stale tree.
2) **Identifier placed on wrapper, not switch**: `SwipeActions.Haptics.Toggle` may resolve to a container element, so XCUI taps don’t hit the UISwitch.
3) **Post-load reset**: `EpisodeListView` or `SwipeConfigurationController` may reload baseline/reset defaults after the tap, wiping draft before the debug summary updates.
4) **Launch/env mismatch vs passing run**: A newer UITEST flag or defaults seeding/reset behavior might be clobbering state mid-test.

**Plan (no further code tweaks until validated)**
1) **Runtime visibility of the sheet tree**: Immediately after opening the sheet, log to stdout the scoped container’s `debugDescription` plus a filtered list of elements (type/id/label). Goal: confirm which element holds `SwipeActions.Haptics.Toggle` and whether a real `Switch` exists under it.
2) **Switch existence check in tests**: In test support, assert and log the presence/type/value of `app.switches["SwipeActions.Haptics.Toggle"]` (scoped to the sheet). If absent, fail early with the printed tree to avoid blind taps.
3) **Controller identity tracking**: Include a controller UUID in the debug summary to detect mid-test controller replacement/resets.
4) **Baseline/reset tracing**: Add lightweight logging when `loadBaseline`/`updateDraft` run in the controller to see if state is being reset after the tap.
5) **Env parity check**: Compare UITEST env from the passing 2025-11-10 run to current defaults (reset flags, seeded defaults, UITEST_* toggles) to ensure we’re not reinitializing defaults between steps.

**Next action**: Implement the above observability (stdout tree dump + switch existence assert + controller UUID + baseline/reset logs) and re-run the toggle suite to capture evidence before any further functional changes.

# 2025-11-16 — Broader test/spec/architecture alignment (ET)

**Prompt to zoom out**: User requested a holistic review to ensure tests match the intended design/spec, not just a toggle interaction. No code changes yet; this entry documents the broader findings and proposed adjustments (code + tests).

### What we’re testing vs intended scenarios
- Failing suites: `SwipeToggleInteractionTests`, `SwipeConfigurationUIDisplayTests`, `SwipeComplexIntegrationTests`.
- Intended GWT scenarios (from Issue 02.1.6 swipe gestures plan):
  - Toggle haptics on/off and persist.
  - Display: sheet shows baseline actions/haptics and reacts to presets.
  - Integration: navigation from episode list, apply preset/add/remove actions, commit and verify persistence.
- Current tests focus heavily on debug seams (summary, debug buttons) rather than user-facing outcomes. There is no assertion of actual episode swipe behavior after toggles in the failing suite.

### Architectural fit gaps
- **Controller lifecycle**: Controller may be recreated when the sheet opens or when defaults reset (`EpisodeListView` init honors `UITEST_RESET_SWIPE_SETTINGS`). Tests assume a single controller instance across interactions.
- **Navigation path**: Tests only open from episode list; if settings shell creates a different controller/view, the debug summary could be from another instance. Need to confirm tap path matches the intended public surface.
- **Env/reset behavior**: UITest env always sets `UITEST_RESET_SWIPE_SETTINGS=1`; if any post-load operation re-applies baseline, draft changes disappear before debug summary updates.
- **Identifier health**: Possible duplicate/misplaced `SwipeActions.Haptics.Toggle` (wrapper vs switch). Without a reliable tree dump, tests may be tapping the wrong element.

### Test/harness validity concerns
- Tests rely on debug summary probes more than user-visible effects (e.g., no episode swipe execution check after toggling haptics/full-swipe).
- Setup does not assert the switch exists before tapping; it doesn’t fail fast with tree context.
- Assumptions on auto-materialization flags (`UITEST_SWIPE_PRELOAD_SECTIONS`, `UITEST_AUTO_SCROLL_PRESETS`) may no longer hold after the rollback.

### Proposed broader changes (to document and then implement)
**Code-side (minimal, aligned to intent)**
1) Make controller identity explicit in debug summary (UUID) so tests detect controller replacement/resets.
2) Add lightweight logging for `loadBaseline`/`updateDraft` to detect post-tap resets (UITEST-only).
3) Ensure the haptics toggle identifier is only on the UISwitch (no wrapper duplication).
4) Verify controller reuse from episode list and settings; avoid recreating the controller on sheet reopen during UITests.

**Test-side**
1) Align tests to GWT and user outcomes:
   - `SwipeToggleInteractionTests`: assert switch exists/hittable; after toggling, verify debug summary *and* a simple episode swipe reflects the haptics/full-swipe state (observable effect rather than just summary).
   - `SwipeConfigurationUIDisplayTests`: assert baseline UI presence with the correct controller UUID (detect wrong sheet).
   - `SwipeComplexIntegrationTests`: ensure navigation path matches intended user flow; refocus on end-to-end apply/save, not debug seams.
2) Add fast-fail diagnostics: if `app.switches["SwipeActions.Haptics.Toggle"]` is missing, print scoped tree and fail, rather than blind taps.
3) Remove reliance on deprecated auto-scroll/materialization flags in tests; use explicit existence checks tied to the current layout.

**Process**
- Implement observability first (no behavioral change), rerun failing suites, capture evidence.
- Adjust identifiers/controller reuse if evidence confirms misbinding.
- Then update tests to match the intended scenarios and outcomes (GWT), minimizing dependence on internal debug seams.

### PR/dev-log actions
- Document this broader plan (this entry) in dev-log and summarize the same in the PR description before further code/test changes.
- After observability changes land and evidence is collected, outline the concrete code/test edits in the PR summary to keep reviewers aligned with the broader intent.

### Test updates started (11/16)
- Hardened toggle tests to fail fast and align with GWT:
  - `SwipeToggleInteractionTests`: now require the haptics switch to exist before toggling, capture initial toggle + summary state, assert switch state after each toggle, and avoid blind toggles when elements are missing.
  - Helpers: `requireToggleSwitch` and `assertHapticsToggleState` added to enforce existence/hittability and provide diagnostics (with scoped identifier dump on failure).
- No app behavior changes yet; these are test-side safety/clarity improvements to surface the real failure.

## 2025-11-16 — BREAKTHROUGH ANALYSIS: Root Cause & Simplified Solution (ET)

**Context**: After 1+ week of debugging toggle failures with increasingly complex diagnostics, instrumentation, and workarounds, it's time for a fundamental reassessment.

### THE REAL PROBLEM (Hidden in Plain Sight)

**SwipeActionConfigurationView Architecture** has a FATAL FLAW:

```swift
// Current broken architecture:
@ObservedObject private var controller: SwipeConfigurationController
@State private var hapticsEnabledState: Bool  // ⚠️ REDUNDANT STATE

// In init:
self._hapticsEnabledState = State(initialValue: controller.hapticsEnabled)

// Toggle binding:
SettingsToggleRow(
  "Enable Haptic Feedback",
  isOn: $hapticsEnabledState,  // ⚠️ BOUND TO @STATE, NOT CONTROLLER
  accessibilityIdentifier: "SwipeActions.Haptics.Toggle"
) { newValue in
  controller.setHapticsEnabled(newValue)  // ⚠️ CALLBACK UPDATES CONTROLLER
  hapticsToggleProbe = UUID()
  // ...
}

// Sync watcher:
.onReceive(controller.$draft) { draft in
  hapticsEnabledState = draft.swipeActions.hapticFeedbackEnabled  // ⚠️ MANUAL SYNC
}
```

**Why This Is Broken:**

1. **Redundant State**: `@State hapticsEnabledState` duplicates `controller.hapticsEnabled`
2. **Binding Disconnect**: Toggle binds to local `@State`, NOT the @ObservedObject controller
3. **Callback Hell**: onChange callback must manually call controller setter
4. **Race Condition**: Controller update → Combine publisher → onReceive → State update = lag
5. **Test Brittleness**: Tests see stale @State while controller has correct value

**The Architecture We THOUGHT We Had:**
```
Toggle → Binding($controller.hapticsEnabled) → Controller @Published → View updates
```

**The Architecture We ACTUALLY Have:**
```
Toggle → Binding($hapticsEnabledState) → onChange callback → controller.setHapticsEnabled() 
  → controller.draft @Published → onReceive → hapticsEnabledState = newValue
```

**4 LAYERS OF INDIRECTION** when it should be 1!

### THE BREAKTHROUGH SOLUTION

**SIMPLIFY TO DIRECT BINDINGS** (What SwiftUI was designed for):

```swift
// Solution: Remove ALL redundant @State
@ObservedObject private var controller: SwipeConfigurationController
// DELETE: @State private var hapticsEnabledState
// DELETE: @State private var hapticStyleState
// DELETE: @State private var leadingFullSwipe
// DELETE: @State private var trailingFullSwipe

// Direct binding (SwiftUI best practice):
SettingsToggleRow(
  "Enable Haptic Feedback",
  isOn: Binding(
    get: { controller.hapticsEnabled },
    set: { controller.setHapticsEnabled($0) }
  ),
  accessibilityIdentifier: "SwipeActions.Haptics.Toggle"
) { newValue in
  // Side effects only (haptic feedback, logging)
  if newValue { hapticsService.selectionChanged() }
}

// DELETE the entire .onReceive(controller.$draft) block - not needed!
```

**Why This Works:**

1. **Single Source of Truth**: Controller is the ONLY state owner
2. **Direct Binding**: SwiftUI's Binding<T> connects Toggle directly to controller
3. **Automatic Updates**: @ObservedObject/@Published handles all reactivity
4. **No Race Conditions**: No manual sync, no onReceive lag
5. **Testable**: Tests see controller state immediately, no intermediate layers

### ROOT CAUSE ANALYSIS

**How Did We Get Here?**

Looking at git history, the @State variables were added as a "fix" when direct bindings "didn't work". But the real issue was likely:

1. **Controller not @MainActor**: Fixed in recent commits
2. **Missing @Published on draft**: Controller always had this
3. **View not observing controller**: @ObservedObject was always there

The @State "fix" was treating symptoms, not the root cause. Now we have **double state management** causing synchronization bugs.

**Evidence From Test Failures:**

- Controller logs show `setHapticsEnabled` IS called
- Controller `hasUnsavedChanges` IS true after toggle
- Debug summary shows correct controller state
- BUT toggle UI doesn't reflect the change

**Smoking Gun**: The Toggle is bound to `$hapticsEnabledState` (@State), which updates via onReceive AFTER the controller. Tests tap → controller updates → test reads debug summary (correct) → BUT the Toggle's @State hasn't synced yet!

### SIMPLIFIED PLANS

## ❌ OLD PLAN (Complex, Treating Symptoms):
- Add controller UUID tracking
- Add baseline/reset logging  
- Add switch existence checks
- Add tree dumps on failure
- Add materialization probes
- More diagnostics, more complexity

## ✅ NEW PLAN (Simple, Fix Root Cause):

**Phase 1: Remove Redundant State** (1 file edit)
- Delete all @State duplicates from SwipeActionConfigurationView
- Replace with direct Binding(get:set:) to controller
- Delete the .onReceive(controller.$draft) sync watcher
- Keep only side-effect logic in onChange closures

**Phase 2: Verify Controller Is Ready** (sanity check)
- Confirm controller setters call updateDraft() ✅ (already does)
- Confirm controller has @Published var draft ✅ (already does)
- Confirm view has @ObservedObject ✅ (already does)
- Confirm controller/view are @MainActor ✅ (already are)

**Phase 3: Simplify Tests** (reduce complexity)
- Remove `waitForDebugState` polling (controller updates are synchronous)
- Assert toggle state immediately after tap (no race conditions)
- Remove complex toggle value interpretation (SwiftUI handles it)
- Remove materialization workarounds (not needed with direct bindings)

**Expected Result:**
- Toggle tap → Binding.set → controller.setHapticsEnabled() → draft updated → @Published fires → View updates
- **ALL SYNCHRONOUS, NO DELAYS**
- Tests pass immediately, no polling needed

### LESSONS LEARNED

1. **Don't Layer State**: @State + @ObservedObject on same data = trouble
2. **Trust SwiftUI**: Binding(get:set:) is the correct pattern for computed bindings
3. **Test Brittleness Signals Architecture Problems**: If tests need complex polling/waiting, the architecture is wrong
4. **Simplify First**: Adding diagnostics to complex code makes it more complex
5. **Read The Error**: "Toggle doesn't update" = binding problem, not test infrastructure

### ACTION ITEMS

**IMMEDIATE** (Next commit):
1. Refactor SwipeActionConfigurationView to direct bindings
2. Delete @State duplicates and .onReceive sync logic  
3. Run tests - expect immediate pass with no changes needed

**FOLLOWUP** (If tests still fail):
- Then and only then add diagnostics
- But bet: with correct architecture, tests will just work

**CONFIDENCE LEVEL**: 95%

The architecture flaw explains:
- Why controller logs show correct values but Toggle doesn't update
- Why tests need complex polling (waiting for onReceive to sync @State)
- Why reverting to "known-good" code still fails (it always had this flaw)
- Why adding more diagnostics hasn't helped (wrong layer)

**This is the breakthrough**: Stop fighting symptoms, fix the root cause.

---

## 2025-11-16 — Materialization + Haptics Control Recovery Plan (ET) [OBSOLETE - See Breakthrough Above]

**Intent (pre-implementation)**: Resolve current build and runtime flap in SwipeUI suites by (1) restoring deterministic section materialization, (2) fixing the missing `HapticsToggleControl`/wait helper that breaks builds and test discovery, and (3) realigning display/toggle tests to fail fast on navigation/context while asserting user-visible outcomes instead of only debug probes.

### Observations
- `waitForSectionMaterialization()` is referenced (Assertions.swift) and described earlier but not implemented anywhere; navigation no longer waits for materialization.
- `UITEST_SWIPE_PRELOAD_SECTIONS` remains in the launch environment even though the view no longer scrolls/materializes sections when the flag is set.
- `SwipeActionConfigurationView` references `HapticsToggleControl`, which is missing, blocking a successful build and preventing the haptics toggle from entering the accessibility tree.
- `SwipeConfigurationUIDisplayTests` still relies on manual navigation and debug summary assertions; it does not fail fast if the sheet/container isn’t present, so it can search the episode list tree for minutes before failing.

### Plan
1) Implement `waitForSectionMaterialization(timeout:)` in test support and call it from `openSwipeConfigurationSheet()` + assertions; wait on a real element (e.g., `SwipeActions.Haptics.Toggle`) rather than time-based delays.
2) Reintroduce UITest-only materialization in `SwipeActionConfigurationView` gated by `UITEST_SWIPE_PRELOAD_SECTIONS` (e.g., `ScrollViewReader` auto-scroll or forced evaluation) so haptics/preset sections enter the accessibility tree deterministically.
3) Replace the missing toggle control with a concrete, accessible implementation (likely `SettingsToggleRow` or a SwiftUI `Toggle`) ensuring the `SwipeActions.Haptics.Toggle` identifier sits on the UISwitch.
4) Harden `SwipeConfigurationUIDisplayTests` to use the shared navigation helper, assert the sheet container + controller UUID, and fast-fail with scoped tree dumps if the sheet isn’t present before any list assertions. Require the Haptics section (header + toggle + style picker) to exist; if missing after materialization, fail immediately with diagnostics instead of repeated searches.
5) Make materialization observable: add a `Materialized` bit to the debug summary/probe and have tests wait on that (≤1–2s) rather than time-based guesses. If `Materialized=1` but `SwipeActions.Haptics.Toggle` is still missing, treat it as an app rendering bug and abort early.
6) Shift toggle assertions toward user-outcome validation (e.g., sample swipe/haptic state) while retaining debug probes for diagnostics; convert manual polling to `XCTNSPredicateExpectation` where possible to align with XCTest async guidance. Keep waits short and targeted; don’t increase global suite timeouts to mask rendering issues.
