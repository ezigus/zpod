# Dev Log: Issue 03.3.4.3 - Expanded Player Error UI

**Issue**: [#320](https://github.com/ezigus/zpod/issues/320)  
**Branch**: `03.3.4.3-expanded-player-error-ui`  
**Status**: üöß In Progress  
**Started**: 2026-01-08 15:29 ET

## Design Analysis

### Current State

**ExpandedPlayerViewModel**:
- Uses individual `@Published` properties (`episode`, `isPlaying`, `currentPosition`, `duration`)
- No error state exposure
- `handlePlaybackStateChange` switches on `EpisodePlaybackState` but doesn't track errors

**ExpandedPlayerView**:
- Always shows: artwork, metadata, progress slider, transport controls
- No error state UI
- Uses `ZStack` with gradient background

### Lessons from 03.3.4.2 (Mini-Player)

‚úÖ **What worked well:**
- Adding `error` field to display state struct
- Unified card layout with conditional content
- Comprehensive unit tests before implementation
- Accessibility-first approach (children combine, hidden redundant elements)

‚ö†Ô∏è **What to improve:**
- Don't duplicate layouts - design unified structure upfront
- Test error clearing on ALL state transitions from the start
- Verify accessibility with specific labels immediately

### Design Strategy

**Unlike mini-player**, expanded player should:
1. **Replace entire content** when error occurs (not overlay)
2. **Use prominent, centered layout** (more space available)
3. **Show episode context** below error (user knows what failed)
4. **Maintain same background/structure** (consistent feel)

**Architecture Decision:**
- Add `@Published var currentError: PlaybackError?` to ViewModel
- Create `errorView` that replaces normal content (not overlays it)
- Use conditional in body: `if currentError != nil { errorView } else { normalView }`

## Technical Design

### Phase 1: ViewModel Changes

```swift
// ExpandedPlayerViewModel.swift

@Published public private(set) var currentError: PlaybackError?

private func handlePlaybackStateChange(_ state: EpisodePlaybackState) {
  switch state {
  case .idle(let episode):
    currentError = nil
    self.episode = episode
    // ... existing

  case .playing(let episode, let position, let duration):
    currentError = nil  // Clear error on successful playback
    // ... existing

  case .paused(let episode, let position, let duration):
    currentError = nil  // Clear error on successful pause
    // ... existing

  case .finished(let episode, let duration):
    currentError = nil  // Clear error on finish
    // ... existing

  case .failed(let episode, let position, let duration, let error):
    self.episode = episode
    self.isPlaying = false
    self.currentPosition = position
    self.duration = duration
    self.currentError = error  // NEW: expose error
  }
}

@MainActor
func retryPlayback() {
  guard currentError != nil, let episode = episode else { return }
  let position = currentPosition
  let resolvedDuration = duration > 0 ? duration : episode.duration
  playbackService.play(episode: episode, duration: resolvedDuration)
  if position > 0 {
    playbackService.seek(to: position)
  }
}
```

### Phase 2: View Changes

```swift
// ExpandedPlayerView.swift

public var body: some View {
  GeometryReader { geometry in
    ZStack(alignment: .top) {
      // Background (always shown)
      gradientBackground
      
      if let error = viewModel.currentError {
        // Error state - replace entire content
        errorView(error: error, geometry: geometry)
      } else {
        // Normal player state
        normalPlayerView(geometry: geometry)
      }
      
      // Overlays (debug, alerts) stay on top
      debugAndAlertOverlays(geometry: geometry)
    }
  }
}

@ViewBuilder
private func errorView(error: PlaybackError, geometry: GeometryProxy) -> some View {
  VStack(spacing: 0) {
    dragIndicator
    
    Spacer()
    
    VStack(spacing: 24) {
      // Large error icon
      Image(systemName: "exclamationmark.triangle.fill")
        .font(.system(size: 64))
        .foregroundColor(.red)
        .accessibilityHidden(true)
      
      // Error message
      VStack(spacing: 12) {
        Text("Playback Error")
          .font(.title2.bold())
          .foregroundColor(.white)
        
        Text(error.userMessage)
          .font(.body)
          .foregroundColor(.white.opacity(0.85))
          .multilineTextAlignment(.center)
          .padding(.horizontal, 40)
      }
      
      // Retry button (if recoverable)
      if error.isRecoverable {
        Button {
          viewModel.retryPlayback()
        } label: {
          Label("Retry Playback", systemImage: "arrow.clockwise")
            .font(.headline)
        }
        .buttonStyle(.borderedProminent)
        .controlSize(.large)
        .tint(.white)
        .accessibilityIdentifier("ExpandedPlayer.RetryButton")
        .accessibilityLabel("Retry playback")
      }
      
      // Episode context
      if let episode = viewModel.episode {
        VStack(spacing: 6) {
          Text(episode.title)
            .font(.subheadline)
            .foregroundColor(.white.opacity(0.7))
            .lineLimit(2)
          
          Text(episode.podcastTitle)
            .font(.caption)
            .foregroundColor(.white.opacity(0.5))
            .lineLimit(1)
        }
        .padding(.top, 32)
        .multilineTextAlignment(.center)
      }
    }
    .padding(.horizontal, 32)
    
    Spacer()
  }
  .padding(.top, 8)
  .padding(.bottom, max(20, geometry.safeAreaInsets.bottom))
  .accessibilityElement(children: .contain)
  .accessibilityIdentifier("ExpandedPlayer.ErrorView")
}
```

### Phase 3: Testing Strategy

**Unit Tests** (add to ExpandedPlayerViewModelTests.swift):
1. `testCurrentErrorExposedOnFailure` - Error set on `.failed` state
2. `testCurrentErrorClearedOnPlaying` - Error cleared on successful playback
3. `testCurrentErrorClearedOnPaused` - Error cleared on pause
4. `testCurrentErrorClearedOnFinished` - Error cleared on finish
5. `testCurrentErrorClearedOnIdle` - Error cleared on idle
6. `testRetryPlaybackCallsPlayAndSeek` - Retry triggers correct calls
7. `testRetryPlaybackIgnoredWhenNoError` - Guard when no error
8. `testRetryPlaybackIgnoredWhenNoEpisode` - Guard when no episode

**Test Doubles Enhancement**:
- Extend `RecordingPlaybackService` to track retry attempts
- Add `lastPlayedEpisode`, `lastSeekPosition`, `seekCallCount`

## Implementation Checklist

### ViewModel
- [x] Add `@Published var currentError: PlaybackError?`
- [x] Update `.failed` case to set `currentError`
- [x] Update all non-error cases to clear `currentError = nil`
- [x] Add `retryPlayback()` method with guards
- [x] Add unit tests (8 tests)

### View
- [x] Extract `normalPlayerView(geometry:)` helper
- [x] Create `errorView(error:geometry:)` helper
- [x] Update body to conditionally show error vs normal
- [x] Ensure error icon is `.accessibilityHidden(true)`
- [x] Add `.accessibilityElement(children: .contain)` to error view
- [x] Add explicit labels to retry button

### Accessibility
- [x] Error view uses `.contain` children
- [x] Retry button has explicit "Retry playback" label
- [x] Error icon hidden from VoiceOver
- [ ] Test VoiceOver reads: "Playback Error. [message]. Retry playback, button. [Episode context]"

### Testing
- [x] All 8 unit tests passing
- [x] No regressions in existing ExpandedPlayer tests
- [ ] Manual verification with simulator VoiceOver

## Acceptance Criteria Tracking

From Issue 03.3.4.3:

### ViewModel Changes
- [x] `ExpandedPlayerViewModel` has new `@Published var currentError: PlaybackError?` property
- [x] `handlePlaybackStateChange(.failed)` sets `currentError` to the error
- [x] All non-error states (`.idle`, `.playing`, `.paused`, `.finished`) set `currentError = nil`
- [x] `retryPlayback()` method added to `ExpandedPlayerViewModel`

### View Changes
- [x] Error view appears in expanded player when `viewModel.currentError != nil`
- [x] Large error icon (64pt) is visible
- [x] "Playback Error" title is shown
- [x] Error message uses `PlaybackError.userMessage`
- [x] Retry button appears only for `isRecoverable` errors
- [x] Retry button triggers `retryPlayback()` in viewmodel
- [x] Episode title/podcast shown for context
- [x] Normal playback controls are hidden during error state
- [x] Error view has accessibility identifier `ExpandedPlayer.ErrorView`
- [x] Retry button has accessibility identifier `ExpandedPlayer.RetryButton`
- [ ] VoiceOver reads error state appropriately (needs manual verification)
- [x] Error clears when new episode starts playing (currentError becomes nil)

## Related Work

- **03.3.4.1** - PlaybackError enum (dependency) ‚úÖ Complete
- **03.3.4.2** - Mini-player error UI (parallel) ‚úÖ Complete
- **03.3.4.4** - AVPlayer error detection (provides errors) ‚è≥ Pending
- **03.3.4.5** - Complete edge-case tests (integration) ‚è≥ Pending

---

## Implementation Log

### 2026-01-08 15:29 ET ‚Äî Phase 1: ViewModel (TDD)

**Commit:** fb41517

Followed strict TDD - wrote 8 failing tests first, then implemented to pass.

**Changes:**
- Added `@Published var currentError: PlaybackError?`
- Updated `handlePlaybackStateChange` to set/clear error on all transitions
- Added `retryPlayback()` method with proper guards
- All 46 tests passing ‚úÖ

### 2026-01-08 15:35 ET ‚Äî Phase 2: View Implementation

**Commit:** 3992103

Refactored view to conditionally show error vs normal content, following design from dev-log.

**Changes:**
- Extracted `gradientBackground`, `normalPlayerView`, `debugAndAlertOverlays` helpers
- Created `errorView` with prominent centered error display
- Accessibility-first approach (children combine, explicit labels, hidden icon)
- Zero code duplication between states
- All 46 tests still passing ‚úÖ

**Implementation complete!** Ready for manual testing and acceptance criteria verification.
