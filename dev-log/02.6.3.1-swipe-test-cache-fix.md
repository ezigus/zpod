# Issue #02.6.3.1 - Swipe Configuration Test Cache Fix

**Issue**: CI-only failures in 3 swipe UI test suites due to stale element cache
**Branch**: `copilot/decompose-swipeconfiguration-ui-tests`
**PR**: #134
**Date**: 2025-01-22

## Problem Summary

### Failing Tests (CI Only)

1. `SwipeConfigurationUIDisplayTests` - 3 tests
2. `SwipePresetSelectionTests` - 3 tests  
3. `SwipeExecutionTests` - 1 test

### Root Cause

The test infrastructure caches the sheet container element (`cachedSwipeContainer`) and assumes it remains valid throughout test execution. In CI, SwiftUI appears to dismiss/recreate the sheet between operations, invalidating the cached `XCUIElement` reference.

**Key failure patterns**:

- "No matches found for first query match sequence: Elements matching predicate 'SwipeActions.List' IN identifiers"
- "Swipe configuration sheet container unavailable while applying preset"

### Why It Only Failed in CI

- Local tests run faster with warmer simulators
- CI has additional pre-warming script overhead (~30s of spawning process retries)
- CI simulators are freshly provisioned per job
- Timing differences cause SwiftUI to invalidate/recreate sheets more frequently

## Solution: Eliminate Cache Assumptions

Instead of trusting a cached element, **always re-discover the sheet container** when needed. This is deterministic because it relies on query existence checks, not time-based waits.

### Changes Made

#### 1. `SwipeConfigurationTestSupport+SheetUtilities.swift`

**Removed cache trust** - Always verify sheet exists before returning:

```swift
@MainActor
func swipeActionsSheetListContainer() -> XCUIElement? {
  // Always re-discover instead of trusting cache - SwiftUI may recreate the sheet
  let save = app.buttons.matching(identifier: "SwipeActions.Save").firstMatch
  let cancel = app.buttons.matching(identifier: "SwipeActions.Cancel").firstMatch
  guard
    save.exists || cancel.exists
      || app.staticTexts.matching(identifier: "Swipe Actions").firstMatch.exists
  else {
    return nil
  }
  // ... discovery logic continues ...
}
```

**Key**: Removed `if let cached = cachedSwipeContainer, cached.exists { return cached }` check.

#### 2. `SwipeConfigurationTestSupport+Navigation.swift`

**Changed reuse logic** - Always call discovery function instead of returning cached element:

```swift
@MainActor
@discardableResult
func reuseOrOpenConfigurationSheet(resetDefaults: Bool = false) throws -> XCUIElement? {
  if resetDefaults {
    cachedSwipeContainer = nil
    return try openConfigurationSheetReady(resetDefaults: resetDefaults)
  }
  // Try to discover existing sheet first
  if let container = swipeActionsSheetListContainer() {
    return container
  }
  // Sheet not found, open it
  return try openConfigurationSheetReady(resetDefaults: resetDefaults)
}
```

**Key**: Changed from `if let cached = cachedSwipeContainer, cached.exists` to calling `swipeActionsSheetListContainer()`.

#### 3. `SwipeConfigurationTestSupport+ActionManagement.swift`

**Improved error message** to clarify when sheet is missing:

```swift
@MainActor
func applyPreset(identifier: String) {
  // ... debug overlay checks ...
  
  // Re-discover container to handle sheet state changes
  guard let container = swipeActionsSheetListContainer() else {
    XCTFail("Swipe configuration sheet not found. Sheet may have been dismissed or not yet opened.")
    return
  }
  // ... rest of method ...
}
```

## Why This Is Deterministic

✅ **No waits** - Uses only synchronous `exists` checks on query results
✅ **No timeouts** - Either element exists now or it doesn't  
✅ **No timing dependencies** - Discovery is query-based, not time-based
✅ **Handles SwiftUI lifecycle** - Re-discovers sheet every time, catching recreation

## Testing Plan

### Local Validation

```bash
# Run each failing test suite individually
./scripts/run-xcode-tests.sh -t zpodUITests/SwipeConfigurationUIDisplayTests
./scripts/run-xcode-tests.sh -t zpodUITests/SwipePresetSelectionTests  
./scripts/run-xcode-tests.sh -t zpodUITests/SwipeExecutionTests

# Run full regression
./scripts/run-xcode-tests.sh
```

### CI Validation

Push to PR #134 and verify all 3 swipe test suites pass in the `ui-tests-swipe` matrix job.

## Architecture Notes

### Cache Still Exists (For Now)

The `cachedSwipeContainer` variable still exists and is set in `openConfigurationSheetReady()`, but it's no longer trusted as the source of truth. This allows for potential future optimization if we determine the cache is reliable in certain contexts.

### Future Consideration

If this pattern proves stable, consider removing `cachedSwipeContainer` entirely and always use fresh queries. The discovery logic already has multiple fallback strategies, so performance impact should be minimal.

## Acceptance Criteria

- [x] Changes compile without errors
- [ ] Local test runs pass consistently
- [ ] CI test runs pass in PR #134
- [ ] No new `waitForExistence()` calls added
- [ ] Solution uses only deterministic query checks

## Related Documentation

- PR #134: "[#02.6.3] Hybrid tier architecture for swipe UI tests"
- Root cause analysis in GitHub Actions run 19597330948 logs
- AGENTS.md terminal command guidelines (no waits, no background execution)

## 2025-11-24 11:34 ET – Implementation and rediscovery hardening

- Removed all reliance on `cachedSwipeContainer` when reusing the configuration sheet; `reuseOrOpenConfigurationSheet` now re-discovers before opening and resets both the cache and `sectionsMaterialized` flag when defaults are reset.
- `swipeActionsSheetListContainer()` always performs fresh queries and `ensureVisibleInSheet` now refreshes the container/target before every scroll, keeping the scroll surface valid when SwiftUI rebuilds the sheet.
- Debug helpers standardized to a 2s timeout with early validator exit; toggle assertions drop the retry loop and rely on the refreshed container plus debug state consistency.
- Added `sectionsMaterialized` guard to run section materialization only once per test, with reset on cache clear to avoid stale state across test-level relaunches.
- Next: run targeted swipe suites and full regression to validate the rediscovery path; update acceptance criteria with results.
