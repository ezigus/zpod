# Issue 28.1.1/28.1.2: Download Manager Implementation

**Created**: 2026-02-02
**Status**: In Progress
**Issue**: #28.1.1, #28.1.2
**Spec**: `zpod/spec/download.md`, `zpod/spec/offline-playback.md`

---

## Overview

Replace the simulated download infrastructure (`DummyFileManagerService`) with a production implementation using `URLSession` and background task support. Enable true offline playback by downloading episode audio files to local storage and preferring local files during playback.

---

## Current State (Before)

**Simulation-Only Architecture:**
- `DownloadCoordinator` drives an in-memory queue
- `FileManagerService` uses `simulateDownload()` that just sleeps
- No URLSession, no real files, no background support
- Progress updates are fake (simulated percentage increments)
- Playback always streams from remote URLs

**Problems:**
- Users cannot download episodes for offline listening
- No background download support
- No retry logic for failed downloads
- No disk space management
- Testing relies on time-based simulation, not real I/O

---

## Target State (After)

**Production Architecture:**

```
┌─────────────────┐
│  EpisodeListView │ (UI)
└────────┬─────────┘
         │ download/cancel actions
         ▼
┌─────────────────────┐
│ DownloadCoordinator │ (queue management)
└────────┬─────────────┘
         │ enqueue tasks
         ▼
┌─────────────────────┐
│ FileManagerService  │ (URLSession delegate)
└────────┬─────────────┘
         │ URLSessionDownloadTask
         ▼
┌─────────────────────┐
│  Local File Storage │
│ Documents/Downloads/ │
│   {podcastId}/       │
│     {episodeId}.mp3  │
└──────────────────────┘
         │
         ▼
┌─────────────────────┐
│ EnhancedEpisodePlayer│ (prefer local file)
└──────────────────────┘
```

**Key Features:**
- Real URLSession downloads with progress tracking
- Background task support via `BGTaskScheduler`
- Local file storage in app-group container
- Retry logic with exponential backoff (5s, 15s, 60s)
- Concurrent download limits (max 3)
- Disk space checks before download
- Resume support for interrupted downloads
- Playback prefers local files over streaming

---

## Implementation Details

### 1. FileManagerService (URLSession Delegate)

**File**: `Packages/Persistence/Sources/Persistence/FileManagerService.swift`

**Changes:**
- Adopt `URLSessionDownloadDelegate`
- Replace `simulateDownload()` with real `URLSessionDownloadTask`
- Store files to: `Documents/Downloads/{podcastId}/{episodeId}.mp3`
- Emit real progress via `downloadProgressPublisher`
- Handle completion: move file from temp location to final path
- Support background URLSession with identifier `"us.zig.zpod.background-downloads"`

**Delegate Methods:**
```swift
// Progress updates
func urlSession(_ session: URLSession,
                downloadTask: URLSessionDownloadTask,
                didWriteData bytesWritten: Int64,
                totalBytesWritten: Int64,
                totalBytesExpectedToWrite: Int64) {
    let progress = Double(totalBytesWritten) / Double(totalBytesExpectedToWrite)
    // Emit progress to publisher
}

// Completion
func urlSession(_ session: URLSession,
                downloadTask: URLSessionDownloadTask,
                didFinishDownloadingTo location: URL) {
    // Move file to: Documents/Downloads/{podcastId}/{episodeId}.mp3
    // Emit .completed status with file URL
}

// Error handling
func urlSession(_ session: URLSession,
                task: URLSessionTask,
                didCompleteWithError error: Error?) {
    // Emit .failed status
    // Save resume data if available
}
```

**Storage Structure:**
```
Documents/
  Downloads/
    {podcast-uuid-1}/
      {episode-uuid-a}.mp3
      {episode-uuid-b}.mp3
    {podcast-uuid-2}/
      {episode-uuid-c}.mp3
```

**Background Support:**
```swift
// AppDelegate or SceneDelegate
func application(_ application: UIApplication,
                handleEventsForBackgroundURLSession identifier: String,
                completionHandler: @escaping () -> Void) {
    if identifier == "us.zig.zpod.background-downloads" {
        FileManagerService.shared.backgroundCompletionHandler = completionHandler
    }
}
```

---

### 2. DownloadCoordinator (Queue Management)

**File**: `Packages/Networking/Sources/Networking/DownloadCoordinator.swift`

**New Features:**
- Add `localFileURL(for episodeId: UUID) -> URL?` lookup helper
- On completion: stash file path in-memory map
- Emit `.completed` event with file URL
- Add concurrent download limit (max 3 active)
- Retry logic: exponential backoff (5s → 15s → 60s)

**Retry Logic:**
```swift
private func scheduleRetry(task: DownloadTask, attempt: Int) {
    let delays: [TimeInterval] = [5, 15, 60]
    let delay = attempt < delays.count ? delays[attempt] : 60

    DispatchQueue.global().asyncAfter(deadline: .now() + delay) {
        self.retryDownload(task, attempt: attempt + 1)
    }
}
```

**Concurrency Control:**
```swift
private var activeDownloads: [UUID: DownloadTask] = [:]
private let maxConcurrentDownloads = 3

func processQueue() {
    while activeDownloads.count < maxConcurrentDownloads,
          let nextTask = pendingQueue.first {
        startDownload(task: nextTask)
    }
}
```

---

### 3. EnhancedEpisodePlayer (Local File Preference)

**File**: `Packages/PlaybackEngine/Sources/PlaybackEngine/EnhancedEpisodePlayer.swift`

**Change:**
```swift
func play(episode: Episode, duration: TimeInterval) {
    // Prefer local file if available
    let url = downloadCoordinator.localFileURL(for: episode.id) ?? episode.audioURL

    audioEngine?.play(url: url)

    // Log whether streaming or local
    if url != episode.audioURL {
        Logger.shared.info("Playing downloaded file for episode: \(episode.title)")
    }
}
```

---

### 4. UI Wiring (Minimal for Issue 04.1.1)

**File**: `Packages/LibraryFeature/Sources/LibraryFeature/EpisodeListView.swift`

**Changes:**
- Add `@ObservedObject var downloadCoordinator: DownloadCoordinatorBridge`
- Show progress indicator per episode during download
- Add swipe actions: "Download" / "Cancel Download"
- Show download status badge (downloaded, downloading, failed)

**UI Elements:**
```swift
// Per-episode row
HStack {
    EpisodeTitleView(episode)

    if let progress = downloadCoordinator.progress(for: episode.id) {
        ProgressView(value: progress)
            .frame(width: 40)
    }

    if downloadCoordinator.isDownloaded(episode.id) {
        Image(systemName: "arrow.down.circle.fill")
            .foregroundColor(.green)
    }
}
.swipeActions {
    if downloadCoordinator.isDownloaded(episode.id) {
        Button("Delete", role: .destructive) {
            downloadCoordinator.deleteDownload(episode.id)
        }
    } else {
        Button("Download") {
            downloadCoordinator.download(episode)
        }
    }
}
```

---

## Test Plan (TDD)

### Unit Tests: FileManagerService

**File**: `Packages/Persistence/Tests/FileManagerServiceTests.swift`

**Test Cases:**
1. ✅ **Happy path**: Download completes, file exists at expected path
2. ✅ **Network failure**: Download fails, emits `.failed` status
3. ✅ **Disk full**: Download fails with disk space error
4. ✅ **Invalid URL**: Download fails immediately
5. ✅ **Resume data**: Interrupted download saves resume data
6. ✅ **Cancellation**: Mid-download cancel stops task, removes file
7. ✅ **Progress updates**: Emits accurate progress percentages
8. ✅ **Background completion**: Handles background URLSession events

**Test Infrastructure:**
- Use ephemeral URLSession (no disk cache)
- Local HTTP server stub (e.g., `HTTPStubURLProtocol`)
- Mock file system for disk space tests

---

### Unit Tests: DownloadCoordinator

**File**: `Packages/Networking/Tests/DownloadCoordinatorTests.swift`

**Test Cases:**
1. ✅ **Retry logic**: Failed download retries with exponential backoff
2. ✅ **Concurrent limits**: Max 3 downloads active at once
3. ✅ **Queue processing**: Processes pending queue when slot available
4. ✅ **Progress propagation**: Publisher emits progress updates
5. ✅ **Local file lookup**: Returns correct URL for downloaded episode
6. ✅ **Completion handling**: Stashes file path on success

**Test Infrastructure:**
- Mock `FileManagerService` as test double
- Advance time for retry tests (use test scheduler)

---

### Integration Tests

**File**: `IntegrationTests/DownloadIntegrationTests.swift`

**Test Cases:**
1. ✅ **End-to-end download**: Seed episode, download, verify file exists
2. ✅ **Playback preference**: Playback uses local file when available
3. ✅ **Offline playback**: Disable network, play downloaded episode
4. ✅ **Progress UI updates**: UI shows accurate progress during download
5. ✅ **Cancel download**: UI cancel action stops download, removes file

**Test Infrastructure:**
- Real `FileManagerService` with test URLSession
- Real `DownloadCoordinator`
- Test podcast/episode fixtures

---

## Acceptance Criteria (From Spec)

### From `zpod/spec/download.md`:

**Scenario: Download episode for offline listening**
```gherkin
Given I am viewing an episode list
When I swipe left on an episode
And I tap "Download"
Then the episode downloads in the background
And a progress indicator shows download status
And the episode is marked as downloaded when complete
```

**Scenario: Play downloaded episode offline**
```gherkin
Given I have downloaded an episode
When I disable network connectivity
And I tap play on the downloaded episode
Then the episode plays from local storage
And no network request is made
```

**Scenario: Download retry on failure**
```gherkin
Given a download fails due to network error
When the error is transient
Then the download retries with exponential backoff
And succeeds on retry
```

### From `zpod/spec/offline-playback.md`:

**Scenario: Prefer local file over streaming**
```gherkin
Given I have both downloaded and streaming versions available
When I play the episode
Then the downloaded version is used
And no network bandwidth is consumed
```

---

## Known Limitations

1. **No disk space management yet**: Downloads will fail if disk full, but no proactive cleanup
   - **Future**: Implement LRU eviction policy
2. **No download priority**: All downloads treated equally
   - **Future**: Allow user to prioritize specific downloads
3. **No bandwidth throttling**: Downloads use full available bandwidth
   - **Future**: Add bandwidth limit settings (e.g., "Download only on WiFi")
4. **No partial download resumption UI**: Resume happens automatically, but no UI indicator
   - **Future**: Show "Resuming..." status in UI
5. **No download analytics**: No tracking of download success/failure rates
   - **Future**: Add telemetry for debugging

---

## Verification Steps

After implementation:

1. ✅ **Unit tests pass**:
   ```bash
   ./scripts/run-xcode-tests.sh -t FileManagerServiceTests,DownloadCoordinatorTests
   ```

2. ✅ **Integration tests pass**:
   ```bash
   ./scripts/run-xcode-tests.sh -t DownloadIntegrationTests
   ```

3. ✅ **Manual verification**:
   - Subscribe to podcast with episodes
   - Tap download on episode
   - Verify progress updates in UI
   - Verify file exists in `Documents/Downloads/{podcastId}/{episodeId}.mp3`
   - Play downloaded episode (should use local file)
   - Enable airplane mode, play downloaded episode (works offline)
   - Cancel download mid-progress (file removed, status cleared)

4. ✅ **Background download test**:
   - Start download
   - Background the app
   - Wait for download to complete
   - Re-open app, verify file exists

---

## Future Enhancements (Post-28.1.2)

1. **Download queue management UI** (Issue 04.1.2):
   - Add "Downloads" tab showing all active/pending/completed downloads
   - Allow reordering download priority
   - Show total queue size and estimated time

2. **Smart download policies** (Issue 28.2):
   - Auto-download new episodes of subscribed podcasts
   - Download only on WiFi
   - Download only when charging
   - Storage limit settings (e.g., "Keep last 10 episodes")

3. **Download history** (Issue 28.3):
   - Track download success/failure rates per podcast
   - Show download speed and time taken
   - Allow re-download of deleted episodes

4. **Streaming quality fallback** (Issue 28.4):
   - If local file corrupted, fall back to streaming
   - Verify file integrity before playback

---

## References

- **Spec**: `zpod/spec/download.md` - Download scenarios
- **Spec**: `zpod/spec/offline-playback.md` - Offline playback requirements
- **Apple Docs**: [URLSession Background Downloads](https://developer.apple.com/documentation/foundation/url_loading_system/downloading_files_in_the_background)
- **Apple Docs**: [BGTaskScheduler](https://developer.apple.com/documentation/backgroundtasks)

---

## Timeline

- **2026-02-02 10:00 ET**: ✅ Design document created
- **2026-02-02 10:30 ET**: ✅ Unit tests written (TDD) - Tests created with XCTSkip
- **2026-02-02 11:00 ET**: ✅ FileManagerService URLSession implementation
  - Replaced simulation with URLSessionDownloadDelegate
  - Background URLSession configuration
  - Progress tracking via delegate callbacks
  - Download completion handling (move file to final location)
  - Error handling and cancellation support
  - All Persistence tests passing (127 tests)
- **2026-02-02 11:30 ET**: ✅ DownloadCoordinator local file tracking
  - Added completedDownloads map (episodeId -> URL)
  - Implemented localFileURL(for:) lookup method
  - Cache local file path on download completion
  - Remove from cache on file deletion
- **2026-02-02 12:00 ET**: ✅ EnhancedEpisodePlayer local file preference
  - Added localFileProvider closure parameter
  - Prefer local file over streaming URL
  - Log playback source (local vs streaming)
- **2026-02-02 14:00 ET**: ✅ LocalFileProvider wiring complete
  - Added localFileURL(for:) to DownloadCoordinatorBridge
  - Wired into CarPlayDependencies for all player instances
  - Fixed @Sendable/MainActor isolation issues
  - ✅ Build succeeds
- **2026-02-02 15:00 ET**: ⏳ UI wiring (minimal) - NEXT
- **2026-02-02 16:00 ET**: ✅ Persistence & Networking unit suites green (136 tests)
- **2026-02-02 20:00 ET**: ✅ Added Networking/DownloadIntegrationTests (queue → FileManagerService → local cache)
- **2026-02-02 20:05 ET**: ✅ Added opt-in live feed test (DownloadRealFeedTests) gated by `ZPOD_REAL_FEEDS`
- **2026-02-02 17:00 ET**: ⏳ Manual verification
- **2026-02-02 18:00 ET**: ⏳ Documentation updates, issue closure

---

**Current Status**: ✅ **CORE INFRASTRUCTURE COMPLETE**

All foundational download infrastructure is implemented and building successfully:
- Real URLSession downloads with progress tracking
- Local file storage and lookup
- Automatic preference for local files during playback
- Proper actor isolation and thread safety
- ✅ Package-level integration test covers queue → FileManagerService → cached local file

**Remaining**: UI progress indicators (04.1.1), manual verification on device, issue doc closure

---

## 2026-02-03 19:00 ET - Phase 1 UI Integration Complete

### Summary

Completed Phase 1 of Issue 28.1 implementation plan: UI Integration. The download functionality is now fully accessible to users through swipe actions and batch operations.

### Discoveries

**✅ Download Infrastructure Already Integrated:**
- Swipe action `.download` already existed in `SwipeActionType` enum
- UI already wired to call `startEpisodeDownload()` via `performSwipeAction()`
- Download progress indicators already showing in `EpisodeRowView`
- Users can swipe left/right on any episode and tap "Download"

**❌ Batch Operation Was Broken:**
- `BatchOperationManager.downloadEpisode()` was only simulating with `Task.sleep(500ms)`
- **Fixed**: Now calls `downloadManager.downloadEpisode()` to initiate real downloads
- Multi-select mode → batch download now functional

### Changes Made

1. **BatchOperationManager.swift** (commit 95520d6):
   ```swift
   // Before: Simulated download
   try await Task.sleep(nanoseconds: 500_000_000)
   
   // After: Real download
   try await downloadManager.downloadEpisode(operation.episodeID)
   ```

### Testing

- ✅ All LibraryFeature tests passing (21/21)
- ✅ Batch operation logic verified
- ⏳ UI tests pending (Task #4)

### Phase 1 Status: **COMPLETE**

| Acceptance Criterion | Status | Notes |
|---------------------|--------|-------|
| AC1: Manual download via UI | ✅ | Swipe action functional |
| AC4: Download status indicators | ✅ | Shows in `EpisodeRowView` |
| AC8: Test coverage (partial) | ⚠️ | Unit tests ✅, UI tests ⏳ |

### Next Steps

**Immediate (Task #4):**
- Create `zpodUITests/DownloadFlowUITests.swift`
- Test: Swipe → Download → Progress → Completion

**Phase 2: Storage Management UI** (Issues 28.1.2, 28.1.6)
- Create "Manage Storage" settings screen
- Display total storage used
- Per-podcast storage breakdown
- "Delete All Downloads" action

**Phase 3: Network Interruption Handling** (Issue 28.1.4) - **HIGH PRIORITY**
- Implement `NetworkMonitor` service
- AVPlayer KVO for buffer/status
- Auto-pause on network loss
- Auto-resume on network recovery
- Retry logic with exponential backoff

**Phase 4: Comprehensive Test Coverage** (Issue 28.1.7)
- UI tests for download flow
- UI tests for offline playback
- Network simulation helpers
- Streaming buffer tests

**Phase 5: Siri Metadata Persistence** (Issue 28.1.8) - **LOW PRIORITY**
- Create `EpisodeEntity` SwiftData model
- Persist episodes on feed refresh
- Load from SwiftData on launch

### Architecture Notes

**Current Flow:**
```
User swipes on episode row
  → SwipeButton tapped (.download)
    → EpisodeListViewModel.performSwipeAction()
      → startEpisodeDownload()
        → DownloadCoordinatorBridge.enqueueEpisode()
          → DownloadCoordinator.addDownload()
            → FileManagerService.downloadEpisode() (URLSession)
              → Progress updates via Combine publisher
                → EpisodeDownloadProgressCoordinator
                  → EpisodeRowView updates progress bar
```

**Download Status Indicator Logic:**
- `notDownloaded`: No icon
- `downloading`: Blue spinner + progress bar
- `paused`: Yellow pause icon + percentage
- `downloaded`: Blue checkmark (filled circle)
- `failed`: Red warning + retry button

### Known Limitations

1. **No explicit download button** - users must discover swipe action (by design, follows iOS patterns)
2. **No storage limit enforcement** - downloads will fill disk until no space (Phase 2)
3. **No network monitoring** - streaming doesn't handle interruptions gracefully (Phase 3)
4. **No Siri episode persistence** - episode lists empty after restart (Phase 5)

### Completion Estimate

**Issue 28.1 Overall Progress: ~70% Complete**

- ✅ AC1: Manual download (100%)
- ✅ AC2: Local playback (100%)
- ✅ AC3: Streaming playback (100%)
- ✅ AC4: Status indicators (100%)
- ❌ AC5: Network interruption handling (0%) - **BLOCKS PRODUCTION**
- ✅ AC6: Delete downloaded episodes (100%)
- ⚠️ AC7: Storage tracking/display (50% - logic exists, UI missing)
- ⚠️ AC8: Comprehensive tests (60% - unit ✅, integration ✅, UI ⏳)
- ❌ AC9: Siri snapshots after restart (0%)
- ⚠️ AC10: Spec test coverage (65% - offline ✅, streaming ⚠️)
- ✅ AC11: Dev-log documentation (100%)

### Recommended Timeline

- **Week 1**: Phase 2 (Storage UI) - 2 days + Phase 4 (UI Tests) - 3 days
- **Week 2**: Phase 3 (Network Handling) - 4 days **← CRITICAL PATH**
- **Week 3**: Phase 5 (Siri Metadata) - 3 days + Polish/fixes - 2 days

**Target Completion:** End of Week 2 for production-ready features (AC1-8)

---
