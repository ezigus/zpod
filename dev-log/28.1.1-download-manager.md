# Issue 28.1.1/28.1.2: Download Manager Implementation

**Created**: 2026-02-02
**Status**: In Progress
**Issue**: #28.1.1, #28.1.2
**Spec**: `zpod/spec/download.md`, `zpod/spec/offline-playback.md`

---

## Overview

Replace the simulated download infrastructure (`DummyFileManagerService`) with a production implementation using `URLSession` and background task support. Enable true offline playback by downloading episode audio files to local storage and preferring local files during playback.

---

## Current State (Before)

**Simulation-Only Architecture:**
- `DownloadCoordinator` drives an in-memory queue
- `FileManagerService` uses `simulateDownload()` that just sleeps
- No URLSession, no real files, no background support
- Progress updates are fake (simulated percentage increments)
- Playback always streams from remote URLs

**Problems:**
- Users cannot download episodes for offline listening
- No background download support
- No retry logic for failed downloads
- No disk space management
- Testing relies on time-based simulation, not real I/O

---

## Target State (After)

**Production Architecture:**

```
┌─────────────────┐
│  EpisodeListView │ (UI)
└────────┬─────────┘
         │ download/cancel actions
         ▼
┌─────────────────────┐
│ DownloadCoordinator │ (queue management)
└────────┬─────────────┘
         │ enqueue tasks
         ▼
┌─────────────────────┐
│ FileManagerService  │ (URLSession delegate)
└────────┬─────────────┘
         │ URLSessionDownloadTask
         ▼
┌─────────────────────┐
│  Local File Storage │
│ Documents/Downloads/ │
│   {podcastId}/       │
│     {episodeId}.mp3  │
└──────────────────────┘
         │
         ▼
┌─────────────────────┐
│ EnhancedEpisodePlayer│ (prefer local file)
└──────────────────────┘
```

**Key Features:**
- Real URLSession downloads with progress tracking
- Background task support via `BGTaskScheduler`
- Local file storage in app-group container
- Retry logic with exponential backoff (5s, 15s, 60s)
- Concurrent download limits (max 3)
- Disk space checks before download
- Resume support for interrupted downloads
- Playback prefers local files over streaming

---

## Implementation Details

### 1. FileManagerService (URLSession Delegate)

**File**: `Packages/Persistence/Sources/Persistence/FileManagerService.swift`

**Changes:**
- Adopt `URLSessionDownloadDelegate`
- Replace `simulateDownload()` with real `URLSessionDownloadTask`
- Store files to: `Documents/Downloads/{podcastId}/{episodeId}.mp3`
- Emit real progress via `downloadProgressPublisher`
- Handle completion: move file from temp location to final path
- Support background URLSession with identifier `"us.zig.zpod.background-downloads"`

**Delegate Methods:**
```swift
// Progress updates
func urlSession(_ session: URLSession,
                downloadTask: URLSessionDownloadTask,
                didWriteData bytesWritten: Int64,
                totalBytesWritten: Int64,
                totalBytesExpectedToWrite: Int64) {
    let progress = Double(totalBytesWritten) / Double(totalBytesExpectedToWrite)
    // Emit progress to publisher
}

// Completion
func urlSession(_ session: URLSession,
                downloadTask: URLSessionDownloadTask,
                didFinishDownloadingTo location: URL) {
    // Move file to: Documents/Downloads/{podcastId}/{episodeId}.mp3
    // Emit .completed status with file URL
}

// Error handling
func urlSession(_ session: URLSession,
                task: URLSessionTask,
                didCompleteWithError error: Error?) {
    // Emit .failed status
    // Save resume data if available
}
```

**Storage Structure:**
```
Documents/
  Downloads/
    {podcast-uuid-1}/
      {episode-uuid-a}.mp3
      {episode-uuid-b}.mp3
    {podcast-uuid-2}/
      {episode-uuid-c}.mp3
```

**Background Support:**
```swift
// AppDelegate or SceneDelegate
func application(_ application: UIApplication,
                handleEventsForBackgroundURLSession identifier: String,
                completionHandler: @escaping () -> Void) {
    if identifier == "us.zig.zpod.background-downloads" {
        FileManagerService.shared.backgroundCompletionHandler = completionHandler
    }
}
```

---

### 2. DownloadCoordinator (Queue Management)

**File**: `Packages/Networking/Sources/Networking/DownloadCoordinator.swift`

**New Features:**
- Add `localFileURL(for episodeId: UUID) -> URL?` lookup helper
- On completion: stash file path in-memory map
- Emit `.completed` event with file URL
- Add concurrent download limit (max 3 active)
- Retry logic: exponential backoff (5s → 15s → 60s)

**Retry Logic:**
```swift
private func scheduleRetry(task: DownloadTask, attempt: Int) {
    let delays: [TimeInterval] = [5, 15, 60]
    let delay = attempt < delays.count ? delays[attempt] : 60

    DispatchQueue.global().asyncAfter(deadline: .now() + delay) {
        self.retryDownload(task, attempt: attempt + 1)
    }
}
```

**Concurrency Control:**
```swift
private var activeDownloads: [UUID: DownloadTask] = [:]
private let maxConcurrentDownloads = 3

func processQueue() {
    while activeDownloads.count < maxConcurrentDownloads,
          let nextTask = pendingQueue.first {
        startDownload(task: nextTask)
    }
}
```

---

### 3. EnhancedEpisodePlayer (Local File Preference)

**File**: `Packages/PlaybackEngine/Sources/PlaybackEngine/EnhancedEpisodePlayer.swift`

**Change:**
```swift
func play(episode: Episode, duration: TimeInterval) {
    // Prefer local file if available
    let url = downloadCoordinator.localFileURL(for: episode.id) ?? episode.audioURL

    audioEngine?.play(url: url)

    // Log whether streaming or local
    if url != episode.audioURL {
        Logger.shared.info("Playing downloaded file for episode: \(episode.title)")
    }
}
```

---

### 4. UI Wiring (Minimal for Issue 04.1.1)

**File**: `Packages/LibraryFeature/Sources/LibraryFeature/EpisodeListView.swift`

**Changes:**
- Add `@ObservedObject var downloadCoordinator: DownloadCoordinatorBridge`
- Show progress indicator per episode during download
- Add swipe actions: "Download" / "Cancel Download"
- Show download status badge (downloaded, downloading, failed)

**UI Elements:**
```swift
// Per-episode row
HStack {
    EpisodeTitleView(episode)

    if let progress = downloadCoordinator.progress(for: episode.id) {
        ProgressView(value: progress)
            .frame(width: 40)
    }

    if downloadCoordinator.isDownloaded(episode.id) {
        Image(systemName: "arrow.down.circle.fill")
            .foregroundColor(.green)
    }
}
.swipeActions {
    if downloadCoordinator.isDownloaded(episode.id) {
        Button("Delete", role: .destructive) {
            downloadCoordinator.deleteDownload(episode.id)
        }
    } else {
        Button("Download") {
            downloadCoordinator.download(episode)
        }
    }
}
```

---

## Test Plan (TDD)

### Unit Tests: FileManagerService

**File**: `Packages/Persistence/Tests/FileManagerServiceTests.swift`

**Test Cases:**
1. ✅ **Happy path**: Download completes, file exists at expected path
2. ✅ **Network failure**: Download fails, emits `.failed` status
3. ✅ **Disk full**: Download fails with disk space error
4. ✅ **Invalid URL**: Download fails immediately
5. ✅ **Resume data**: Interrupted download saves resume data
6. ✅ **Cancellation**: Mid-download cancel stops task, removes file
7. ✅ **Progress updates**: Emits accurate progress percentages
8. ✅ **Background completion**: Handles background URLSession events

**Test Infrastructure:**
- Use ephemeral URLSession (no disk cache)
- Local HTTP server stub (e.g., `HTTPStubURLProtocol`)
- Mock file system for disk space tests

---

### Unit Tests: DownloadCoordinator

**File**: `Packages/Networking/Tests/DownloadCoordinatorTests.swift`

**Test Cases:**
1. ✅ **Retry logic**: Failed download retries with exponential backoff
2. ✅ **Concurrent limits**: Max 3 downloads active at once
3. ✅ **Queue processing**: Processes pending queue when slot available
4. ✅ **Progress propagation**: Publisher emits progress updates
5. ✅ **Local file lookup**: Returns correct URL for downloaded episode
6. ✅ **Completion handling**: Stashes file path on success

**Test Infrastructure:**
- Mock `FileManagerService` as test double
- Advance time for retry tests (use test scheduler)

---

### Integration Tests

**File**: `IntegrationTests/DownloadIntegrationTests.swift`

**Test Cases:**
1. ✅ **End-to-end download**: Seed episode, download, verify file exists
2. ✅ **Playback preference**: Playback uses local file when available
3. ✅ **Offline playback**: Disable network, play downloaded episode
4. ✅ **Progress UI updates**: UI shows accurate progress during download
5. ✅ **Cancel download**: UI cancel action stops download, removes file

**Test Infrastructure:**
- Real `FileManagerService` with test URLSession
- Real `DownloadCoordinator`
- Test podcast/episode fixtures

---

## Acceptance Criteria (From Spec)

### From `zpod/spec/download.md`:

**Scenario: Download episode for offline listening**
```gherkin
Given I am viewing an episode list
When I swipe left on an episode
And I tap "Download"
Then the episode downloads in the background
And a progress indicator shows download status
And the episode is marked as downloaded when complete
```

**Scenario: Play downloaded episode offline**
```gherkin
Given I have downloaded an episode
When I disable network connectivity
And I tap play on the downloaded episode
Then the episode plays from local storage
And no network request is made
```

**Scenario: Download retry on failure**
```gherkin
Given a download fails due to network error
When the error is transient
Then the download retries with exponential backoff
And succeeds on retry
```

### From `zpod/spec/offline-playback.md`:

**Scenario: Prefer local file over streaming**
```gherkin
Given I have both downloaded and streaming versions available
When I play the episode
Then the downloaded version is used
And no network bandwidth is consumed
```

---

## Known Limitations

1. **No disk space management yet**: Downloads will fail if disk full, but no proactive cleanup
   - **Future**: Implement LRU eviction policy
2. **No download priority**: All downloads treated equally
   - **Future**: Allow user to prioritize specific downloads
3. **No bandwidth throttling**: Downloads use full available bandwidth
   - **Future**: Add bandwidth limit settings (e.g., "Download only on WiFi")
4. **No partial download resumption UI**: Resume happens automatically, but no UI indicator
   - **Future**: Show "Resuming..." status in UI
5. **No download analytics**: No tracking of download success/failure rates
   - **Future**: Add telemetry for debugging

---

## Verification Steps

After implementation:

1. ✅ **Unit tests pass**:
   ```bash
   ./scripts/run-xcode-tests.sh -t FileManagerServiceTests,DownloadCoordinatorTests
   ```

2. ✅ **Integration tests pass**:
   ```bash
   ./scripts/run-xcode-tests.sh -t DownloadIntegrationTests
   ```

3. ✅ **Manual verification**:
   - Subscribe to podcast with episodes
   - Tap download on episode
   - Verify progress updates in UI
   - Verify file exists in `Documents/Downloads/{podcastId}/{episodeId}.mp3`
   - Play downloaded episode (should use local file)
   - Enable airplane mode, play downloaded episode (works offline)
   - Cancel download mid-progress (file removed, status cleared)

4. ✅ **Background download test**:
   - Start download
   - Background the app
   - Wait for download to complete
   - Re-open app, verify file exists

---

## Future Enhancements (Post-28.1.2)

1. **Download queue management UI** (Issue 04.1.2):
   - Add "Downloads" tab showing all active/pending/completed downloads
   - Allow reordering download priority
   - Show total queue size and estimated time

2. **Smart download policies** (Issue 28.2):
   - Auto-download new episodes of subscribed podcasts
   - Download only on WiFi
   - Download only when charging
   - Storage limit settings (e.g., "Keep last 10 episodes")

3. **Download history** (Issue 28.3):
   - Track download success/failure rates per podcast
   - Show download speed and time taken
   - Allow re-download of deleted episodes

4. **Streaming quality fallback** (Issue 28.4):
   - If local file corrupted, fall back to streaming
   - Verify file integrity before playback

---

## References

- **Spec**: `zpod/spec/download.md` - Download scenarios
- **Spec**: `zpod/spec/offline-playback.md` - Offline playback requirements
- **Apple Docs**: [URLSession Background Downloads](https://developer.apple.com/documentation/foundation/url_loading_system/downloading_files_in_the_background)
- **Apple Docs**: [BGTaskScheduler](https://developer.apple.com/documentation/backgroundtasks)

---

## Timeline

- **2026-02-02 10:00 ET**: Design document created
- **2026-02-02 10:30 ET**: Unit tests written (TDD)
- **2026-02-02 11:00 ET**: FileManagerService implementation
- **2026-02-02 11:30 ET**: DownloadCoordinator enhancements
- **2026-02-02 12:00 ET**: EnhancedEpisodePlayer local file preference
- **2026-02-02 14:00 ET**: UI wiring (minimal)
- **2026-02-02 15:00 ET**: Integration tests
- **2026-02-02 16:00 ET**: Manual verification
- **2026-02-02 17:00 ET**: Documentation updates, issue closure

---

**Next Steps**: Write unit tests first (TDD), then implement FileManagerService URLSession delegate.
