# 03.3.2.6 - Test Audio Infrastructure Implementation

**Date**: 2026-01-04  
**Issue**: #03.3.2.6  
**Status**: In Progress  
**Estimated Time**: 2 hours

## Problem Statement

The AVPlayer test suite (PlaybackPositionAVPlayerTests) correctly enables AVPlayer mode but all tests fail because test episodes have no `audioURL` set. Without valid audio URLs, `EnhancedEpisodePlayer` checks for nil audioURL, transitions to `.failed` state, and AVPlayer never starts playback.

### Current Behavior
```swift
// ContentView.swift - createSamplePodcast
Episode(
  id: "st-001",
  title: "Episode 1: Introduction",
  podcastID: id,
  podcastTitle: title,
  duration: 2723  // ‚Üê No audioURL parameter
)
```

**Result**: `episode.audioURL == nil` ‚Üí `EnhancedEpisodePlayer` fails immediately ‚Üí Position never advances ‚Üí Tests timeout.

## Architecture Decision: Environment-Based URL Injection

### Why Not Bundle.main?

**Initial Approach (Incorrect)**:
```swift
// ‚ùå This does NOT work
Bundle.main.url(forResource: "test-episode-short", ...)
```

**Problem**: 
- Audio files are in `zpodUITests` target (test bundle)
- `Bundle.main` refers to `zpod.app` (app bundle)
- App bundle doesn't contain test resources
- URL lookup returns `nil`

### Correct Architecture: Environment Variables + file:// URLs

```mermaid
sequenceDiagram
    participant Test as PlaybackPositionAVPlayerTests
    participant TestBundle as zpodUITests.xctest
    participant Env as Launch Environment
    participant App as ContentView
    participant Player as AVPlayerPlaybackEngine
    
    Test->>TestBundle: Bundle(for: type(of: self)).url(...)
    TestBundle-->>Test: file:///path/to/test-episode-short.m4a
    Test->>Test: Create launch environment vars
    Note right of Test: UITEST_AUDIO_SHORT_PATH="/path/to/..."
    Test->>Env: app.launchEnvironment = {...}
    Test->>App: Launch app
    
    App->>Env: ProcessInfo.processInfo.environment
    Env-->>App: UITEST_AUDIO_SHORT_PATH value
    App->>App: URL(fileURLWithPath: path)
    App->>App: Episode(..., audioURL: fileURL)
    App->>Player: play(episode)
    Player->>Player: AVPlayer streams from file:// URL
    Player-->>Test: Time observer callbacks ‚Üí position updates
```

### Environment Variable Schema

| Variable | Purpose | Example Value |
|----------|---------|---------------|
| `UITEST_AUDIO_SHORT_PATH` | 10 second test audio | `/path/to/test-episode-short.m4a` |
| `UITEST_AUDIO_MEDIUM_PATH` | 15 second test audio | `/path/to/test-episode-medium.m4a` |
| `UITEST_AUDIO_LONG_PATH` | 20 second test audio | `/path/to/test-episode-long.m4a` |

**Key Insight**: AVPlayer can play file:// URLs from any filesystem location, regardless of which bundle owns the files.

## Implementation Phases

### Phase 0: Design & Documentation ‚úÖ
- Create this dev-log with architecture diagram
- Document environment variable schema
- Record decision rationale

### Phase 1: Audio Generation ‚è≥
**Goal**: Create 3 test audio files in 3 formats (AIFF source + M4A + MP3)

**Commands**:
```bash
cd zpodUITests/TestResources/Audio

# Generate AIFF (source files)
say -v "Samantha" -o test-episode-short.aiff \
  "This is test episode short. It contains ten seconds of audio for testing the playback position tracking system." \
  --file-format=AIFF

say -v "Daniel" -o test-episode-medium.aiff \
  "This is test episode medium. It contains fifteen seconds of audio content for testing the audio playback engine. This includes position tracking and seeking functionality." \
  --file-format=AIFF

say -v "Alex" -o test-episode-long.aiff \
  "This is test episode long. It contains twenty seconds of spoken audio for comprehensive testing of the audio playback engine. This file validates position tracking, pause and resume functionality, and seeking operations in the AVPlayer integration tests." \
  --file-format=AIFF

# Convert to M4A (AAC - iOS native format)
afconvert test-episode-short.aiff test-episode-short.m4a -f m4af -d aac
afconvert test-episode-medium.aiff test-episode-medium.m4a -f m4af -d aac
afconvert test-episode-long.aiff test-episode-long.m4a -f m4af -d aac

# Convert to MP3 (universal compatibility)
# TBD: Check for ffmpeg/lame availability
```

**Status**: 
- ‚úÖ AIFF generated (285KB, 461KB, 663KB)
- ‚úÖ M4A generated (32KB, 49KB, 67KB)
- ‚è≥ MP3 pending (tool availability check)

### Phase 2: Xcode Integration ‚è≥ MANUAL
**Action Required**: Add TestResources folder to Xcode project
- Must use folder references (blue icon, not yellow groups)
- Target membership: zpodUITests ONLY
- Subdirectory path must match Bundle.url() calls

### Phase 3: Test Helpers ‚è≥
**Files**:
- `zpodUITests/PlaybackPositionTestSupport.swift`
- `zpodUITests/UITestHelpers.swift`
- `zpodUITests/PlaybackPositionAVPlayerTests.swift`

**New Functions**:
1. `testAudioURL(named:extension:)` - Resolve file URL from test bundle
2. `audioLaunchEnvironment()` - Create env vars dict for launch
3. `validateTestAudioExists()` - Fail fast if audio missing
4. Update `launchWithPlaybackMode(.avplayer)` to inject audio env vars

### Phase 4: App-Side URL Injection ‚è≥
**File**: `Packages/LibraryFeature/Sources/LibraryFeature/ContentView.swift`

**Changes**:
```swift
// Read environment variables
let env = ProcessInfo.processInfo.environment
let shortAudioURL = env["UITEST_AUDIO_SHORT_PATH"].map { URL(fileURLWithPath: $0) }

// Pass to Episode initializer
Episode(..., audioURL: shortAudioURL)
```

**Behavior**:
- In production: Env vars not set ‚Üí audioURL is nil ‚Üí Episode shows "no audio" state
- In UI tests: Env vars set by test ‚Üí audioURL is valid file:// URL ‚Üí AVPlayer plays audio

### Phase 5: Verification ‚è≥
1. Syntax check
2. Single test (testExpandedPlayerProgressAdvancesDuringPlayback)
3. Full suite √ó 3 consecutive runs
4. Bundle size check

### Phase 6: Documentation ‚è≥
1. Finalize this dev-log with results
2. Update test file headers
3. Update issue 03.3.2.6 status
4. Update TestSummary.md

## File Specifications

**Target Sizes**:
- AIFF (source): 285KB, 461KB, 663KB (total: ~1.4MB - kept for regeneration)
- M4A (iOS native): 32KB, 49KB, 67KB (total: 148KB)
- MP3 (universal): TBD (~similar to M4A)

**Total Expected**: < 1.5MB (well under 2MB limit)

## Acceptance Criteria Mapping

| Criterion | Verification | Status |
|-----------|--------------|--------|
| Test audio files created (10-15 seconds, MP3/M4A) | `ls -lh *.{m4a,mp3}` | ‚è≥ M4A done, MP3 pending |
| Files in `zpodUITests/TestResources/Audio/` | Directory exists | ‚úÖ Done |
| Files in `zpodUITests` target | Xcode File Inspector | ‚è≥ Pending manual step |
| Episode factory updated with audioURL | Code review | ‚è≥ Pending Phase 4 |
| AVPlayer tests pass (3/3 runs) | Test execution | ‚è≥ Pending Phase 5 |
| Total size < 2MB | `du -sh` | ‚úÖ 148KB M4A (MP3 TBD) |
| Documented in TestSummary.md | File review | ‚è≥ Pending Phase 6 |

## Open Questions

1. **MP3 generation tool**: ffmpeg available? lame? fallback to online converter?
2. **Keep AIFF sources**: Yes (per requirement) - useful for regeneration
3. **Test both M4A and MP3**: Or pick one format? (Recommendation: M4A only for simplicity)

## Decisions Made

1. ‚úÖ **Architecture**: Environment variable injection (not Bundle.main)
2. ‚úÖ **Audio content**: Text-to-speech (macOS `say` command)
3. ‚úÖ **Voices**: Samantha (short), Daniel (medium), Alex (long)
4. ‚úÖ **Formats**: AIFF source + M4A primary + MP3 optional
5. ‚úÖ **Keep sources**: Yes, AIFF files stay in repo

## Phase 5: AVPlayer Debugging & Resolution

### Phase 5A: Diagnostic Logging ‚úÖ COMPLETED (2026-01-04)

**Goal**: Add logging to understand why AVPlayer won't play audio files.

**Changes Made**:
1. Added OSLog diagnostic logging to `ContentView.createSamplePodcast()`:
   - Logs environment variable paths
   - Checks `FileManager.default.isReadableFile(atPath:)` for each URL
   - Gated by `UITEST_DEBUG_AUDIO=1` flag

2. Added OSLog diagnostic logging to `AVPlayerPlaybackEngine`:
   - Logs `play(from:)` calls with URL details
   - Logs AVPlayerItem status changes (unknown/ready/failed)
   - Logs errors when status becomes `.failed`

3. Enabled `UITEST_DEBUG_AUDIO=1` in `UITestHelpers.launchWithPlaybackMode(.avplayer)`

**Issues Encountered**:
- Logger privacy parameter not supported ‚Üí Removed `privacy: .public`
- OSLog output not visible in test logs (goes to system log only)

**Commits**:
- `84f5c60` - Phase 5A: Add diagnostic logging
- `3b39fc5` - Fix Logger privacy parameter compile errors

**Result**: Diagnostic infrastructure ready, but logs not accessible from test output.

---

### Phase 5B: Sandbox File Access Solutions ‚ö†Ô∏è IN PROGRESS (2026-01-04)

**Goal**: Fix sandbox access issue preventing app from reading test bundle audio files.

**Root Cause** (confirmed by PR feedback):
> "The app under test runs in a different sandbox and cannot read files inside the test runner's container, so URL(fileURLWithPath:) resolves but AVPlayer cannot open the file."

#### Attempt 1: Direct file:// URLs from Test Bundle ‚ùå FAILED
**Implementation**: Pass `Bundle(for: type(of: self)).url(...)` paths directly to app via environment variables.

**Result**: App sandbox blocks access to test bundle files.

**Why It Failed**: iOS sandbox prevents cross-process file access. App cannot read test runner's bundle.

---

#### Attempt 2: Copy to Documents Directory ‚ùå FAILED
**Implementation**: 
```swift
fileManager.urls(for: .documentDirectory, in: .userDomainMask).first
```

**Result**: Same failure - Pause button never appears, AVPlayer doesn't play.

**Why It Failed**: `.documentDirectory` returns **test runner's** Documents directory, not the app's Documents directory. Each process has its own sandboxed Documents folder.

**Commit**: `08e2be3` - Phase 5B: Copy audio files to app container

---

#### Attempt 3: Copy to /tmp Directory ‚ö†Ô∏è CURRENT ATTEMPT
**Implementation**:
```swift
let tmpDir = URL(fileURLWithPath: NSTemporaryDirectory())
  .appendingPathComponent("zpod-ui-test-audio")
```

**Hypothesis**: `/tmp` is accessible to both test runner and app on simulator.

**Result**: Tests still fail (6/6 failures), Pause button never appears.

**Verification Issues**:
- `/tmp/zpod-ui-test-audio/` directory doesn't exist after test run
- Suggests copy operation isn't happening or failing silently
- Cannot verify if `audioLaunchEnvironment()` is being called
- NSLog diagnostics added but output not visible in test logs

**Commits**:
- `30586c3` - Fix protocol constraint for audioLaunchEnvironment()
- `7464115` - Use /tmp directory for audio file sharing
- `d8ea7e8` - Add NSLog diagnostic for audio environment setup

---

### Current Test Results (2026-01-05 01:35 UTC)

**Status**: ALL 6 TESTS FAIL

**Symptom** (identical across all attempts):
```
Waiting 4.0s for "Expanded Player Pause" Button to exist
‚Üí Timeout after 4 seconds
‚Üí XCTAssertTrue failed
```

**Interpretation**:
- Playback never starts
- Play button never transitions to Pause
- AVPlayer is not playing the audio files

**Test Execution Time**: ~2.5 minutes per full suite run (6 tests)

---

### What We Know (Evidence-Based Analysis)

‚úÖ **Confirmed Working**:
1. Audio files exist in test bundle (6 files, 1.6MB total)
2. Copy logic is implemented (`audioLaunchEnvironment()`)
3. App reads environment variables (`ProcessInfo.processInfo.environment`)
4. Episode.audioURL gets assigned (from env var paths)
5. AVPlayerPlaybackEngine.play(from:) gets called (based on code flow)

‚ùå **Confirmed Broken**:
1. AVPlayer never plays audio
2. Files not copied to `/tmp` (directory doesn't exist after test)
3. Diagnostic logs not visible (OSLog/NSLog output issue)

‚ùì **Unknown** (Cannot Verify):
1. Does cast to `(any PlaybackPositionTestSupport & XCTestCase)` succeed?
2. Is `audioLaunchEnvironment()` actually called?
3. Does `FileManager.copyItem()` succeed or fail?
4. Are environment variables actually passed to app?
5. Can app read `/tmp` directory on simulator?

---

### Blocker: Diagnostic Output Not Visible

**Problem**: Cannot debug because logs aren't accessible.

**Why**:
- OSLog (`Logger`) goes to system log, not test output
- NSLog goes to console, not captured by xcodebuild
- Running specific test methods fails (xcodebuild reports "0 tests executed")

**What We Need**:
- Visibility into whether copy succeeds
- Confirmation that environment variables are set
- File existence check in app code

---

### Architecture Options Going Forward

#### Option A: App Bundle (Simplest, Violates Constraint)
**Implementation**: Add audio files to zpod app target.
- ‚úÖ PRO: Guaranteed to work, no sandbox issues
- ‚ùå CON: Violates "test-bundle-only" constraint
- ‚ùå CON: Bloats app bundle by 1.6MB
- üéØ **Use Case**: Temporary workaround to verify AVPlayer works

#### Option B: App Group (Standard, Requires Setup)
**Implementation**: Setup shared App Group container.
- ‚úÖ PRO: Standard iOS pattern for sharing data
- ‚úÖ PRO: Keeps files in test bundle
- ‚ùå CON: Requires entitlements configuration (both app and test targets)
- ‚ùå CON: More complex setup
- üéØ **Use Case**: Production-ready solution

#### Option C: Debug Copy Operation (Current Path)
**Implementation**: Add more diagnostics to understand failure.
- ‚úÖ PRO: May reveal simple fix
- ‚ùå CON: Already spent 3 hours debugging
- ‚ùå CON: Logs not visible (tooling issue)
- üéØ **Use Case**: Worth one more focused attempt

#### Option D: HTTP Server (Complex)
**Implementation**: Run local HTTP server in test process.
- ‚úÖ PRO: No sandbox issues
- ‚úÖ PRO: Keeps files in test bundle
- ‚ùå CON: Significant complexity
- ‚ùå CON: Overkill for this use case
- üéØ **Use Case**: Last resort

---

### Time Spent Summary

| Phase | Time | Status |
|-------|------|--------|
| Phase 0-4 | 4 hours | ‚úÖ Complete (merged to main) |
| Phase 5A | 1 hour | ‚úÖ Complete (diagnostics added) |
| Phase 5B | 3 hours | ‚ö†Ô∏è Blocked (copy not working) |
| **Total** | **8 hours** | **Tests still failing** |

---

## Lessons Learned

(To be filled after implementation)

## Related Issues

- **03.3.2.3**: AVPlayer test suite (unblocked by this issue)
- **03.3.2.4**: CI integration (next step after tests pass)
- **03.3.2.5**: Documentation and cleanup (can proceed in parallel)

---

**Next Action**: Execute revised Phase 5B plan (see below).

---

## REVISED PHASE 5B PLAN (2026-01-05)

### Decision: HTTP Server Approach (Files Stay in Test Bundle)

**Rationale**: 
- 8 hours spent on file copy strategies (all failed due to sandbox)
- Need to verify AVPlayer works without polluting app bundle or production code
- HTTP server keeps files in test bundle only and bypasses sandbox entirely
- AVPlayer gets tested against real streaming (local but deterministic)

**Two-Stage Approach**:

#### Stage 1: HTTP Server Diagnostic (1-2 hours)
**Goal**: Verify AVPlayer works when given accessible HTTP URLs (no sandbox issues).

**Implementation**:
1. **Add HTTP server to UI test setup** (in PlaybackPositionTestSupport):
   - Use `NWListener` from Network framework (already available)
   - Start server in test `setUpWithError()`, stop in `tearDownWithError()`
   - Serve files from test bundle: `/test-episode-short.m4a`, etc.
   - Bind to `127.0.0.1` on random available port

2. **Pass base URL via environment**:
   - Set `UITEST_AUDIO_BASE_URL=http://127.0.0.1:<port>`
   - App constructs URLs: `baseURL + "/test-episode-short.m4a"`

3. **Update app code** (ContentView.createSamplePodcast):
   - Read `UITEST_AUDIO_BASE_URL` from environment
   - If set: `URL(string: baseURL + "/test-episode-short.m4a")`
   - If not set: `audioURL` remains `nil` (existing behavior)
   - **No `Bundle.main` fallback** (keeps production code clean)

4. **Run tests 3x**:
   - If tests PASS ‚Üí AVPlayer works with HTTP URLs ‚Üí Stage 2
   - If tests FAIL ‚Üí AVPlayer has other issues ‚Üí Debug separately

**Why This Works**:
- ‚úÖ Files stay in test bundle only (no app bundle pollution)
- ‚úÖ No sandbox issues (app reads HTTP, not file paths)
- ‚úÖ No production code changes (environment-only approach)
- ‚úÖ Tests real streaming behavior (though localhost)
- ‚úÖ Fully automated (no manual Xcode steps)

#### Stage 2: Productionize or Pivot (After Stage 1)
**Goal**: Deploy long-term solution based on Stage 1 results.

**If Stage 1 passes, choose ONE**:

**Option A: Keep HTTP Server** (Recommended if Stage 1 works)
- Polish HTTP server implementation
- Add error handling and port conflict resolution
- Document in test infrastructure
- ‚úÖ Maintains clean separation, no app changes needed
- Time: 30 minutes (just polish)

**Option B: App Group Container** (Alternative if HTTP has issues)
- Add App Group entitlement to both targets
- Copy files to shared container in test setup
- App reads from shared container
- ‚úÖ Standard iOS pattern, no HTTP complexity
- Time: 1-2 hours

**If Stage 1 fails**:
- Debug AVPlayer separately (audio session, format, buffering)
- Then revisit file access strategy

---

### Stage 1 Implementation Steps (HTTP Server)

#### Step 1: Create HTTP Server Helper (30 minutes)

**File**: `zpodUITests/TestAudioServer.swift` (NEW FILE)

```swift
import Foundation
import Network
import XCTest

/// Lightweight HTTP server for serving test audio files from test bundle.
/// Starts on 127.0.0.1:<random-port> and serves .m4a files via GET requests.
@MainActor
final class TestAudioServer {
  private var listener: NWListener?
  private let testBundle: Bundle
  private let port: NWEndpoint.Port
  
  var baseURL: String {
    "http://127.0.0.1:\(port.rawValue)"
  }
  
  init(testBundle: Bundle) throws {
    self.testBundle = testBundle
    
    // Find available port
    let params = NWParameters.tcp
    params.allowLocalEndpointReuse = true
    
    let listener = try NWListener(using: params, on: .any)
    self.listener = listener
    self.port = listener.port ?? NWEndpoint.Port(integerLiteral: 0)
    
    listener.newConnectionHandler = { [weak self] connection in
      self?.handleConnection(connection)
    }
  }
  
  func start() throws {
    listener?.start(queue: .main)
    // Wait briefly for server to bind
    Thread.sleep(forTimeInterval: 0.1)
  }
  
  func stop() {
    listener?.cancel()
    listener = nil
  }
  
  private func handleConnection(_ connection: NWConnection) {
    connection.start(queue: .main)
    
    // Read HTTP request
    connection.receive(minimumIncompleteLength: 1, maximumLength: 8192) { [weak self] data, _, isComplete, error in
      guard let data = data, let request = String(data: data, encoding: .utf8) else {
        connection.cancel()
        return
      }
      
      self?.handleRequest(request, connection: connection)
    }
  }
  
  private func handleRequest(_ request: String, connection: NWConnection) {
    // Parse: "GET /test-episode-short.m4a HTTP/1.1"
    guard let firstLine = request.components(separatedBy: "\r\n").first,
          let path = firstLine.components(separatedBy: " ").dropFirst().first else {
      send404(connection)
      return
    }
    
    let filename = String(path.dropFirst()) // Remove leading "/"
    
    guard let fileURL = testBundle.url(forResource: filename.replacingOccurrences(of: ".m4a", with: ""), withExtension: "m4a"),
          let fileData = try? Data(contentsOf: fileURL) else {
      send404(connection)
      return
    }
    
    sendFile(fileData, connection: connection)
  }
  
  private func sendFile(_ data: Data, connection: NWConnection) {
    let response = """
    HTTP/1.1 200 OK\r
    Content-Type: audio/mp4\r
    Content-Length: \(data.count)\r
    Connection: close\r
    \r
    
    """.data(using: .utf8)! + data
    
    connection.send(content: response, completion: .contentProcessed { _ in
      connection.cancel()
    })
  }
  
  private func send404(_ connection: NWConnection) {
    let response = """
    HTTP/1.1 404 Not Found\r
    Content-Length: 0\r
    Connection: close\r
    \r
    
    """.data(using: .utf8)!
    
    connection.send(content: response, completion: .contentProcessed { _ in
      connection.cancel()
    })
  }
}
```

#### Step 2: Integrate Server into Tests (15 minutes)

**File**: `zpodUITests/PlaybackPositionTestSupport.swift`

```swift
extension PlaybackPositionTestSupport where Self: XCTestCase {
  
  /// Starts HTTP server and returns launch environment with base URL.
  func audioServerLaunchEnvironment() throws -> [String: String] {
    // Start server (will be stored in test instance variable)
    let server = try TestAudioServer(testBundle: Bundle(for: type(of: self)))
    try server.start()
    
    // Store server reference to keep it alive
    // (requires adding `var audioServer: TestAudioServer?` to conforming test class)
    if let testCase = self as? PlaybackPositionAVPlayerTests {
      testCase.audioServer = server
    }
    
    return ["UITEST_AUDIO_BASE_URL": server.baseURL]
  }
  
  /// Call in tearDownWithError() to stop server
  func stopAudioServer() {
    if let testCase = self as? PlaybackPositionAVPlayerTests {
      testCase.audioServer?.stop()
      testCase.audioServer = nil
    }
  }
}
```

**File**: `zpodUITests/PlaybackPositionAVPlayerTests.swift`

```swift
final class PlaybackPositionAVPlayerTests: XCTestCase, PlaybackPositionTestSupport {
  var app: XCUIApplication!
  var audioServer: TestAudioServer? // Add this
  
  nonisolated override func setUpWithError() throws {
    try super.setUpWithError()
    continueAfterFailure = false
  }
  
  nonisolated override func tearDownWithError() throws {
    // Stop server
    MainActor.assumeIsolated {
      stopAudioServer()
    }
    try super.tearDownWithError()
  }
  
  // Tests remain unchanged...
}
```

#### Step 3: Update UITestHelpers (10 minutes)

**File**: `zpodUITests/UITestHelpers.swift`

In `launchWithPlaybackMode(.avplayer)`:

```swift
case .avplayer:
  overrides["UITEST_DISABLE_AUDIO_ENGINE"] = "0"
  
  // Start HTTP server and get base URL
  if let testCase = self as? (any PlaybackPositionTestSupport & XCTestCase) {
    do {
      let serverEnv = try testCase.audioServerLaunchEnvironment()
      overrides.merge(serverEnv) { _, new in new }
    } catch {
      XCTFail("Failed to start audio server: \(error)")
    }
  }
```

#### Step 4: Update App Code (10 minutes)

**File**: `Packages/LibraryFeature/Sources/LibraryFeature/ContentView.swift`

```swift
private func createSamplePodcast(id: String, title: String) -> Podcast {
  let env = ProcessInfo.processInfo.environment
  
  // Check if running in UI test with HTTP server
  var shortAudioURL: URL?
  if let baseURL = env["UITEST_AUDIO_BASE_URL"] {
    shortAudioURL = URL(string: "\(baseURL)/test-episode-short.m4a")
  }
  
  let sampleEpisodes = [
    Episode(
      id: "st-001",
      title: "Episode 1: Introduction",
      podcastID: id,
      podcastTitle: title,
      audioURL: shortAudioURL, // Will be http://127.0.0.1:<port>/test-episode-short.m4a
      duration: 6.5,
      // ... rest of episode
    ),
    // ... other episodes
  ]
  
  return Podcast(/* ... */)
}
```

#### Step 5: Run Tests (5 minutes)

```bash
./scripts/run-xcode-tests.sh -t PlaybackPositionAVPlayerTests  # Run 1
./scripts/run-xcode-tests.sh -t PlaybackPositionAVPlayerTests  # Run 2
./scripts/run-xcode-tests.sh -t PlaybackPositionAVPlayerTests  # Run 3
```

**Expected Result**: 18/18 passes (AVPlayer streams from localhost HTTP)

#### Step 6: Document & Commit (5 minutes)

```bash
git add -A
git commit -m "[#03.3.2.6] Stage 1: HTTP server for test audio

Implemented lightweight NWListener HTTP server in test bundle.
Serves audio files via http://127.0.0.1:<port>/<filename>.m4a

Results: X/18 tests pass

Next: Stage 2 - Polish or pivot based on results"
```

---

### Decision Matrix: Which Stage 2 Option?

| Option | Time | Complexity | Violates Constraint | Production Impact |
|--------|------|------------|---------------------|-------------------|
| **HTTP Server** | 30 min | Low | ‚ùå No | None |
| **App Group** | 1-2 hrs | Medium | ‚ùå No | None |
| ~~**App Bundle**~~ | ~~0 hrs~~ | ~~Low~~ | ~~‚ö†Ô∏è Yes~~ | ~~Ships test audio~~ |

**Recommendation**: 
1. Try HTTP Server (Stage 1) ‚Üí If works ‚Üí Polish and keep it (Stage 2 Option A)
2. If HTTP has issues ‚Üí Try App Group (Stage 2 Option B)
3. ~~Never use app bundle~~ (violates constraints, pollutes production)

---

### Success Criteria (Overall)

| Criterion | Target | Current Status |
|-----------|--------|----------------|
| Stage 1: AVPlayer plays | 1/1 test passes | ‚ùå Not attempted |
| Full suite pass (run 1) | 6/6 | ‚ùå 0/6 |
| Full suite pass (run 2) | 6/6 | ‚ùå 0/6 |
| Full suite pass (run 3) | 6/6 | ‚ùå 0/6 |
| No flakiness | 18/18 total | ‚ùå 0/18 |
| Files in test bundle | Yes | ‚úÖ Yes (but not accessible) |
| App bundle bloat | < 100KB | TBD (32KB if accepted) |

---

**Ready to execute Stage 1?** This will take ~30 minutes and definitively answer: "Does AVPlayer work when files ARE accessible?"
