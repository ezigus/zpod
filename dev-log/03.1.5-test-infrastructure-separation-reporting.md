# Dev Log – Issue 03.1.5: Test Infrastructure Separation and Enhanced Reporting

## 2025-10-20 23:05 ET – Intent & Design

### Objective
Bring the run script in line with the remaining acceptance criteria by:
- Allowing each regression phase to complete even if earlier steps fail.
- Printing structured Build/Test/Overall summaries on every exit path, including interruptions.
- Capturing SIGINT/ERR to surface partial progress instead of aborting silently.

### Design Notes
- Introduce a lightweight phase runner that wraps each task (syntax, test-plan, builds, package tests, AppSmoke, Integration, UI, lint) and records success/failure without short-circuiting.
- Track phase results in associative arrays keyed by category so summary formatting can compute totals (success, warn, fail, interrupted).
- Apply `trap` handlers for `ERR` and `INT` that flip an `INTERRUPTED=1` flag, append an interruption summary item, and fall through to unified exit logic.
- Replace the existing free-form `print_summary` output with structured sections matching Issue 03.1.5 expectations.

```mermaid
flowchart TD
    A[Setup & Argument Parsing]
    A --> B{Specific Flags?}
    B -- yes --> C[Run Requested Actions]
    B -- no --> D[Default Regression Phases]
    D --> E[Phase Runner (per step)]
    C --> E
    E --> F[Record Phase Result]
    F --> G[Final Summary Formatter]
    G --> H[Print Build/Test/Overall Sections]
    H --> I[Exit with appropriate status]
    subgraph Traps
      J[SIGINT] --> K[Set INTERRUPTED]
      L[ERR] --> M[Record Failure]
      K --> G
      M --> G
    end
```

### Open Questions
- How granular should interrupted phases be reported (per phase vs overall)? Plan to tag incomplete phases with status `interrupted` in the summary array.
- Exit code strategy: prefer first failing phase's status while still running later phases. Will capture first non-zero exit status and return it at the end.

### Next Steps
1. Update issue status to in-progress.
2. Implement phase runner, traps, and structured summary logic in `scripts/run-xcode-tests.sh`.
3. Backfill this log with implementation notes and verification steps.

## 2025-10-20 23:42 ET – Phase Runner & Reporting Implementation

### Work Completed
- Added phase orchestration helpers (`execute_phase`, `begin_phase`) so the default regression runs every step even when a command fails, capturing the first non-zero exit code for the final status.
- Installed shared signal handling (`trap` on `INT`/`ERR`) to print partial summaries and tag the in-flight phase as interrupted rather than terminating silently.
- Rebuilt `print_summary` into structured Build/Test/Lint/Overall sections with aggregate counts and per-group breakdowns (Unit, Integration, UI, Package).
- Hardened package build/test helpers and lint invocations to detect errors without relying on `set -e`, ensuring summaries get written for both successes and failures.
- Front-loaded regression gating so syntax and AppSmoke tests execute first and halt the remaining phases on failure; mirrored the same gating in CI with a preflight job that runs syntax, clean build, and smoke before fanning out.

### Verification
- `bash -n scripts/run-xcode-tests.sh` ✅
- `bash -n scripts/lib/spm.sh` ✅
- `./scripts/run-xcode-tests.sh --self-check` ✅

### Follow-up
- Monitor a full default run to confirm the new summary formatting looks clean end-to-end.

## 2025-10-21 00:52 ET – CI ordering tweak
- Updated the workflow so the macOS UI/integration matrix waits for the package matrix (`needs: [preflight, package-tests]`). Packages now compile/test immediately after the preflight gate and before any UI suites fan out.

## 2025-10-21 08:02 ET – CI selector inputs
- Added a `matrix` input to the workflow_dispatch trigger so we can run `all`, `packages`, `ui`, or `linux` slices on demand. Each downstream job now checks that input before running.

## 2025-10-21 09:47 ET – Layered CI separation design

### Intent
- Break the current `xcode-tests` matrix into dedicated jobs for `AppSmokeTests`, `IntegrationTests`, and the grouped UI suites so logs remain focused per layer.
- Preserve the existing `preflight` gate for syntax/build health, but make downstream jobs depend on it instead of letting AppSmoke ride inside the gate.
- Update Issue 03.1.5 acceptance criteria to reflect that CI coverage across the layered jobs supersedes the need for a redundant "no-arguments" regression job.

### Job Structure
```mermaid
flowchart LR
    P[preflight]
    P --> U[unit-tests]
    P --> PK[package-tests]
    U --> I[integration-tests]
    U --> UI[ui-tests (matrix)]
    PK --> UI
    PK --> I
```

### Notes
- `unit-tests` provisions its own simulator, runs `./scripts/run-xcode-tests.sh -t AppSmokeTests`, and shares gating status via `needs`.
- `integration-tests` becomes a standalone job (no longer inside the UI matrix) and runs only `-t IntegrationTests`.
- `ui-tests` keeps the existing suite matrix, limited to UI-only bundles, and still fans out after packages to balance runtime.
- Acceptance criteria update will clarify that CI already executes the full regression suite once the three jobs plus packages and Linux syntax pass.

## 2025-10-27 15:48 ET – Playback UI job failure analysis

### Observation
- GitHub Actions `UITests-Playback` job failed with `ld: library '.../zpod.app/zpod' not found` while linking the IntegrationTests bundle, causing xcodebuild to exit with status 65 before any UI cases executed.
- The dedicated UI jobs pass `-only-testing:zpodUITests/...`, but Xcode still schedules the `IntegrationTests` bundle for build because the `zpod` scheme includes it.

### Decision
- When invoking the script for UI-only slices, append `-skip-testing:IntegrationTests` so the Integration test bundle is neither built nor linked in those legs. This keeps the separation we just added and prevents host-app ordering issues from bleeding across layers.

### Next Steps
- Patch `run-xcode-tests.sh` to inject the skip flag for `zpodUITests` targets and rerun the affected suite locally to confirm the linker failure disappears.

## 2025-10-27 16:28 ET – UI suite verification pass
- `./scripts/run-xcode-tests.sh -t zpodUITests/PlaybackUITests` ✅ – confirms the linker skip flag keeps the playback run green.
- `./scripts/run-xcode-tests.sh -t zpodUITests/BatchOperationUITests` ✅ – no build leakage from IntegrationTests.
- `./scripts/run-xcode-tests.sh -t zpodUITests/ContentDiscoveryUITests` ✅ – full suite passes with the new flag.
- `./scripts/run-xcode-tests.sh -t zpodUITests/SwipeConfiguration{Persistence,Execution,PresetCycling,ActionManagement}UITests` ✅ – each long-running swipe configuration scenario completes without the prior status 65 failure.

## 2025-10-27 20:55 ET – Content discovery retries flake

### Failure Snapshot
- CI rerun failed in `zpodUITests/ContentDiscoveryUITests` with two cases timing out:
  - `testRSSURLInput_GivenRSSSheet_WhenEnteringURL_ThenAcceptsInput` spun for ~140s trying to reacquire the URL text field after typing, eventually hitting the XCTest snapshot timeout.
  - `testSearchFieldInput_GivenSearchInterface_WhenTyping_ThenAcceptsInput` typed `"Swift Talk"`, but the predicate waiter never completed even though the field held the value; the fallback static text element also failed to appear before timeout.
- Local reruns pass quickly, pointing to race conditions in CI around focus stabilization and asynchronous field updates.

### Design Notes
- Introduce a reusable helper to assert keyboard focus and wait for text-field value propagation using polling rather than snapshot-heavy predicates, reducing the chances of hitting the 120s timeout path.
- For the RSS sheet scenario, re-query the URL field after typing (the sheet re-renders its hierarchy) and fall back to verifying via `value` or an exact-match static text.
- For search typing, replace the ad-hoc `XCTNSPredicateExpectation` with the shared helper and allow configurable timeouts scaled by `adaptiveTimeout` so slower simulators still meet the condition.
- Add defensive clear-before-type logic so residual text or placeholder ellipses do not interfere with value assertions.

### Planned Implementation
```mermaid
flowchart TD
    A[Focus field] --> B[Ensure keyboard present]
    B --> C[Clear existing text]
    C --> D[Type desired string]
    D --> E[waitForTextMatch helper]
    E --> F{Condition met?}
    F -- yes --> G[Assert success]
    F -- no --> H[Surface diagnostics & fail fast]
```

### Next Steps
1. Add a `waitForText` utility (and optional `clearAndType`) in the `SmartUITesting` helpers so all UI suites can reuse the stabilization logic.
2. Refactor the two failing tests to call the new helper instead of bespoke predicates, and rerun the ContentDiscovery suite locally to confirm stability before pushing.
3. Capture one more local `./scripts/run-xcode-tests.sh -t zpodUITests/ContentDiscoveryUITests` run after the refactor to ensure both the RSS and search scenarios finish without timing out.
